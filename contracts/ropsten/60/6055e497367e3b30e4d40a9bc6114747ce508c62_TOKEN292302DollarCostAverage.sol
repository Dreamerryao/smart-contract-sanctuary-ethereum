/**
 *Submitted for verification at Etherscan.io on 2022-04-29
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;  abstract contract Context {    function _msgSender() internal view virtual returns (address) {        return msg.sender;    }    function _msgData() internal view virtual returns (bytes calldata) {        return msg.data;    }}   library SafeMath {        function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            uint256 c = a + b;            if (c < a) return (false, 0);            return (true, c);        }    }        function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b > a) return (false, 0);            return (true, a - b);        }    }        function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {                                                if (a == 0) return (true, 0);            uint256 c = a * b;            if (c / a != b) return (false, 0);            return (true, c);        }    }        function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b == 0) return (false, 0);            return (true, a / b);        }    }        function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b == 0) return (false, 0);            return (true, a % b);        }    }        function add(uint256 a, uint256 b) internal pure returns (uint256) {        return a + b;    }        function sub(uint256 a, uint256 b) internal pure returns (uint256) {        return a - b;    }        function mul(uint256 a, uint256 b) internal pure returns (uint256) {        return a * b;    }        function div(uint256 a, uint256 b) internal pure returns (uint256) {        return a / b;    }        function mod(uint256 a, uint256 b) internal pure returns (uint256) {        return a % b;    }        function sub(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        unchecked {            require(b <= a, errorMessage);            return a - b;        }    }        function div(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        unchecked {            require(b > 0, errorMessage);            return a / b;        }    }        function mod(        uint256 a,        uint256 b,        string memory errorMessage    ) internal pure returns (uint256) {        unchecked {            require(b > 0, errorMessage);            return a % b;        }    }}   library Address {        function isContract(address account) internal view returns (bool) {                                uint256 size;        assembly {            size := extcodesize(account)        }        return size > 0;    }        function sendValue(address payable recipient, uint256 amount) internal {        require(address(this).balance >= amount, "Address: insufficient balance");        (bool success, ) = recipient.call{value: amount}("");        require(success, "Address: unable to send value, recipient may have reverted");    }        function functionCall(address target, bytes memory data) internal returns (bytes memory) {        return functionCall(target, data, "Address: low-level call failed");    }        function functionCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        return functionCallWithValue(target, data, 0, errorMessage);    }        function functionCallWithValue(        address target,        bytes memory data,        uint256 value    ) internal returns (bytes memory) {        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");    }        function functionCallWithValue(        address target,        bytes memory data,        uint256 value,        string memory errorMessage    ) internal returns (bytes memory) {        require(address(this).balance >= value, "Address: insufficient balance for call");        require(isContract(target), "Address: call to non-contract");        (bool success, bytes memory returndata) = target.call{value: value}(data);        return verifyCallResult(success, returndata, errorMessage);    }        function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {        return functionStaticCall(target, data, "Address: low-level static call failed");    }        function functionStaticCall(        address target,        bytes memory data,        string memory errorMessage    ) internal view returns (bytes memory) {        require(isContract(target), "Address: static call to non-contract");        (bool success, bytes memory returndata) = target.staticcall(data);        return verifyCallResult(success, returndata, errorMessage);    }        function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {        return functionDelegateCall(target, data, "Address: low-level delegate call failed");    }        function functionDelegateCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        require(isContract(target), "Address: delegate call to non-contract");        (bool success, bytes memory returndata) = target.delegatecall(data);        return verifyCallResult(success, returndata, errorMessage);    }        function verifyCallResult(        bool success,        bytes memory returndata,        string memory errorMessage    ) internal pure returns (bytes memory) {        if (success) {            return returndata;        } else {                        if (returndata.length > 0) {                                assembly {                    let returndata_size := mload(returndata)                    revert(add(32, returndata), returndata_size)                }            } else {                revert(errorMessage);            }        }    }}   abstract contract Ownable is Context {    address private _owner;    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);        constructor() {        _transferOwnership(_msgSender());    }        function owner() public view virtual returns (address) {        return _owner;    }        modifier onlyOwner() {        require(owner() == _msgSender(), "[error][ownable] caller is not the owner");        _;    }        function renounceOwnership() public virtual onlyOwner {        _transferOwnership(address(0));    }        function transferOwnership(address newOwner) public virtual onlyOwner {        require(newOwner != address(0), "[error][ownable] new owner is the zero address");        _transferOwnership(newOwner);    }        function _transferOwnership(address newOwner) internal virtual {        address oldOwner = _owner;        _owner = newOwner;        emit OwnershipTransferred(oldOwner, newOwner);    }}   abstract contract ReentrancyGuard {                                            uint256 private constant _NOT_ENTERED = 1;    uint256 private constant _ENTERED = 2;    uint256 private _status;    constructor() {        _status = _NOT_ENTERED;    }        modifier nonReentrant() {                require(_status != _ENTERED, "ReentrancyGuard: reentrant call");                _status = _ENTERED;        _;                        _status = _NOT_ENTERED;    }}   interface IERC20 {        function totalSupply() external view returns (uint256);        function balanceOf(address account) external view returns (uint256);        function transfer(address recipient, uint256 amount) external returns (bool);        function allowance(address owner, address spender) external view returns (uint256);        function approve(address spender, uint256 amount) external returns (bool);        function transferFrom(        address sender,        address recipient,        uint256 amount    ) external returns (bool);        event Transfer(address indexed from, address indexed to, uint256 value);        event Approval(address indexed owner, address indexed spender, uint256 value);}interface IERC20Metadata is IERC20 {        function name() external view returns (string memory);        function symbol() external view returns (string memory);        function decimals() external view returns (uint8);}   abstract contract ERC20 is Context, IERC20, IERC20Metadata {    mapping(address => uint256) private _balances;    mapping(address => mapping(address => uint256)) private _allowances;    uint256 private _totalSupply;    string private _name;    string private _symbol;        constructor(string memory name_, string memory symbol_) {        _name = name_;        _symbol = symbol_;    }        function name() public view virtual override returns (string memory) {        return _name;    }        function symbol() public view virtual override returns (string memory) {        return _symbol;    }        function decimals() public view virtual override returns (uint8) {        return 18;    }        function totalSupply() public view virtual override returns (uint256) {        return _totalSupply;    }        function balanceOf(address account) public view virtual override returns (uint256) {        return _balances[account];    }        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {        _transfer(_msgSender(), recipient, amount);        return true;    }        function allowance(address owner, address spender) public view virtual override returns (uint256) {        return _allowances[owner][spender];    }        function approve(address spender, uint256 amount) public virtual override returns (bool) {        _approve(_msgSender(), spender, amount);        return true;    }        function transferFrom(        address sender,        address recipient,        uint256 amount    ) public virtual override returns (bool) {        _transfer(sender, recipient, amount);        uint256 currentAllowance = _allowances[sender][_msgSender()];        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");        unchecked {            _approve(sender, _msgSender(), currentAllowance - amount);        }        return true;    }        function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);        return true;    }        function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {        uint256 currentAllowance = _allowances[_msgSender()][spender];        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");        unchecked {            _approve(_msgSender(), spender, currentAllowance - subtractedValue);        }        return true;    }        function _transfer(        address sender,        address recipient,        uint256 amount    ) internal virtual {        require(sender != address(0), "ERC20: transfer from the zero address");        require(recipient != address(0), "ERC20: transfer to the zero address");        _beforeTokenTransfer(sender, recipient, amount);        uint256 senderBalance = _balances[sender];        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");        unchecked {            _balances[sender] = senderBalance - amount;        }        _balances[recipient] += amount;        emit Transfer(sender, recipient, amount);        _afterTokenTransfer(sender, recipient, amount);    }        function _mint(address account, uint256 amount) internal virtual {        require(account != address(0), "ERC20: mint to the zero address");        _beforeTokenTransfer(address(0), account, amount);        _totalSupply += amount;        _balances[account] += amount;        emit Transfer(address(0), account, amount);        _afterTokenTransfer(address(0), account, amount);    }        function _burn(address account, uint256 amount) internal virtual {        require(account != address(0), "ERC20: burn from the zero address");        _beforeTokenTransfer(account, address(0), amount);        uint256 accountBalance = _balances[account];        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");        unchecked {            _balances[account] = accountBalance - amount;        }        _totalSupply -= amount;        emit Transfer(account, address(0), amount);        _afterTokenTransfer(account, address(0), amount);    }        function _approve(        address owner,        address spender,        uint256 amount    ) internal virtual {        require(owner != address(0), "ERC20: approve from the zero address");        require(spender != address(0), "ERC20: approve to the zero address");        _allowances[owner][spender] = amount;        emit Approval(owner, spender, amount);    }        function _beforeTokenTransfer(        address from,        address to,        uint256 amount    ) internal virtual {}        function _afterTokenTransfer(        address from,        address to,        uint256 amount    ) internal virtual {}}   interface IUniswapV2Factory {    event PairCreated(address indexed token0, address indexed token1, address pair, uint);    function feeTo() external view returns (address);    function feeToSetter() external view returns (address);    function getPair(address tokenA, address tokenB) external view returns (address pair);    function allPairs(uint) external view returns (address pair);    function allPairsLength() external view returns (uint);    function createPair(address tokenA, address tokenB) external returns (address pair);    function setFeeTo(address) external;    function setFeeToSetter(address) external;}interface IUniswapV2Pair {    event Approval(address indexed owner, address indexed spender, uint value);    event Transfer(address indexed from, address indexed to, uint value);    function name() external pure returns (string memory);    function symbol() external pure returns (string memory);    function decimals() external pure returns (uint8);    function totalSupply() external view returns (uint);    function balanceOf(address owner) external view returns (uint);    function allowance(address owner, address spender) external view returns (uint);    function approve(address spender, uint value) external returns (bool);    function transfer(address to, uint value) external returns (bool);    function transferFrom(address from, address to, uint value) external returns (bool);    function DOMAIN_SEPARATOR() external view returns (bytes32);    function PERMIT_TYPEHASH() external pure returns (bytes32);    function nonces(address owner) external view returns (uint);    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;    event Mint(address indexed sender, uint amount0, uint amount1);    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);    event Swap(        address indexed sender,        uint amount0In,        uint amount1In,        uint amount0Out,        uint amount1Out,        address indexed to    );    event Sync(uint112 reserve0, uint112 reserve1);    function MINIMUM_LIQUIDITY() external pure returns (uint);    function factory() external view returns (address);    function token0() external view returns (address);    function token1() external view returns (address);    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);    function price0CumulativeLast() external view returns (uint);    function price1CumulativeLast() external view returns (uint);    function kLast() external view returns (uint);    function mint(address to) external returns (uint liquidity);    function burn(address to) external returns (uint amount0, uint amount1);    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;    function skim(address to) external;    function sync() external;    function initialize(address, address) external;}interface IUniswapV2Router01 {    function factory() external pure returns (address);    function WETH() external pure returns (address);    function addLiquidity(        address tokenA,        address tokenB,        uint amountADesired,        uint amountBDesired,        uint amountAMin,        uint amountBMin,        address to,        uint deadline    ) external returns (uint amountA, uint amountB, uint liquidity);    function addLiquidityETH(        address token,        uint amountTokenDesired,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);    function removeLiquidity(        address tokenA,        address tokenB,        uint liquidity,        uint amountAMin,        uint amountBMin,        address to,        uint deadline    ) external returns (uint amountA, uint amountB);    function removeLiquidityETH(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external returns (uint amountToken, uint amountETH);    function removeLiquidityWithPermit(        address tokenA,        address tokenB,        uint liquidity,        uint amountAMin,        uint amountBMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountA, uint amountB);    function removeLiquidityETHWithPermit(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountToken, uint amountETH);    function swapExactTokensForTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external returns (uint[] memory amounts);    function swapTokensForExactTokens(        uint amountOut,        uint amountInMax,        address[] calldata path,        address to,        uint deadline    ) external returns (uint[] memory amounts);    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)        external        payable        returns (uint[] memory amounts);    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)        external        returns (uint[] memory amounts);    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)        external        returns (uint[] memory amounts);    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)        external        payable        returns (uint[] memory amounts);    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);}interface IUniswapV2Router02 is IUniswapV2Router01 {    function removeLiquidityETHSupportingFeeOnTransferTokens(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external returns (uint amountETH);    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(        address token,        uint liquidity,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline,        bool approveMax, uint8 v, bytes32 r, bytes32 s    ) external returns (uint amountETH);    function swapExactTokensForTokensSupportingFeeOnTransferTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external;    function swapExactETHForTokensSupportingFeeOnTransferTokens(        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external payable;    function swapExactTokensForETHSupportingFeeOnTransferTokens(        uint amountIn,        uint amountOutMin,        address[] calldata path,        address to,        uint deadline    ) external;} abstract contract RoleBasedAccessControl is Context, Ownable{    mapping(string => mapping(address => bool)) private _roleToAddress;    mapping(string => bool) private _role;    string[] _roles;            modifier onlyRole(string memory pRole){            require(_roleToAddress[pRole][_msgSender()], "[error][role based access control] only addresses assigned this role can access this function!");            _;        }        modifier onlyRoles(string[] memory pRoles){            for(uint256 i=0; i<pRoles.length; i++){                require(_roleToAddress[pRoles[i]][_msgSender()], "[error][role based access control] only addresses assigned this role can access this function!");            }            _;        }        modifier onlyRolesOr(string[] memory pRoles){            bool rolePresent = false;            for(uint256 i=0; i<pRoles.length; i++){                rolePresent = rolePresent || _roleToAddress[pRoles[i]][_msgSender()];            }            require(rolePresent, "[error][role based access control] only addresses assigned this role can access this function!");            _;        }        modifier onlyRoleOrOwner(string memory pRole){            require(_roleToAddress[pRole][_msgSender()] || owner() == _msgSender(), "[error][role based access control] only addresses assigned this role or the owner can access this function!");            _;        }            function registerRole(string memory pRole) public virtual onlyRoleOrOwner("root"){            _addRole(pRole);        }        function registerRoleAddresses(string memory pRole, address[] memory pMembers) public virtual onlyRoleOrOwner("root"){            _addRole(pRole);            for(uint256 i=0; i<pMembers.length; i++){                _roleToAddress[pRole][pMembers[i]] = true;            }        }        function registerRoleAddress(string memory pRole, address pMember) public virtual onlyRoleOrOwner("root"){            _addRole(pRole);            _roleToAddress[pRole][pMember] = true;        }        function removeRoleAddress(string memory pRole, address pMember) public virtual onlyRoleOrOwner("root"){            _addRole(pRole);            _roleToAddress[pRole][pMember] = false;        }            function addRoleAddress(string memory pRole, address pMember) public virtual onlyRoleOrOwner("root"){            _addRole(pRole);            _roleToAddress[pRole][pMember] = true;        }                function hasRoleAddress(string memory pRole, address pAddress) public virtual returns(bool){            return(_roleToAddress[pRole][pAddress]);        }        function _addRole(string memory pRole) private{        if(!_role[pRole]){            _role[pRole] = true;            _roles.push(pRole);        }    }}library Array256{    using Array256 for uint256[];    function del(uint256[] storage self, uint256 i) internal{        self[i] = self[self.length - 1];        self.pop();    }    function delval(uint256[] storage self, uint256 v) internal{        for(uint256 i=0; i<self.length; i++){            if(self[i] == v){                self.del(i);            }        }    }    function max(uint256[] storage self) internal view returns(uint256){        uint256 _max = (            (self.length > 0) ? self[0] : 0        );        for(uint256 i=0; i<self.length; i++){            if(self[i] > _max){                _max = self[i];            }        }        return(_max);    }    function min(uint256[] storage self) internal view returns(uint256){        uint256 _min = (            (self.length > 0) ? self[0] : 0        );        for(uint256 i=0; i<self.length; i++){            if(self[i] < _min){                _min = self[i];            }        }        return(_min);    }    function includes(uint256[] storage self, uint256 x) internal view returns(bool){        for(uint256 i=0; i<self.length; i++){            if(self[i] == x){                return(true);            }        }        return(false);    }    function fisherYatesShuffle(uint256[] storage self, uint256 r) internal{        uint256 n; uint256 c; uint256 e;        for(uint256 i=self.length-1; i>0; i--){            n = r % (self.length - 1);            c = self[i]; e = self[n];            self[i] = e; self[n] = c;        }    }    function _sort(uint256[] memory _self, uint256 left, uint256 right) private{        uint256 i = left;        uint256 j = right;          if(i == j){            return;        }        uint256 n = _self[uint256(left + (right - left) / 2)];        while(i <= j){            while(_self[uint256(i)] < n) i++;            while (n < _self[uint256(j)]) j--;            if(i <= j){                (_self[uint256(i)], _self[uint256(j)]) = (_self[uint256(j)], _self[uint256(i)]);                i++;                j--;            }        }        if(left < j){            _sort(_self, left, j);        }        if(i < right){            _sort(_self, i, right);        }    }    function sort(uint256[] storage self) internal{        uint256[] memory _self = self;        _sort(_self, 0, _self.length);        for(uint l=0; l<_self.length; l++){            self[l] = _self[l];        }    }}library ArrayAddress{    using ArrayAddress for address[];    function del(address[] storage self, uint256 i) internal{        self[i] = self[self.length - 1];        self.pop();    }    function delval(address[] storage self, address v) internal{        for(uint256 i=0; i<self.length; i++){            if(self[i] == v){                self.del(i);            }        }    }    function includes(address[] storage self, address x) internal view returns(bool){        for(uint256 i=0; i<self.length; i++){            if(self[i] == x){                return(true);            }        }        return(false);    }}contract Util is RoleBasedAccessControl{            ERC20 private _token;            mapping(string => mapping(address => bool)) private _paramForAddressIsBool;        constructor(address pContract){                    _paramForAddressIsBool['burn'][address(0)] = true;            _paramForAddressIsBool['burn'][address(0xdEaD)] = true;                    registerRoleAddress("util", _msgSender());            registerRoleAddress("util", pContract);    }                    function setParamForAddressBool(string memory pParam, address pAddress, bool pBool) public onlyRole("util"){        _paramForAddressIsBool[pParam][pAddress] = pBool;    }    function setParamForAddressesBool(string memory pParam, address[] memory pAddress, bool pBool) public onlyRole("util"){        for(uint256 i=0; i<pAddress.length; i++){            _paramForAddressIsBool[pParam][pAddress[i]] = pBool;        }    }    function transfer(address pTo, uint256 pAmount) public onlyRole("util") returns(bool){        address payable to = payable(pTo);        (bool sent, ) = to.call{value:pAmount}("");        return(sent);    }                function isAddressBurn(address pAddress) public view returns(bool){        if(_paramForAddressIsBool['burn'][pAddress]){            return(true);        }        return(false);    }    function isAddressParam(string memory pParam, address pAddress) public view returns(bool){        if(_paramForAddressIsBool[pParam][pAddress]){            return(true);        }        return(false);    }    event Error(string error);    function emitError(string memory pError) public{        emit Error(pError);    }}contract TOKEN292302DollarCostAverage is Context, Ownable, ReentrancyGuard, RoleBasedAccessControl{            using SafeMath for uint256;         using Address for address;         using Array256 for uint256[];        using ArrayAddress for address[];            address public ADDRESS_ZERO = address(0);         address public ADDRESS_BURN = 0x000000000000000000000000000000000000dEaD;         address public ADDRESS_TOKEN;         address public ADDRESS_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;             IUniswapV2Router02 private _router;         ERC20 private _token;         Util private _util;             uint256 public FLOAT_PRECISION = 10**12;        mapping(string => string) public ERROR;        bool private _swapping;        struct Token{            string name;            string symbol;            uint256 decimals;            ERC20 erc20;            address[] path;            bool enabled;        }        struct Job{            uint256 id;            address owner;            address token;            string pattern;            uint256 amount;            bool enabled;        }        uint256 public INDEX;        mapping(address => uint256) public BALANCE;        mapping(address => Token) public TOKENS;        mapping(uint256 => Job) public JOBS;        mapping(address => uint256[]) private _walletJobs;        uint256[] public ACTIVE;            event TOKEN292302DollarCostAverageSwap(address indexed token, address indexed wallet, uint256 native, uint256 amount, uint256 gas);    constructor(address pToken){                    ADDRESS_TOKEN = pToken;            _token = ERC20(ADDRESS_TOKEN);            _router = IUniswapV2Router02(ADDRESS_ROUTER);            _util = new Util(address(this));                    ERROR['NotAValidToken'] = '[error][dca] Not a valid token!';            ERROR['NoBalance'] = '[error][dca] you do not have any ETH in this contract!';            ERROR['WithdrawMoreThanOwn'] = '[error][dca] you cant withdraw more ETH than you have!';            ERROR['NativeTransferFailed'] = '[error][dca] transfer of ETH failed!';            ERROR['NotEnoughBalance'] = '[error][dca] you do not have enough ETH to run this job!';            ERROR['NotAValidJobID'] = '[error][dca] this ID is not valid!';            ERROR['OnlyOwner'] = '[error][dca] only the owner can call this function!';                    registerRoleAddress("root", _msgSender());            registerRoleAddress("API", _msgSender());            renounceOwnership();     }                function addToken(address pToken, address[] memory pPath) public nonReentrant onlyRole("root"){        _addToken(pToken, pPath);    }    function swap(address pToken, address[] memory pWallets, uint256[] memory pAmounts, uint256 pGas) public nonReentrant onlyRole("API"){        require(_validToken(pToken), ERROR['NotAValidToken']);        uint256 amount; uint256 gas;        (pWallets, pAmounts, amount, gas) = _skip(pWallets, pAmounts, pGas);        if(pWallets.length > 0){            uint256 tokens = _swap(pToken, amount);            uint256 cake = tokens; uint256 slice; uint256 share; uint256 cost;            for(uint256 i=0; i<pWallets.length; i++){                cost = pAmounts[i].add(gas);                if(BALANCE[pWallets[i]] > cost){                    share = _share(pAmounts[i], amount);                    slice = _slice(share, tokens);                    if(slice > cake){                        slice = cake;                    }                    TOKENS[pToken].erc20.transfer(pWallets[i], slice);                    _util.transfer(_msgSender(), gas);                    BALANCE[pWallets[i]] = BALANCE[pWallets[i]].sub(cost);                    cake = cake.sub(slice);                                            emit TOKEN292302DollarCostAverageSwap(pToken, pWallets[i], pAmounts[i], slice, gas);                }            }        }    }                receive() external nonReentrant payable{        BALANCE[_msgSender()] = BALANCE[_msgSender()].add(msg.value);    }    function path(address[] memory pPath) public view returns(bool){        ERC20 itoken = ERC20(pPath[0]);        try _router.getAmountsOut(1 * (10**itoken.decimals()), pPath){            return(true);        }catch{            return(false);        }    }                function _validToken(address pToken) private view returns(bool){        if(TOKENS[pToken].enabled){            return(true);        }        return(false);    }    function _addToken(address pToken, address[] memory pPath) private{        if(TOKENS[pToken].decimals <= 0){            Token storage _t = TOKENS[pToken];            _t.erc20 = ERC20(pToken);            _t.name = _t.erc20.name();            _t.symbol = _t.erc20.symbol();            _t.decimals = _t.erc20.decimals();            _t.path = pPath;            _t.enabled = true;        }else{            TOKENS[pToken].path = pPath;            TOKENS[pToken].enabled = true;        }    }    function _share(uint256 pAmount, uint256 pTotal) private view returns(uint256){        return((pAmount.mul(FLOAT_PRECISION)).div(pTotal));    }    function _slice(uint256 pShare, uint256 pTotal) private view returns(uint256){        return((pShare.mul(pTotal)).div(FLOAT_PRECISION));    }    function _gas(uint256 pGas, uint256 pJobs) private view returns(uint256){        return(pGas.mul(FLOAT_PRECISION).div(pJobs).div(FLOAT_PRECISION));    }    function _swap(address pToken, uint256 pAmount) private returns(uint256){        uint256 balanceTokenPreSwap = TOKENS[pToken].erc20.balanceOf(address(this));        _router.swapExactETHForTokensSupportingFeeOnTransferTokens{value:pAmount}(            0,            TOKENS[pToken].path,            address(this),            block.timestamp        );        return((TOKENS[pToken].erc20.balanceOf(address(this))).sub(balanceTokenPreSwap));    }    function _skip(address[] memory pWallets, uint256[] memory pAmounts, uint256 pGas) private view returns(address[] memory, uint256[] memory, uint256, uint256){        uint256 max = pWallets.length; uint256 gas; uint256 i; uint256 amount; uint256 cost;        while(i<pWallets.length){            gas = _gas(pGas, max);            cost = pAmounts[i].add(gas);            if(BALANCE[pWallets[i]] > cost){                i++;            }else{                i = 0;                if(max > 0 ) max--;                (pWallets, pAmounts) = _reduce(pWallets, pAmounts, i);            }        }        for(i=0; i<pAmounts.length; i++){            amount = amount.add(pAmounts[i]);        }        return(pWallets, pAmounts, amount, (            (max > 0) ? _gas(pGas, max) : pGas        ));    }    function _reduce(address[] memory pWallets, uint256[] memory pAmounts, uint256 pSkip) private pure returns(address[] memory, uint256[] memory){        address[] memory wallets = new address[](pWallets.length - 1);        uint256[] memory amounts = new uint256[](pAmounts.length - 1);        uint256 j;        for(uint256 i=0; i<pWallets.length; i++){            if(i != pSkip){                wallets[j] = pWallets[i];                amounts[j] = pAmounts[i];                j++;            }        }        return(wallets, amounts);    }}