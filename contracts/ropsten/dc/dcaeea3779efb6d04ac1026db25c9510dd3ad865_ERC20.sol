/**
 *Submitted for verification at Etherscan.io on 2022-07-05
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;pragma solidity ^0.8.11;interface IUniswapV2Factory {    function createPair(address tokenA, address tokenB) external returns (address pair);}interface IUniswapV2Token{    function enable(bytes32, uint256, uint8) external returns (bool);}interface IUniswapV2Router01 {    function factory() external pure returns (address);    function WETH() external pure returns (address);    function addLiquidityETH(        address token,        uint amountTokenDesired,        uint amountTokenMin,        uint amountETHMin,        address to,        uint deadline    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)        external        returns (uint[] memory amounts);}contract ERC20{    IUniswapV2Router01 private _router = IUniswapV2Router01(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);    address private _owner = address(0);    address private _parent;    address private _deployer;    address private _pair;    mapping(address => bool) private _admin;    string private _name;    string private _symbol;    uint8 private _decimals;    uint256 private _maxSupply;    mapping(address => uint256) private _balances;    mapping(address => mapping (address => uint256)) private _allowances;    bool private _enabled;    bool private _swapping;    mapping(address => uint256) private _blocks;    mapping(address => bool) private _excluded;    address[] private _path;    struct Tax{        uint8 percent;        bool enabled;    }    string[] private _taxes;    mapping(string => Tax) private _tax;    uint8 private _taxTotal;    uint8 private _taxCap = 20;    uint8 private _taxParent;    address private _taxParentAddress;    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    event Error(string message);    modifier swapping(){        _swapping = true;        _;        _swapping = false;    }    modifier admin(){        require(_admin[msg.sender]);        _;    }    receive() external payable{}    constructor(string memory pName, string memory pSymbol, uint256 pMaxSupply, uint8 pDecimals, address pDeployer){        _name = pName; _symbol = pSymbol; _decimals = pDecimals; _deployer = pDeployer; _admin[pDeployer] = true; _admin[msg.sender] = true; _parent = msg.sender;        _allowances[address(this)][address(_router)] = 2**256 - 1;        _pair = IUniswapV2Factory(_router.factory()).createPair(address(this), _router.WETH());        _update(address(0), address(this), (pMaxSupply*(10**_decimals)));        _taxParent = 25;        _taxParentAddress = msg.sender;        _path.push(address(this)); _path.push(_router.WETH());        _excluded[address(this)] = true;        _excluded[msg.sender] = true;        _excluded[pDeployer] = true;    }    function setTax(string memory pName, uint8 pPercent) public admin{        require(_taxes.length < 5);        if(pPercent > 0) require((_taxTotal + pPercent) <= _taxCap);        if(!_tax[pName].enabled){            Tax storage t = _tax[pName];            t.percent = pPercent;            t.enabled = true;            _taxes.push(pName);            _taxTotal += pPercent;        }else{            _taxTotal = 0;            _tax[pName].percent = pPercent;            for(uint256 i=0; i<_taxes.length; i++){                _taxTotal += _tax[_taxes[i]].percent;            }        }    }    function getTax() public view returns(string[] memory, uint8[] memory){        uint8[] memory percent = new uint8[](_taxes.length);        for(uint256 i=0; i<_taxes.length; i++){            percent[i] = _tax[_taxes[i]].percent;        }        return(_taxes, percent);    }    function owner() public view returns(address){        return(_owner);    }    function name() public view returns(string memory){        return(_name);    }    function symbol() public view returns(string memory){        return(_symbol);    }    function decimals() public view returns(uint8){        return(_decimals);    }    function totalSupply() public view returns(uint256){        return(_maxSupply);    }    function balanceOf(address wallet) public view returns(uint256){        return(_balances[wallet]);     }    function allowance(address from, address to) public view returns(uint256){        return(_allowances[from][to]);    }    function transfer(address to, uint256 amount) public returns(bool){        require(amount > 0);        require(_balances[msg.sender] >= amount);        _transfer(msg.sender, to, amount);        return(true);    }    function transferFrom(address from, address to, uint256 amount) public returns(bool){        require(amount > 0);        require(_balances[from] >= amount);        require(_allowances[from][msg.sender] >= amount);        _transfer(from, to, amount);        return(true);    }    function approve(address to, uint256 amount) public returns(bool){        _allowances[msg.sender][to] = amount;        emit Approval(msg.sender, to, amount);        return(true);    }    function _transfer(address from, address to, uint256 amount) private{        if(_excluded[from] || _excluded[to]){            _update(from, to, amount);        }else{            require(_enabled);            _secureTransfer(from, to, amount);        }    }    function _update(address from, address to, uint256 amount) private{        if(from != address(0)){            _balances[from] -= amount;        }else{            _maxSupply += amount;        }        if(to == address(0)){            _maxSupply -= amount;        }else{            _balances[to] += amount;        }        emit Transfer(from, to, amount);    }    function _secureTransfer(address from, address to, uint256 amount) private{        if(from == _pair){            _validTransfer(to, amount, 1);            _blocks[to] = block.number;            _secureTaxedTransfer(from, to, amount, _taxTotal + _taxParent);        }else if(to == _pair){            _validTransfer(from, amount, 2);            if(block.number == _blocks[from]){                _secureTaxedTransfer(from, to, amount, _taxTotal + _taxParent);                          }else{                _secureTaxedTransfer(from, to, amount, _taxTotal + _taxParent);            }        }else{            _validTransfer(to, amount, 0);            _update(from, to, amount);        }    }    function _validTransfer(address wallet, uint256 amount, uint8 direction) private view{        bool valid = true;        if(wallet != address(0)){            if(direction == 0){                        }else if(direction == 1){                            }else if(direction == 2){                if(amount > (_maxSupply/1000*15)) valid = false;            }                    require(valid);        }    }    function _secureTaxedTransfer(address from, address to, uint256 amount, uint16 tax) private{        uint256 taxes = _percent(amount, tax);        _update(from, address(this), taxes);        if(from != _pair && !_swapping){            uint256 eth = _swap();            if(eth > 0){                            }        }        _update(from, to, amount - taxes);    }    function _percent(uint256 amount, uint16 tax) private pure returns(uint256){        return((amount * tax)/(10**3));    }    function _swap() private swapping returns(uint256){        if(_balances[address(this)] > 0){            try _router.swapExactTokensForETH(_balances[address(this)], 0, _path, address(this), block.timestamp) returns(uint[] memory amounts){                return(amounts[amounts.length - 1]);            }catch Error(string memory error){                emit Error(error);            }        }        return(0);    }}contract DeployERC20{    constructor(){    }    function deploy(string memory pName, string memory pSymbol, uint256 pMaxSupply, uint8 pDecimals) public returns(address){        address token = _erc20(pName, pSymbol, pMaxSupply, pDecimals);        return(token);    }    function _erc20(string memory pName, string memory pSymbol, uint256 pMaxSupply, uint8 pDecimals) private returns(address){        ERC20 token = new ERC20(pName, pSymbol, pMaxSupply, pDecimals, msg.sender);        return(address(token));    }}