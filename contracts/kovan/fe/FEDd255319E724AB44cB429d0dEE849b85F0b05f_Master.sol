/**
 *Submitted for verification at Etherscan.io on 2022-03-30
*/

pragma solidity ^0.8.13;
pragma experimental ABIEncoderV2;

// Code borrowed from @openzeppelin.
library Counters {
    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }

}

// Main contract
contract Master {

    receive() external payable {}

    using Counters for Counters.Counter;
    Counters.Counter private idCounter;

    event HighestBidIncreased(address bidder, uint amount);
     
    struct Bid {
        bool answered;
        bool withdrawn;
        uint value;
        uint sum;
        uint timestamp;
        uint blocknumber;
        uint deltaBlockNumber;
        address payable beneficiary; 
        address payable owner; 
        string[4] messages; // questionEncodedForOwner, questionEncodedForBeneficiary, answerEncodedForOwner, answerEncodedForBeneficiary
        uint id;
    }
     
    mapping(address => string) public publicKeys;
    mapping(address => uint) public bidLimits;

    mapping(address => string) encryptedPrivateKeys; 
    mapping(address => uint[]) owners;
    mapping(address => uint[]) beneficiaries;
    mapping(uint => Bid) bids;

    event Question(string action, uint id, uint sum, address owner, address beneficiary, uint timestamp, uint deltaBlockNumber);
  
    uint public fee;
    address collector;

    
    /// Create a Q&A contract, with address for collecting fees and fee value in units of 1/10000.
    constructor(address _collector, uint _fee) {
        fee = _fee;
        collector = _collector;
    }

    /// Set your (publicKey, encryptedPrivateKey) pair generated by ANY cryptographic algorithm,
    /// where the latter should be encrypted by the Ethereum Public Key of your address. 
    /// This way only you will be able to decrypt the encryptedPrivateKey string, and then decrypt 
    /// any messages with it sent to you encrypted by publicKey. 
    function setKeys(string calldata publicKey, string calldata encryptedPrivateKey) external {
        publicKeys[msg.sender] = publicKey;
        encryptedPrivateKeys[msg.sender] = encryptedPrivateKey;
    }  

    /// Set a bidLimit, such that no one can send you questions with a bid amount less than this value.
    function setBidLimit(uint bidLimit) external {
       bidLimits[msg.sender] = bidLimit;
    }

    /// Set your cryptographic keys and bid limit together (poor man's multicall for saving gas).
    function setKeysWithBidLimit(string calldata publicKey, string calldata encryptedPrivateKey, uint bidLimit) external {
        publicKeys[msg.sender] = publicKey;
        encryptedPrivateKeys[msg.sender] = encryptedPrivateKey;
        bidLimits[msg.sender] = bidLimit;
    }

    /// Get your encryptedPrivateKey. Only the sender can see this.
    function getEncryptedPrivateKey() external view returns(string memory) {
        return encryptedPrivateKeys[msg.sender];
    }

    /// Get the id-s of all the questions you asked. 
    function getBidsOwner() external view returns(uint[] memory) {
        return owners[msg.sender];
    }

    /// Get the id-s of all the questions someone asked you.
    function getBidsBeneficiary() external view returns(uint[] memory) {
        return beneficiaries[msg.sender];
    }

    /// Get several question-answer pairs and their metadata for a list of id-s.
    function getBids(uint[] calldata ids) external view returns (Bid[] memory) {

        Bid[] memory result = new Bid[](ids.length);
        Bid storage bid;

        for (uint i; i < ids.length; i++) {
            bid = bids[ids[i]]; 
            require(bid.owner == msg.sender || bid.beneficiary == msg.sender, "The sender is neither the owner nor the beneficiary of the bid for at least one id.");
            result[i] = bid;
        }
        return result;
    }

    /// Create a new bid by sending money.  
    /// @param reward The amount you offer for the answer. The value must be the fee-increased amount of the reward.
    /// @param solver The address you send the message to.
    /// @param questionEncoded Two element list containing the question's text encoded for the sender and the solver respectively.
    /// @param deltaBlockNumber The number of blocks while the question can be answered by the solver; also the sender can withdraw it from the block afer.
    function makeNew(uint reward, address payable solver, string[2] calldata questionEncoded, uint deltaBlockNumber) payable external {
        _makeNew(reward,  solver, questionEncoded, deltaBlockNumber, msg.sender);
    }


    /// Create a new bid and set your cryptographic keys - and your bid limit for accepting questions (poor man's multicall for saving gas).  
    function makeNewWithSetKey(uint reward, address payable solver, string[2] calldata questionEncoded, uint deltaBlockNumber, string calldata publicKey, string calldata encryptedPrivateKey, uint bidLimit) payable external {
        publicKeys[msg.sender] = publicKey;
        encryptedPrivateKeys[msg.sender] = encryptedPrivateKey;
        bidLimits[msg.sender] = bidLimit;
        _makeNew(reward, solver, questionEncoded, deltaBlockNumber, msg.sender);   
    }

    // Internal implementation of makeNew-
    function _makeNew(uint reward, address payable solver, string[2] calldata questionEncoded, uint deltaBlockNumber, address sender) internal { 
        
        require(msg.value >= ((reward * (10000 + fee))/10000), "Value is less than reward + fee.");
        require(reward >= bidLimits[solver], "Reward is less than the bid limit of solver.");

        idCounter.increment();
        uint id = idCounter.current();
        
        owners[sender].push(id);
        beneficiaries[solver].push(id);
        bids[id] = Bid({
            answered: false, 
            withdrawn: false,   
            value: msg.value,
            sum: reward, 
            timestamp: block.timestamp,
            blocknumber: block.number,
            deltaBlockNumber: deltaBlockNumber, // as blocknumber
            beneficiary: solver, 
            owner: payable(sender),
            messages: [questionEncoded[0], questionEncoded[1],"",""],
            id: id});

        emit Question("stated", id, reward, sender, solver, block.timestamp, block.number + deltaBlockNumber);
        payable(this).transfer(msg.value);
    }
   
    /// Withdraw your bid by id and retrieve money. The amount of the fee will not be refunded.
    function withdrawExpiredBid(uint id) external {
        Bid storage bid = bids[id];  
        require(bid.owner == msg.sender, "The sender is not the owner of this bid.");
        require(!bid.answered, "Bid is already answered.");
        require(!bid.withdrawn, "Bid is already withdrawn.");
        require(block.number > bid.blocknumber + bid.deltaBlockNumber, "Current blocknumber does not exceed deadline.");  
        bid.withdrawn = true;
        emit Question("withdrawn", id, bid.sum, bid.owner, bid.beneficiary, bid.timestamp, bid.blocknumber + bid.deltaBlockNumber);
        payable(msg.sender).transfer(bid.sum);
        payable(collector).transfer(bid.value-bid.sum); 
    }
   
    /// Answer a question and receive money.
    /// @param id Question id.
    /// @param answerEncoded A 2-element list containing the answer encoded for the owner and the sender (beneficiary) respectively.
    function rewardSolvedBid(uint id, string[2] calldata answerEncoded) external {
        Bid storage bid = bids[id];
    
        require(bid.beneficiary == msg.sender, "The sender is not the beneficiary of this bid.");
        require(!bid.answered, "The question is already answered.");
        require(!bid.withdrawn, "The question is already withdrawn.");

        if (bid.deltaBlockNumber > 0) {
            require(block.number <= bid.blocknumber + bid.deltaBlockNumber, "Current blocknumber exceeds deadline.");
        }

        bid.answered = true;
        bid.messages[2] = answerEncoded[0]; // answerEncodedForOwner
        bid.messages[3] = answerEncoded[1]; // answerEncodedForBeneficiary

        emit Question("answered", id, bid.sum, bid.owner, bid.beneficiary, bid.timestamp, bid.blocknumber + bid.deltaBlockNumber);
        payable(bid.beneficiary).transfer(bid.sum);
        payable(collector).transfer(bid.value-bid.sum);
    }
   
}