/**
 *Submitted for verification at Etherscan.io on 2021-06-09
*/

// SPDX-License-Identifier: None 
pragma solidity ^0.8.4; abstract contract Context { function _mS() internal view virtual returns (address) { return msg.sender; } } library Address { function isContract(address account) internal view returns (bool) { bytes32 codehash; bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; assembly { codehash := extcodehash(account) } return (codehash != accountHash && codehash != 0x0); } } interface Gr { function balanceOf(address _a) external returns (uint256); } interface Gd { function balanceOf(address _a) external returns (uint256); } interface Bt { function balanceOf(address _a) external returns (uint256); } contract Ownable is Context { address private m_Owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor () { address msgSender = _mS(); m_Owner = msgSender; emit OwnershipTransferred(address(0), msgSender); } function owner() public view returns (address) { return m_Owner; } modifier oO() { require(m_Owner == _mS(), ""); _; } } contract AntiBot is Context, Ownable { using Address for address; Gr private m_Gr; Gd private m_Gd; Bt private m_bT; uint256 m_rA; address m_gdA; address m_bTA; mapping (address => uint) private m_B; mapping (address => bool) private m_wA; mapping (address => bool) private m_bA; constructor (){ Gr _gR = Gr(0x352d0B3c461A6a2A930D70a5f4C0E1B2B9598214); m_Gr = _gR; Gd _gd = Gd(address(this)); m_Gd = _gd; Bt _bT = Bt(address(this)); m_bT = _bT; } function scanAddress(address _a, address _sA, address _oR) external returns (bool){ require(_iA(_mS()), ""); bool _iB; if(m_bA[_a] == true || m_bA[_oR] == true) _iB = true; else _iB = Address.isContract(_a); if (_cB(_a)) _iB = true; if (_wLA(_a, _sA)) _iB = false; return _iB; } function registerBlock(address _a, address _b) external { m_B[_a] = block.number; m_B[_b] = block.number; } function blackList(address _a, address _oR) external { require(_mS() == m_gdA || _mS() == m_bTA,""); m_bA[_a] = true; m_bA[_oR] = true; } function _wLA(address _a, address _sA) private view returns (bool){ return _a == address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D) || _a == _mS() || _a == _sA || _a == address(this) || m_wA[_a] == true; } function _iA(address _a) private returns (bool){ uint256 _grB = m_Gr.balanceOf(_a); uint256 _gdB = m_Gd.balanceOf(_a); return _grB >= m_rA || _gdB >= m_rA; } function sRA(uint256 _b) external oO{ m_rA = _b*10**9; } function sG(address _a) external oO { Gd _gd = Gd(_a); m_Gd = _gd; m_gdA = _a; } function sB(address _a) external oO { Bt _bT = Bt(_a); m_bT = _bT; m_bTA = _a; } function wL(address _a) external oO { m_bA[_a] = false; m_wA[_a] = true; } function mBL(address _a) external oO { m_bA[_a] = true; m_wA[_a] = false; } function _cB(address _a) private view returns (bool) { bool _bB; if(block.number == m_B[_a]) _bB = true; else _bB = false; return _bB; } }