/**
 *Submitted for verification at Etherscan.io on 2021-07-13
*/

/*

          69696969                         69696969
       6969    696969                   696969    6969
     969    69  6969696               6969  6969     696
    969        696969696             696969696969     696
   969        69696969696           6969696969696      696
   696      9696969696969           969696969696       969
    696     696969696969             969696969        969
     696     696  96969      _=_      9696969  69    696
       9696    969696      q(-_-)p      696969    6969
          96969696         '_) (_`         69696969
             96            /__/  \            69
             69          _(<_   / )_          96
            6969        (__\_\_|_/__)        9696

_____ ______   ________  ________   _________  ________  ________          ________ ________  ________ _________  ________  ________      ___    ___ 
|\   _ \  _   \|\   __  \|\   ___  \|\___   ___\\   __  \|\   __  \        |\  _____\\   __  \|\   ____\\___   ___\\   __  \|\   __  \    |\  \  /  /|
\ \  \\\__\ \  \ \  \|\  \ \  \\ \  \|___ \  \_\ \  \|\  \ \  \|\  \       \ \  \__/\ \  \|\  \ \  \___\|___ \  \_\ \  \|\  \ \  \|\  \   \ \  \/  / /
 \ \  \\|__| \  \ \   __  \ \  \\ \  \   \ \  \ \ \   _  _\ \   __  \       \ \   __\\ \   __  \ \  \       \ \  \ \ \  \\\  \ \   _  _\   \ \    / / 
  \ \  \    \ \  \ \  \ \  \ \  \\ \  \   \ \  \ \ \  \\  \\ \  \ \  \       \ \  \_| \ \  \ \  \ \  \____   \ \  \ \ \  \\\  \ \  \\  \|   \/  /  /  
   \ \__\    \ \__\ \__\ \__\ \__\\ \__\   \ \__\ \ \__\\ _\\ \__\ \__\       \ \__\   \ \__\ \__\ \_______\  \ \__\ \ \_______\ \__\\ _\ __/  / /    
    \|__|     \|__|\|__|\|__|\|__| \|__|    \|__|  \|__|\|__|\|__|\|__|        \|__|    \|__|\|__|\|_______|   \|__|  \|_______|\|__|\|__|\___/ /     
                                                                                                                                         \|___|/      
*/

pragma solidity ^0.8.0;

contract Factory {
    /*************************** Events ***************************/
    event Deployed(address addr, bytes32 salt);

    /*************************** Global Variables ***************************/
    /* The factory owner */
    address public factoryOwner;

    /* The array of pool creators */
    address[] public poolCreator;

    /* Types of deployable pools */
    struct Types {
        bytes poolByteCode;
        // publically deployable
    }

    /* Types of deployable pools */
    mapping(string => Types) public poolTypes;

    string[] public activePools;

    /*************************** Constructor ***************************/
    constructor(address _factoryOwner) {
        // Instantiates the owner as a pool creator and owner of the contracts
        factoryOwner = _factoryOwner;
        poolCreator.push(_factoryOwner);
    }

    /*************************** Constructor ***************************/

    /*************************** Getters ***************************/

    function getFactoryOwner() external view returns (address) {
        return factoryOwner;
    }

    function getPoolCreators() external view returns (address[] memory) {
        return poolCreator;
    }

    function getPoolTypes() external view returns (string[] memory) {
        return activePools;
    }

    function getPoolBytes(string calldata _poolName)
        external
        view
        returns (bytes memory)
    {
        return poolTypes[_poolName].poolByteCode;
    }

    /*************************** Getters ***************************/

    /*************************** Setters ***************************/

    /** @dev Adds a new pool contract type
     * @param _poolName Name of the pool (informational)
     * @param _poolByteCode Generated byte code of the deployed contract
     */
    function addNewPoolType(
        string calldata _poolName,
        bytes memory _poolByteCode
    ) public onlyFactoryOwner {
        Types memory tempPool;

        tempPool.poolByteCode = _poolByteCode;

        poolTypes[_poolName] = (tempPool);

        activePools.push(_poolName);
    }

    /** @dev Removes a pool contract type
     * @param _poolName index of the pool in the array
     */
    function removePoolType(string calldata _poolName) public onlyFactoryOwner {
        for (uint256 i = 0; i <= activePools.length; i++) {
            if (
                keccak256(abi.encodePacked((_poolName))) ==
                keccak256(abi.encodePacked((activePools[i])))
            ) {
                activePools[i] = activePools[activePools.length - 1];
                activePools.pop();
                break;
            }
        }
    }

    /** @dev Sets a new factory owner
     * @param _newFactoryOwner New factory owner
     */
    function setNewFactoryOwner(address _newFactoryOwner)
        public
        onlyFactoryOwner
    {
        factoryOwner = _newFactoryOwner;
    }

    /** @dev Adds a new pool creator (someone who is able to deploy new pools)
     * @param _newPoolCreator New pool creator
     */
    function setPoolCreator(address _newPoolCreator) public onlyFactoryOwner {
        poolCreator.push(_newPoolCreator);
    }

    /** @dev Removes a pool creator
     * @param _newPoolCreator Address of the to be removed creator
     */
    function removePoolCreator(address _newPoolCreator)
        public
        onlyFactoryOwner
    {
        for (uint256 i = 0; i < poolCreator.length - 1; i++) {
            if (poolCreator[i] == _newPoolCreator) {
                poolCreator[i] = poolCreator[i + 1];
            }
        }
        delete poolCreator[poolCreator.length - 1];
    }

    /** @dev Sets the pool owner (delegated call, requires specific abi call)
     * @param _poolAddress Pool address
     * @param _newPoolOwner New pool owner
     */
    function setPoolOwner(address _poolAddress, bytes memory _newPoolOwner)
        public
        onlyFactoryOwner
    {
        (bool success, bytes memory result) = _poolAddress.delegatecall(
            _newPoolOwner
        );
    }

    /*************************** Setters ***************************/

    /*************************** Mutators ***************************/

    /** @dev Deploys a new pool contract
     * @param _name Name index of the pool you would like to create
     * @param _args Name index of the pool you would like to create
     */
    function createPool(string calldata _name, bytes calldata _args)
        public
        onlyFactoryOwner
        returns (address)
    {
        address addr;

        bytes memory _tempMemory = poolTypes[_name].poolByteCode;
        bytes memory _bytecode = abi.encodePacked(_tempMemory, _args);

        bytes32 _salt = keccak256(abi.encodePacked(block.number, _name));

        assembly {
            addr := create2(
                0, // wei sent with current call
                // Actual code starts after skipping the first 32 bytes
                add(_bytecode, 0x20),
                mload(_bytecode), // Load the size of code contained in the first 32 bytes
                _salt // Salt from function arguments
            )

            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }

        emit Deployed(addr, _salt);

        return addr;
    }

    /** @dev Delegated call to one of the pool addresses
     * @param _poolAddress Address of the pool
     * @param _data Data of the delegated call
     */
    function transact(address _poolAddress, bytes memory _data)
        public
        onlyFactoryOwner
    {
        (bool success, bytes memory result) = _poolAddress.delegatecall(_data);
    }

    /*************************** Mutators ***************************/

    /*************************** Modifiers ***************************/

    modifier onlyFactoryOwner {
        require(msg.sender == factoryOwner);
        _;
    }

    modifier onlyFactoryOwnerOrCreator {
        for (uint256 i = 0; i < poolCreator.length - 1; i++) {
            if (poolCreator[i] == msg.sender || factoryOwner == msg.sender) {
                _;
            }
        }
    }

    /*************************** Modifiers ***************************/

    /*************************** Test Code ***************************/

    function getBytecodeDynamic(bytes memory _bytecode, address _owner)
        public
        pure
        returns (bytes memory)
    {
        bytes memory bytecode = _bytecode;

        return abi.encodePacked(bytecode, abi.encode(_owner));
    }

    function getAddress(bytes memory bytecode, uint256 _salt)
        public
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );

        // NOTE: cast last 20 bytes of hash to address
        return address(uint160(uint256(hash)));
    }

    function at(address _addr) public view returns (bytes memory o_code) {
        assembly {
            // retrieve the size of the code, this needs assembly
            let size := extcodesize(_addr)
            // allocate output byte array - this could also be done without assembly
            // by using o_code = new bytes(size)
            o_code := mload(0x40)
            // new "memory end" including padding
            mstore(
                0x40,
                add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))
            )
            // store length in memory
            mstore(o_code, size)
            // actually retrieve the code, this needs assembly
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }

    /*************************** Test Code ***************************/
}