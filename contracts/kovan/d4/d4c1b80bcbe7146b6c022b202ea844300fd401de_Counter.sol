// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";

contract Counter is KeeperCompatibleInterface {
    /**
    * Public counter variable
    */
    address public owner;
    uint public counter;
    bool public running = true;
    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    event IncrementedCounter(uint);

    constructor(uint updateInterval) {
        owner = msg.sender;
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        counter = 0;
    }
    /*
    [def] checkData: Data passed to the contract when checking for Upkeep. 
    Specified in the Upkeep registration so it is always the same for 
    a registered Upkeep.

    [def] upkeepNeeded: Indicates whether the Keeper should call performUpkeep 
    or not.

    [def] performData: Bytes that the Keeper should call performUpkeep with, if Upkeep 
    is needed. If you would like to encode data to decode later, try abi.encode.

    In most cases your checkUpkeep method should be marked as view. 
    This might not always be possible if you want to use more advanced 
    Solidity features like DelegateCall. It is a best practice to import 
    the KeeperBase.sol interface and use the cannotExecute modifier to 
    ensure that the method can be used only for simulation purposes.
    */


    // Keeper node calls checkUpkeep to determine if there is work to be done (implicit bool return)
    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        require(running == true, "Running = false");
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    /*
    When your checkUpkeep returns upkeepNeeded == true, the Keeper 
    node broadcasts a transaction to the blockchain to execute your 
    contract code with performData as an input.

    The Upkeep that is performed is subject to the callGasLimit 
    in the configuration of the registry.

    Ensure your performUpkeep is idempotent. Your performUpkeep 
    should change state such that checkUpkeep will not return true 
    for the same subset of work once said work is complete. Otherwise 
    the Upkeep will remain eligible and result in multiple performances 
    by the Keeper Network on the exactly same subset of work.
    */

    // performs the work on the contract, if instructed by checkUpkeep().
    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        require(running == true, "Running = false");
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            emit IncrementedCounter(counter);
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function toggleOnOff(bool _onOff) external {
        require(msg.sender == owner, "Owner only");
        running = _onOff;
    }

}

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

import "./KeeperBase.sol";
import "./interfaces/KeeperCompatibleInterface.sol";

abstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

contract KeeperBase {
  /**
   * @notice method that allows it to be simulated via eth_call by checking that
   * the sender is the zero address.
   */
  function preventExecution() internal view {
    require(tx.origin == address(0), "only for simulated backend");
  }

  /**
   * @notice modifier that allows it to be simulated via eth_call by checking
   * that the sender is the zero address.
   */
  modifier cannotExecute() {
    preventExecution();
    _;
  }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

interface KeeperCompatibleInterface {
  /**
   * @notice method that is simulated by the keepers to see if any work actually
   * needs to be performed. This method does does not actually need to be
   * executable, and since it is only ever simulated it can consume lots of gas.
   * @dev To ensure that it is never called, you may want to add the
   * cannotExecute modifier from KeeperBase to your implementation of this
   * method.
   * @param checkData specified in the upkeep registration so it is always the
   * same for a registered upkeep. This can easily be broken down into specific
   * arguments using `abi.decode`, so multiple upkeeps can be registered on the
   * same contract and easily differentiated by the contract.
   * @return upkeepNeeded boolean to indicate whether the keeper should call
   * performUpkeep or not.
   * @return performData bytes that the keeper should call performUpkeep with, if
   * upkeep is needed. If you would like to encode data to decode later, try
   * `abi.encode`.
   */
  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);

  /**
   * @notice method that is actually executed by the keepers, via the registry.
   * The data returned by the checkUpkeep simulation will be passed into
   * this method to actually be executed.
   * @dev The input to this method should not be trusted, and the caller of the
   * method should not even be restricted to any single registry. Anyone should
   * be able call it, and the input should be validated, there is no guarantee
   * that the data passed in is the performData returned from checkUpkeep. This
   * could happen due to malicious keepers, racing keepers, or simply a state
   * change while the performUpkeep transaction is waiting for confirmation.
   * Always validate the data passed in.
   * @param performData is the data which was passed back from the checkData
   * simulation. If it is encoded, it can easily be decoded into other types by
   * calling `abi.decode`. This data should not be trusted, and should be
   * validated against the contract's current state.
   */
  function performUpkeep(bytes calldata performData) external;
}