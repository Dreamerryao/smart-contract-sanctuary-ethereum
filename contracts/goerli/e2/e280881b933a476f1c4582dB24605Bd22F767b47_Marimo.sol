//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "hardhat/console.sol";

contract Marimo is Ownable, ERC721A {
  using Strings for uint256;
  using Counters for Counters.Counter;

  string baseURI;
  uint256 public immutable maxPerAddressDuringMint;
  uint256 public immutable collectionSize;
  mapping(uint256 => uint256) private _generatedAt;
  mapping(uint256 => uint256) private _lastWaterChangedAt;
  mapping(uint256 => uint16) private _lastSize;

  struct Stats {
      uint8 power;
      uint8 speed;
      uint8 stamina;
      uint8 luck;
  }
  event ChangedStats(
      uint256 indexed _tokenId
  );
  mapping(uint256 => Stats) public tokenStats; // token id => stats

  constructor(uint256 maxBatchSize_, uint256 collectionSize_) ERC721A("Marimo", "MRM") {
    maxPerAddressDuringMint = maxBatchSize_;
    collectionSize = collectionSize_;
  }

  // function hoge() external pure returns(string memory) {
  function hoge() external pure returns(bytes memory) {
    // bytes memory a = abi.encodePacked("M189.63,130.1c14.75,1.35,14.81,1.25,.12-.25,14.73,1.4,14.63,1.52-.25,.27,14.58,1.48,14.49,1.5-.24,.05,14.55,1.48,14.46,1.5-.2,.04,14.54,1.42,14.52,1.37-.08-.14,15.07,.85,15.5,.15,1.04-1.73,14.79,1.06,14.51,1.45-.69,.74,14.48,1.24,14.25,1.24-.55,.01,14.47,1.1,14.42,.98-.12-.29,14.68,.93,14.85,.68,.44-.61,14.64,.97,14.7,.93,.13-.12,15.4,1.23,15.84,1.46,1,.37,14.48,.78,14.12,.52-.89-.67,14.73,.78,14.8,.63,.19-.37,14.97,.84,15.19,.84,.52,0,15.45,1.03,15.81,1.2,.82,.29,14.6,.59,14.2,.32-.96-.68,14.95,.78,15.13,.79,.44,.03,14.87,.77,14.61,.69-.56-.21,14.95,.22,15.11-.3,.41-1.28,15.79,.37,16.77,.17,2.4-.49,15.37,.33,14.28,.42-2.27-.2,14.87,.28,14.87,.23,0-.04,14.97,.13,15.06-.02,.24-.37,15.25-.11,15.58-.43,.79-.81,15.09,.01,14.87,.18-.52,.32,15.13-.17,15.28-.42,.36-.64,15.06-.06,15,.01-.15,.16,15.05-.08,15.07-.14,.06-.14,15.04-.05,14.91,.12-.3,.37,14.75,.23,14.44,.49-.74,.61,14.59,.26,14.33,.35-.6,.22,14.53,.08,14.39-.07-.35-.33,14.6,.05,14.6-.03-.01-.2,14.59,.09,14.58,.16-.03,.17,14.43,0,14.29-.12-.36-.3q14.51,.05,.03-.04c14.59,0,14.66-.06,.18-.14,14.61-.02,14.65-.05,.13-.09,14.65,.19,14.67,.3,.08,.25,14.6-.05,14.58-.17-.02-.28,15.78-.84,16.67-1.12,1.7-.91,14.39-.18,13.84-.08-1.36,.21q14.67-.16,0,0c14.67-.16,14.72-.18,.04-.02q14.66-.16-.03,0c15.05-.58,15.38-1.06,.82-1.16,15.04-.51,15.24-.61,.47-.25,14.96-.48,14.79-.43-.37,.07,15.15-1,15.38-1.57,.56-1.41,15.4-.38,15.62-.13,.5,.53,14.95-1.01,14.78-1.34-.42-.83,15.17-1.45,15.29-2.07,.26-1.55,15.08-1.19,14.9-.64-.52,1.11,14.73-1.3,14.47-1.64-.62-.85,15.45-1.12,15.82-1.05,.82,.06,14.64-1.28,14.27-1.41-.9-.33,15.1-1.3,15.4-1.44,.72-.32,15.15-1.19,15.26-1.15,.24,.09,14.95-1.3,14.88-1.34-.17-.12,15.2-1.37,15.42-1.49,.54-.29,15.1-1.33,14.78-1.24-.73,.15,14.48-1.62,14.01-1.9-1.14-.68,15.21-1.53,15.75-1.65,1.3-.31,14.97-1.52,14.48-1.49-1.09-.06,15.07-1.89,15.39-2.29,.78-.98,14.9-1.75,14.32-1.23-1.36,.88q14.6-1.55,0,0c14.62-1.65,14.64-1.73,.04-.22,14.75-1.71,14.9-1.81,.35-.27,14.69-1.66,14.54-1.59-.33,.13,14.7-2.15,14.75-2.69,.11-1.33,15.5-1.36,15.96-.9,1.08,.83,14.47-2.4,14.02-2.99-1.1-1.45,14.59-2.68,14.48-3.32-.26-1.54,14.58-2.4,14.59-1.87-.11,1.17,14.27-2.41,13.98-2.66-.72-.6,14.42-2.43,14.45-2.58,.06-.38,14.81-2.47,15.22-2.62,.99-.37,14.68-2.44,14.73-2.42,.13,.02,14.65-2.44,14.61-2.46-.09-.04,15.03-2.64,15.42-2.87,.95-.56,14.85-2.57,14.18-2.31-1.46,.29,14.36-2.6,14.19-2.7-.43-.26,14.43-2.79,14.42-3.03,0-.57,16.09-3,17.17-2.86,2.25-.14,14.73-2.8,14.54-2.86-.48-.16,14.88-2.74,14.93-2.74,.09,.02,14.61-2.88,14.38-2.98-.57-.27,15.14-3.03,15.56-3.28,1.04-.62,14.94-2.95,14.13-2.64-1.77,.34,14.47-2.9,14.38-2.93-.2-.06,14.65-2.96,14.79-3.03,.35-.18,14.58-2.93,14.33-2.86-.57,.12,14.41-2.92,14.35-2.94-.12-.04,14.52-3.03,14.61-3.14,.22-.29,14.48-2.98,14.35-2.86-.31,.23,14.36-3.33,14.29-3.72-.17-.96,14.58-3.34,14.77-3.55,.48-.53,14.6-3.21,14.72-3.16,.3,.11,14.55-3.23,14.43-3.3-.25-.17,15.14-4.08,15.69-5.07,1.32-2.39,14.78-3.8,14.1-2.76-1.75,1.8q14.37-3.39-.04,.04c14.27-3.43,14.15-3.46-.3-.09q14.32-3.41,0,0c14.32-3.48,14.3-3.56-.02-.18,14.56-3.59,14.71-3.65,.32-.16,14.25-3.47,14.12-3.43-.33,.06,14.31-3.48,14.31-3.53,0-.05,14.92-4.13,15.48-4.91,1.33-1.89,14.61-3.91,13.89-3.08-1.76,1.39q14.2-3.59-.05,.02,14.18-3.63-.07-.11c14.95-4.54,15.6-5.64,1.55-2.69,14.54-4.21,13.74-3.09-2.02,1.96q14.09-3.78,0,0c14.51-4.19,14.92-4.63,1-1.09,14.31-4.02,14.16-3.91-.35,.24,14.06-4.01,13.68-4.12-.89-.3,14.1-4.22,14.16-4.41,.14-.46,15.37-4.36,16.19-4.3,1.74-.13,14.23-4.24,14.01-4.3-.54-.16,14.08-4.38,13.83-4.54-.62-.4,14.49-4.67,14.78-5.08,.68-1,14.34-4.51,13.92-4.08-1.01,.81q14.08-4.35-.08-.04c14.13-4.64,14.14-4.94,.03-.75,14.84-4.86,15.56-5.36,1.73-1.23,14.49-4.78,13.7-4.31-1.76,.64,14.06-5.12,13.99-5.6-.19-1.19,14.16-5.04,14.24-5.18,.22-.34q14.11-4.98,0,0c14.47-5.56,14.77-6.19,.72-1.54,14.27-5.32,13.76-4.54-1.32,1.42,13.82-5.25,13.65-5.48-.4-.57,14.9-6.47,15.68-8.15,1.81-4.05,14.29-6.03,13.58-4.57-1.98,2.63,13.63-5.22,13.38-4.98-.59,.58,13.83-5.82,13.9-6.34,.17-1.28,13.76-5.61,13.62-5.09-.44,1.04,13.57-5.44,13.5-5.51-.2-.16,13.62-5.52,13.63-5.62,.02-.26,13.62-5.73,13.62-6-.02-.65,13.75-5.61,13.83-5.61,.18,0,13.58-5.63,13.5-5.65-.19-.05,13.6-5.82,13.58-6.02-.06-.48,14.65-5.47,15.26-5.2,1.36,.44,13.32-6.1,12.72-6.5-1.46-.98,13.34-6.82,12.95-7.81-.98-2.38,13.76-6.67,14.13-7.01,.93-.84,13.57-6.57,13.17-6.31-.92,.44,13.48-6.55,13.61-6.63,.3-.2,13.43-6.51,13.18-6.41-.56,.18,13.52-7.45,13.6-8.51,.19-2.58,13.35-7.05,13.26-6.53-.31,1.09,13.25-7.32,13.18-7.84-.16-1.28,13.24-7.09,13.21-6.22-.34,1.79,13.06-7.16,12.92-7.61-.35-1.11,13.02-7.1,12.94-7.25-.19-.39q13.06-7.06,.02-.09,13.1-7.09,.07-.06,13.04-7.04-.07,.03c13.11-7.27,13.17-7.49,.13-.54,13.08-7.17,12.98-6.96-.26,.46,12.97-7.17,12.91-7.26-.14-.23,12.94-7.39,12.87-7.66-.17-.67,13.13-7.3,13.3-7.34,.43-.1,13.05-7.29,12.84-7.29-.47-.03,12.92-7.38,12.9-7.45-.06-.19,13.19-7.57,13.34-7.67,.34-.27,12.9-7.36,12.81-7.31-.24,.11,13.11-7.66,13.26-7.96,.35-.74,14.72-7.9,15.79-7.84,2.26-.25,12.7-7.86,11.87-8.04-2.03-.44,13.19-8.07,13.29-8.46,.22-.96,13.13-7.9,12.93-7.45-.53,.93,12.62-7.73,12.23-7.73-.96-.01q12.8-7.75,0-.12c13.06-7.81,13.32-7.89,.64-.22,12.95-7.78,12.66-7.74-.65,.02,12.79-7.89,12.77-8.01-.04-.3,12.87-8.26,12.92-8.69,.12-1.07,13.75-8.72,14.64-9.54,2.16-2,13.3-8.52,12.36-7.82-2.16,1.11,12.79-8.78,12.74-9.3-.14-1.27,12.79-8.55,12.74-7.88-.27,1.42,12.64-8.21,12.55-8.17-.21,.08,12.73-8.58,12.77-8.95,.09-.91,12.7-8.42,12.56-7.93-.41,1.02,11.93-7.98,11.16-7.79-1.87,.46,12.18-8.19,12.17-8.3-.04-.26,12.24-8.21,12.29-8.28,.13-.16,12.68-8.53,13.13-8.93,1.09-.97,12.45-8.4,12.19-8.24-.6,.3,12.65-8.82,12.97-9.34,.76-1.28,12.49-8.62,11.87-7.88-1.51,1.34,12.12-8.47,12.09-8.62-.08-.37,12.51-9.01,12.86-9.66,.82-1.61,12.32-8.76,11.74-7.97-1.46,1.46,11.99-8.51,11.97-8.59-.02-.18,12.08-8.68,12.17-8.88,.21-.5q12.04-8.6,.02-.03,12.04-8.6-.01,.01c12.11-8.79,12.18-8.99,.16-.48,12.9-9.09,13.45-9.23,1.13-.43,11.9-8.8,11.5-8.77-1.01,.06,12.35-9.69,12.52-10.65,.37-2.32,12.18-9.3,11.98-8.61-.62,1.42,11.84-9.04,11.64-9.09-.49-.12,12.37-9.62,12.68-9.94,.61-.76,11.71-8.96,11.37-8.72-.85,.58,11.9-9.22,11.9-9.39,.01-.41,12.3-9.5,12.69-9.9,.98-.98,12.1-9.36,11.68-9.05-.99,.55,11.87-9.42,11.86-9.59-.04-.44,12.05-9.81,12.2-10.31,.36-1.23,12.06-9.64,12.13-9.66,.15-.04,11.93-9.62,11.88-9.62-.13,0,11.98-9.71,12-9.8,.05-.22,11.97-9.67,11.92-9.56-.11,.22,11.71-9.62,11.48-9.62-.57,.01,11.77-9.79,11.71-9.96-.14-.42q11.83-9.77,.12-.14c11.81-9.74,11.76-9.7-.13,.09,11.56-10.32,11.3-10.93-.67-1.48,11.63-10.05,11.86-9.25,.24,1.74,11.47-9.55,11.21-9.42-.64,.3,11.34-10,11.1-10.39-.59-.96,11.54-10.11,11.66-10.43,.3-.78,11.66-10.14,11.84-10.31,.44-.41,11.57-10.07,11.42-9.98-.37,.19,11.79-10.99,11.97-12.03,.45-2.55,11.59-10.6,11.14-9.11-1.47,2.8,11.19-10.05,11.11-10.12-.19-.18,11.33-10.09,11.44-10.17,.26-.2,11.28-10.06,11.14-9.99-.34,.13q11.16-10.07-.11-.1c11.63-10.63,12.03-11.28,.98-1.59,11.4-10.4,10.82-9.71-1.41,1.24,10.79-10.35,10.48-10.56-.77-.51,12.37-11.65,13.55-12.22,2.16-1.62,9.8-10.27,8.4-9.64-3.38,1.48,10.64-10.34,10.64-10.4,0-.16,10.92-10.91,11.12-11.57,.48-1.61,11.64-11.39,12.44-12.32,1.92-2.29,11.18-11.17,10.4-10.37-1.84,1.33,10.78-11.58,10.72-12.31-.16-1.79,10.73-11.28,10.69-10.22-.46,2.11,10.54-10.76,10.44-10.71-.24,.12q10.58-10.8-.01-.05,10.58-10.79,0,.06c10.04-10.54,9.45-10.3-1.46,.57,10.6-11.12,10.92-11.48,.77-.9q10.46-10.82,.08,.07,10.42-10.88-.04-.11c10.84-11.27,11.11-11.47,.56-.5,10.28-10.86,10.02-10.74-.64,.3,10.3-11.16,10.18-11.4-.28-.6,11.28-12.09,11.97-12.57,1.33-1.26,9.96-11.06,9.32-10.73-1.58,.78,10.24-11.24,10.18-11.32-.13-.22,10.31-11.85,10.3-12.53-.03-1.66,10.26-11.56,10.18-11.02-.29,1.16,10.1-11.44,10.01-11.56-.22-.3,10.01-12.24,9.76-13.11-.63-2.11,10-11.84,10.12-11.19,.06,1.43,9.57-12,9.09-12.4-1.19-1,10.6-12.57,11.21-12.96,1.19-.99,9.3-11.74,8.63-11.44-1.65,.71,9.54-11.87,9.43-11.93-.27-.13,9.14-12.68,8.57-13.48-1.4-1.96,9.27-12.41,9.27-12.53-.02-.32,9.28-12.35,9.26-12.17-.07,.4,9.21-12.22,9.12-12.16-.23,.15,9-12.56,8.78-12.88-.56-.79,9.09-12.4,9.24-12.07,.28,.76,8.98-12.65,8.8-13.05-.47-.99,9.04-12.45,9.2-11.85,.18,1.33,9-12.12,8.91-12.07-.22,.11,8.97-12.12,8.89-12.11-.2,.04,9.1-12.59,9.2-12.85,.17-.59,8.86-12.01,8.71-11.76-.38,.62q8.95-12.12-.04,0,8.9-12.16-.08-.1c8.84-12.23,8.77-12.3-.19-.19,8.86-12.25,8.84-12.31-.04-.16,9.41-12.51,9.75-12.63,.72-.33,8.7-12.27,8.38-12.22-.78,.11q8.84-12.32-.02-.1,8.85-12.29,0,.1c8.75-12.26,8.65-12.24-.24,.05,8.52-12.5,8.22-12.72-.72-.54,8.65-12.51,8.67-12.65,.05-.33,8.7-12.5,8.75-12.54,.13-.11,8.67-12.48,8.62-12.45-.12,.06,8.7-12.86,8.74-13.26,.08-.99,8.66-12.69,8.55-12.24-.35,.94,8.5-12.81,8.39-13.15-.27-.82,8.52-12.66,8.59-12.28,.04,.83,8.38-12.48,8.22-12.49-.39-.01,8.3-12.54,8.15-12.61-.37-.15,8.45-12.8,8.54-13.04,.21-.61,8.81-12.77,9.05-12.81,.52-.13,8.34-12.69,8.15-12.69-.47-.01,8.62-13.17,8.77-13.44,.29-.62,8.26-12.57,8.05-12.33-.52,.61,7.6-12.67,6.86-12.58-1.81,.22,7.72-12.85,7.46-13.05-.64-.5,7.89-12.85,7.95-12.96,.15-.26,8.68-13.19,9.21-13.34,1.1-.44,7.81-12.9,7.53-12.88-.7,.04,9.13-13.96,10.12-15.4,2.36-3.48,8.47-13.66,7.58-12.42-2.28,2.11,7.6-12.93,7.19-12.67-1,.65,7.16-13.02,6.59-12.93-1.38,.21,7.3-13.07,7.14-13.12-.36-.14,8.15-13.26,8.96-13.62,1.95-.89,7.79-13.23,6.76-12.88-2.2,.29,7.24-13.17,7.17-13.17-.16,0,7.21-13.48,7.14-13.8-.18-.77,7.23-13.34,7.24-12.99-.04,.76,7.02-13.17,6.81-13.19-.5-.03,7.05-13.31,6.98-13.44-.16-.33,7-13.46,6.95-13.64-.14-.47,7.54-13.53,7.83-13.58,.64-.19,6.9-13.41,6.62-13.42-.7-.01,6.85-14.14,6.82-14.6-.17-.98,6.93-13.26,6.9-12.9-.1,.87,6.85-13.61,6.72-13.79-.33-.45,7.51-15.04,8.11-15.83,.99-1.89,6.29-13.27,5.59-12.49-1.73,1.87,6.68-13.63,6.63-13.72-.14-.24,6.43-14.54,6.02-15.5-1.01-2.3,6.57-14.15,6.63-14.19,.12-.08,6.44-14.1,6.39-14.07-.14,.05q6.47-14.11-.01-.02,6.47-14.1,0,.02c6.24-14.02,6-13.94-.58,.2,6.12-14.45,5.89-14.84-.59-.96,6.21-14.27,6.4-13.79,.3,1.08,6.19-13.99,6.09-13.95-.22,.1,6.13-14.23,6.01-14.46-.29-.56,6.26-14.44,6.35-14.75,.21-.77,6.21-14.3,6.07-14.03-.34,.57,6.08-14.26,6.04-14.35-.12-.22,6.11-14.22,6.15-14.1,.08,.29,6.08-14.08,6.02-14-.14,.2,5.81-14.67,5.46-15.21-.85-1.33,5.91-14.41,6.26-13.6,.49,1.81,5.74-13.66,5.41-13.27-.82,.94,5.79-13.76,5.74-13.71-.12,.12,5.77-13.89,5.75-13.97-.06-.22,5.92-13.76,5.99-13.72,.16,.08,5.76-13.87,5.69-13.92-.17-.15q5.79-13.84,0-.03,5.79-13.84,0,.02c5.54-14.07,5.28-14.27-.63-.51q5.64-13.98-.04-.06c5.81-14.11,5.98-14.25,.41-.36,5.73-14.05,5.62-13.99-.24,.12,6.43-15.08,7.06-15.61,1.13-1.3,5.28-14,4.69-13.63-1.45,.9,5.6-14.27,5.59-14.44-.03-.41,6.39-14.76,6.92-15.01,1.08-.66,5.37-14.28,4.91-14.17-1.13,.26,5.52-14.78,5.41-15.28-.26-1.22,5.62-14.75,5.72-14.93,.22-.46,5.58-14.66,5.47-14.52-.26,.3,5.34-15.23,5.11-15.87-.57-1.57,5.4-14.94,5.5-14.42,.11,1.14,5.32-14.91,5.23-15.14-.25-.55,5.37-14.81,5.52-14.09,.12,1.57,5.19-14.27,4.93-14.07-.59,.51,4.97-14.57,4.66-14.77-.77-.49,5.12-14.63,5.15-14.72,.05-.22,4.89-14.15,4.7-13.76-.47,.92q4.95-14.34-.12-.08c5.05-14.42,5.13-14.51,.2-.25,5.01-14.38,4.9-14.29-.25,.18q4.96-14.37,0-.08c5.08-14.6,5.2-14.84,.29-.6,5.12-14.55,5.18-14.59,.12-.08q5.01-14.49-.1,.04c5.17-14.83,5.31-15.17,.33-.84,5.1-14.69,4.88-14.35-.54,.71,5.06-14.95,5.13-15.2,.12-.55,4.82-14.3,4.65-13.95-.43,.86,4.83-14.42,4.74-14.39-.21,.09,4.78-14.61,4.68-14.77-.24-.4,4.63-14.81,4.42-15.08-.51-.67,4.88-15.44,4.98-16.25,.23-1.99,4.75-15.12,4.56-14.34-.63,1.58,4.28-15.09,3.91-15.39-.91-.72,4.19-15.61,3.89-16.29-.73-1.66,4.25-15.3,4.42-14.69,.22,1.34,3.76-15.3,3.18-15.56-1.42-.64,3.98-15.14,4.78-14.64,1.46,1.33,4.31-14.6,4.31-14.34,0,.64,4.31-14.5,4.29-14.3-.02,.51,3.92-14.78,3.51-14.95-.99-.42,4.56-15.12,4.86-15.33,.64-.53,3.82-14.65,3.43-14.47-.96,.43q3.98-14.71-.07-.02,4-14.71,.06,.04c3.47-14.44,2.97-14.14-1.23,.72q3.71-14.54-.04,0,3.72-14.55,0,0c3.66-14.94,3.55-15.33-.25-.96,4.44-15.6,5.06-16.68,1.49-2.6,4-15.34,3.39-14.37-1.6,1.69q3.62-14.95-.04,.04c3.57-15.58,3.45-16.22-.3-1.56,3.57-15.3,3.59-14.72-.09,1.24,3.5-15.1,3.46-15.19-.11-.2,3.52-15.07,3.57-14.91,.09,.36,3.53-14.92,3.53-14.87-.02,.16,3.44-14.89,3.24-14.75-.48,.31,3.26-15.06,3.08-15.22-.44-.4,3.54-15.22,3.67-15.35,.27-.3,3.24-14.96,3.1-14.86-.36,.23,3.15-15.12,2.98-15.25-.42-.3,3.4-15.27,3.58-15.49,.44-.54,3.32-15.18,3.05-14.97-.63,.42,3.03-15.18,2.88-15.27-.36-.22,3.21-15.39,3.31-15.66,.25-.65,3.3-15.51,3.38-15.63,.19-.29,3.13-15.3,3.08-15.25-.14,.12,3.23-15.54,3.29-15.76,.15-.55,3.2-15.44,2.88-14.84-.84,1.17q3.01-15.18,0,0,2.96-15.2-.11-.05,2.99-15.19,.09,.08c2.96-15.13,2.92-15.09-.11,.11,2.8-15.49,2.61-15.81-.48-.82,3.15-15.58,3.32-15.71,.36-.31,2.77-15.32,2.6-15.24-.44,.2,2.76-15.51,2.67-15.66-.24-.37,2.81-15.44,2.88-15.25,.14,.41,2.77-15.31,2.71-15.28-.16,.08,2.86-15.56,2.9-15.7,.08-.3,2.77-15.32,2.74-15.25-.1,.18,2.76-16.28,2.83-16.83,.03-1.2,2.55-14.98,2.36-14.34-.47,1.58,2.08-14.9,1.52-14.48-1.37,1.02,2.33-15.03,2.27-15.02-.15,.03,2.23-15.26,2.09-15.48-.35-.54,2.42-15.39,2.55-15.64,.32-.6,2.36-15.29,2.17-15.08-.43,.44,1.99-15.54,1.69-15.88-.73-.83,2.14-15.5,2.2-15.61,.12-.29,2.12-15.44,2.05-15.33-.18,.23,1.99-15.48,1.89-15.57-.24-.22,2.44-15.84,2.71-16.03,.56-.48,1.85-15.42,1.55-15.29-.73,.33q1.96-15.5-.08-.08,1.97-15.49,.06,.09c1.94-15.45,1.89-15.42-.11,.06,2.08-15.91,2.18-16.37,.22-1.14,2.01-15.71,1.76-15.05-.7,1.3,1.25-15.88,.58-16.28-1.65-.99,1.49-15.64,2.17-15.08,1.26,1.38q1.74-15.31-.07,.05c1.21-15.76,.6-16.16-1.49-.97,1.42-15.54,2.02-15.01,1.1,1.3,1.6-15.19,1.52-15.13-.17,.16,1.44-15.18,1.26-15.13-.44,.11,1.44-15.37,1.34-15.56-.24-.44,1.55-15.47,1.61-15.57,.11-.23,1.44-15.28,1.38-15.21-.14,.16,1.32-15.56,1.17-15.8-.39-.61,1.45-15.72,1.51-15.88,.1-.36,1.33-15.41,1.27-15.29-.17,.28,1.23-15.65,1.09-15.84-.35-.47,1.29-15.56,1.42-15.28,.24,.65,1.22-15.21,1.1-14.99-.28,.53,.93-16.42,.4-17.52-1.32-2.66,.99-15.89,1.53-14.49,.53,3.06q1.1-15.19,0,.06c.98-15.23,.86-15.24-.3-.05,1-15.42,.97-15.62-.1-.5,1.04-15.98,1.02-16.65-.07-1.65,1-15.69,.88-14.68-.57,2.06q.87-15.23-.02,0c.83-15.33,.79-15.43-.09-.25,.88-15.39,.9-15.46,.04-.14q.83-15.28-.06,.1c.8-15.41,.76-15.52-.11-.28,.66-16.06,.4-16.76-.62-1.72,.68-15.74,.76-15.39,.1,.78,.25-16.25-.34-16.89-1.42-1.56,.39-15.91,1.05-15.01,.99,2.08,.63-15.37,.66-15.27,.07,.23,.45-15.21,.29-15.01-.39,.47,.44-15.45,.34-15.6-.25-.38,.69-15.84,.86-16.09,.31-.58,.38-15.35,.22-15.19-.39,.39,.42-15.62,.39-15.81-.11-.48,.44-15.53,.44-15.35-.02,.4,.26-15.67,.07-15.89-.45-.54,.14-16.38-.15-17.2-.73-2,.17-16.01,.32-15.36,.15,1.42,.17-15.73,.13-15.77-.1-.09,.24-15.78,.28-15.83,.08-.09q.16-15.7-.1,.08c-.54-16.36-1.36-16.94-2.01-1.42-.27-16.03,.56-15.28,1.46,1.84-.17-15.44-.38-15.25-.53,.47-.02-15.8,0-15.96,.05-.36-.16-15.38-.25-15.15-.24,.55-.29-15.3-.46-15.11-.43,.45-.23-15.47-.27-15.56-.08-.22-.22-15.43-.2-15.3,.03,.28-.31-15.24-.42-15.12-.25,.3-.43-15.66-.62-16.01-.47-.86,.78-16.31,1.58-16.64,1.59-.94-.84-15.58-1.61-15.39-1.9,.47-.48-15.67-.54-15.73-.13-.17-.05-16.03,.23-16.23,.57-.48-.63-15.63-.92-15.5-.7,.31-.52-15.71-.55-15.75-.07-.09-.51-15.69-.49-15.64,.04,.11-.99-15.43-1.44-15.16-1.11,.66-1.23-15.88-1.75-16.21-1.3-.79-1.03-15.7-.53-15.28,.95,1.05-1.13-15.22-1.41-14.96-.7,.64-.96-15.49-.94-15.67,.03-.43-.97-15.42-1.05-15.12-.24,.65-1.13-15.15-1.23-15.03-.25,.31-1.44-15.13-1.8-15.02-.87,.25-1.43-15.16-1.59-15.17-.39-.01-1.37-15.31-1.37-15.46-.02-.39-1.36-15.24-1.39-15.07-.08,.39q-1.4-15.15-.05,0c-1.44-15.47-1.52-15.8-.17-.8-.75-15.96-.28-16.25,.94-.75-1.91-15.28-2.54-15-1.56,.68-1.87-15.93-2.22-16.52-.87-1.42-1.76-15.66-1.45-14.91,.45,1.67-1.8-15.2-1.94-15.11-.34,.23-1.81-15.28-1.88-15.33-.18-.11-1.65-16.33-1.67-17.46-.08-2.76-1.79-15.88-1.88-14.67-.6,2.43-2.88-15.72-3.97-15.89-2.62-.41-2.6-15.61-2.7-15.8-.25-.46-2.56-15.53-2.52-15.38,.08,.34-2.82-15.67-3.1-15.88-.71-.51-2.7-15.57-2.26-15.1,.81,1.12-2.51-15.26-2.5-15.21,.02,.15-2.58-15.31-2.65-15.33-.17-.05-3.39-16.48-4.53-17.55-2.78-2.54-3.17-15.86-2.15-14.85,1.66,2.43-2.69-15.12-2.58-14.89,.26,.54-2.9-14.84-3.02-14.47-.33,.9q-2.83-14.99-.04,.02c-3.03-15.5-3.11-15.82-.23-.68-2.88-14.82-2.85-14.5,.04,.79-3.09-14.84-3.3-14.71-.52,.33-3.19-14.93-3.4-14.95-.51-.05-2.66-15.49-2.33-15.79,.63-.72-3.44-14.81-3.87-14.52-1.08,.71-3.74-14.89-4.31-14.81-1.37,.2-3.27-15.02-3.14-15.09,.3-.18-3.58-14.88-3.72-14.84-.35,.09-4.11-16.48-5.18-18-2.57-3.61-4.08-15.69-3.23-14.47,1.23,2.8-3.68-14.64-3.56-14.17,.29,1.14-3.93-14.83-4.11-14.84-.45-.02-3.91-14.91-3.95-14.97-.08-.12-3.84-14.79-3.82-14.74,.05,.12-4.05-14.82-4.24-14.82-.48,.01-3.92-15.14-3.9-15.48,.04-.82-3.95-15-4.04-14.61-.29,.84-4.56-14.77-5.12-14.67-1.36,.23-4.84-14.86-5.38-14.92-1.32-.15-4.61-14.79-4.25-14.69,.76,.3q-4.44-14.73,.01,0c-4.53-14.69-4.62-14.66-.22,.08-4.67-14.74-4.84-14.76-.43-.05-4.58-14.72-4.46-14.68,.27,.11-4.76-14.6-5.01-14.51-.59,.24-4.66-14.64-4.23-14.72,.95-.06q-4.43-14.64,.06,.04c-4.61-14.39-4.78-14.13-.41,.64-4.75-14.6-4.99-14.68-.58-.19-5.12-15.04-5.63-15.49-1.28-1.11-4.94-14.8-4.58-14.38,.67,1-5.63-15.18-6.61-15.66-2.39-1.13-5.32-14.83-4.59-14.41,1.38,1.13-5.4-14.54-5.79-14.48-.95,.16-5.23-14.54-4.58-14.54,1.33,.23q-4.9-14.45,.08,.09c-4.84-14.39-4.77-14.3,.17,.21-4.87-14.37-4.87-14.32,0,.13-5.13-14.41-5.39-14.43-.63-.06-5.03-14.46-5.03-14.51-.02-.13-5.02-14.43-5.02-14.37,0,.13-5.18-14.43-5.34-14.45-.39-.05-5.21-14.62-5.3-14.83-.26-.51-5.16-14.53-5.1-14.32,.11,.48-5.23-14.44-5.32-14.44-.22-.03-5.09-14.37-5-14.31,.24,.15-5.08-14.05-5.03-13.61,.11,1.09-5.47-14.25-5.86-14.33-.93-.18-5.34-14.53-5.34-14.72-.02-.43-5.37-14.12-5.4-13.95-.1,.42-5.47-14.21-5.6-14.23-.31-.03-5.41-14.2-5.28-14.16,.29,.11-5.44-13.73-5.49-13.28-.13,1.1-5.49-13.91-5.6-13.89-.28,.06-5.5-13.94-5.56-13.94-.15-.03q-5.47-13.95-.01-.05c-5.15-15.62-5.32-17.49-.44-4.42-5.57-14.92-5.42-13.56-.22,2.8-5.7-13.88-5.82-13.44-.27,1.08-5.85-14.22-6.03-14.39-.44-.4-5.9-14.78-6.1-15.43-.49-1.56-5.89-14.5-5.79-13.94,.05,1.21-6.07-14.37-6.26-14.51-.48-.34-5.98-14.3-5.75-14.05,.47,.6-5.89-13.95-5.91-13.72-.06,.58-6.08-14.16-6.18-14.25-.24-.17-5.85-13.97-5.77-13.86,.22,.27q-5.89-14,0,.06c-5.91-13.93-5.92-13.84-.03,.2-6.03-13.96-6.16-13.95-.31,.02-5.9-14.76-5.78-15.22,.16-1.03-6.27-13.55-6.54-12.92-.66,1.56-6.28-13.66-6.46-13.48-.45,.45-6.36-13.93-6.55-14.12-.46-.46-6.25-13.93-6.22-14.02,.08-.21q-6.27-13.89,0-.01c-5.87-14.78-5.55-15.26,.59-1.12q-6.14-14.14-.02,.02c-6.07-14.26-6.02-14.32,.1-.15-6.63-13.74-7.07-13.28-1.1,1.13-7.15-14.85-8.17-15.67-2.47-1.96-6.91-14.35-6.42-13.91,.92,1.08-7.41-14.43-8.18-14.69-1.87-.61-7.12-14.25-5.9-13.65,2.21,1.71-6.4-13.64-6.16-13.38,.58,.62-6.54-13.67-6.57-13.61-.08,.15-7.11-14.12-7.41-14.43-.73-.6-6.46-13.46-6.22-13.12,.58,.85q-6.55-13.64,0,0-6.6-13.64-.11,0-6.58-13.64,.1,.02c-6.62-13.52-6.67-13.41-.14,.28q-6.59-13.57,0,0c-6.94-13.69-7.32-13.79-.91-.25-7.57-14.51-8.54-15.31-2.37-1.9-7.32-14.05-6.65-13.41,1.2,1.54-7.77-14.17-8.57-14.54-1.94-.89-7.48-13.91-7-13.61,.96,.78-7.39-13.13-7.47-12.52-.2,1.49-7.58-13.46-7.85-13.51-.67-.12-8.06-14.05-8.76-14.61-1.7-1.38-7.84-13.74-6.82-12.65,1.61,2.62-7.45-13.1-7.43-13.03,.06,.15-7.58-13.04-7.68-12.95-.26,.22-7.82-13.12-8.12-13.14-.73-.06-7.36-13.61-7.12-13.88,.46-.65-7.93-12.98-8.26-12.72-.8,.64-7.9-13.09-8.04-13.07-.34,.02-9.02-14.15-9.58-14.99-1.42-1.56-7.89-12.72-7.57-12.05,.76,1.63-8.36-13.01-8.74-12.93-.94,.2-8.47-13.54-8.77-14.05-.75-1.25-8.36-13.3-8.13-12.69,.36,1.37-8.65-12.88-9.01-12.75-.9,.34-8.48-12.92-8.05-12.99,.95-.06-8.23-12.7-8.19-12.45,.09,.62-8.32-12.67-8.39-12.54-.17,.32-8.83-12.69-9.39-12.6-1.37,.22-9.19-12.61-9.8-12.49-1.49,.31-8.92-12.61-8.69-12.61,.52,.02q-8.84-12.59-.08,.03c-8.83-12.6-8.74-12.61,.2-.02-8.28-12.55-7.55-12.43,1.73,.35-8.57-12.47-8.75-12.39-.43,.16-8.58-12.64-8.62-12.74-.1-.2-8.5-12.44-8.47-12.35,.05,.23-8.88-12.31-9.26-12.11-.92,.5-9.64-13.1-10.79-13.66-2.78-1.31-9.33-12.66-8.86-12.41,.94,.65-9.07-12.44-9.02-12.35,.12,.22-9.4-12.75-9.72-13.02-.8-.65-9.27-12.61-8.56-11.78,1.17,1.96-9.05-11.99-9.09-11.81-.09,.46-9.46-12.54-9.94-12.98-1.19-1.07-9.29-12.31-8.73-11.64,.94,1.59-9.27-11.94-9.45-11.93-.45,.06-9.18-11.95-8.95-11.93,.52,.09-9.04-11.85-9-11.78,.08,.19-9.06-11.75-9.07-11.61-.02,.33-9.12-11.79-9.2-11.77-.17,.05-9.99-12.69-11.18-13.38-2.82-1.6-9.72-12.16-9.07-11.77,1.23,1.02-10.11-11.35-10.64-10.76-1.31,1.47-10.81-12.3-12.1-12.81-3.1-1.2-10.43-11.87-9.19-11.3,2.26,1.64q-9.9-11.48,.06,.06c-10.21-11.65-10.37-11.75-.38-.22-9.73-11.25-9.45-10.97,.68,.68-9.95-11.12-10.03-10.85-.2,.67-9.93-11.05-9.96-10.85-.07,.47q-9.91-11.13-.02,.03c-9.91-11.23-9.9-11.28,.01-.13-9.94-11.05-9.97-10.95-.08,.26-10.07-10.83-10.2-10.54-.33,.69-10.42-11.35-10.9-11.73-1.18-.91-10.57-11.79-10.7-12.2-.36-.86-10.33-11.07-10.3-10.81,.06,.65-10.39-11.32-10.45-11.44-.16-.3-10.36-11.26-10.33-11.13,.06,.29-10.55-11.3-10.77-11.41-.53-.25-10.46-11.25-10.18-11.04,.57,.53-10.32-10.95-10.3-10.73,.04,.54-10.61-11.09-10.9-11.15-.71-.15-10.57-11.17-10.65-11.29-.21-.3-10.58-11.32-10.6-11.44-.06-.27-10.54-11.1-10.54-11.03,0,.19-10.8-11.48-11.09-11.83-.7-.84-10.7-11.32-10.42-10.82,.48,1.15q-10.59-11.06,0,0c-10.5-10.79-10.41-10.48,.23,.76-10.52-10.63-10.49-10.37,.07,.63q-10.53-10.75-.04,0c-11.12-11.64-11.36-12.26-.68-1.23-10.59-10.37-10.43-9.75,.37,1.52-10.62-10.62-10.65-10.55-.06,.17q-10.62-10.65-.02,0c-10.65-10.8-10.69-10.95-.09-.37-10.64-10.74-10.64-10.54-.01,.44-11.27-10.27-11.83-9.85-1.36,1.04-11.17-11.11-11.23-11.54-.23-.93-11.05-10.11-11.06-9.61-.03,1.21-11.15-10.16-11.3-9.98-.35,.46-12.05-10.69-13.14-11.01-2.65-.76-11.67-10.41-10.48-9.92,2.23,1.44q-11.19-10.05-.04,.1c-11.99-10.57-12.9-10.99-2.21-.99-11.67-10.29-10.92-9.85,1.44,1.18-11.51-10-11.66-9.99-.38,.05-11.44-10.01-11.2-9.99,.51,.08-11.24-9.91-11.16-9.83,.2,.21q-11.31-9.94-.07,.02-11.25-9.95,.11,.01c-11.22-9.89-11.18-9.84,.12,.13-11.31-9.73-11.38-9.53-.15,.47-11.33-10.02-11.34-10.15-.05-.28-11.31-9.62-11.32-9.38-.03,.61q-11.3-9.74,0,.01c-11.63-10.08-11.98-10.42-.87-.82-11.49-9.91-11.07-9.34,.75,1.33-11.54-9.94-11.78-10.25-.59-.76-11.46-9.79-11.2-9.3,.41,1.11-11.49-9.56-11.62-9.56-.31-.02-11.52-9.58-11.6-9.62-.21-.09-11.49-9.81-11.49-9.95-.01-.32-11.51-9.52-11.54-9.41-.06,.28q-11.54-9.6-.11-.05c-11.52-9.59-11.47-9.54,.11,.08q-11.5-9.54-.02,.08-11.51-9.55-.02,0c-12.5-10.51-13.78-11.27-3.08-1.8-12.19-9.95-11.07-9.25,1.96,1.87-11.51-9.24-11.26-8.89,.62,.82q-11.65-9.35-.07-.02c-12.21-9.89-12.91-10.36-1.7-1.11-12.01-9.6-11.51-9.2,.93,.99-12.3-9.43-12.8-9.45-1.24-.04-12.08-9.39-11.25-9.21,1.68,.66-11.63-9.12-11.54-8.98,.21,.33-11.93-8.85-12.18-8.51-.61,.83-12.2-8.96-12.59-8.91-.98,.13-12.5-9.04-12.87-9.12-.87-.18-12.33-9.13-12.4-9.22-.15-.18-12.22-8.97-12.18-8.91,.07,.16-12.31-9.02-12.36-9.05-.11-.04-12.2-8.97-12.14-8.95,.13,.08-12.15-8.84-12.09-8.7,.17,.36-12.51-8.81-12.83-8.69-.79,.29-12.82-9.38-13.04-9.74-.56-.73-12.37-8.65-12.24-8.32,.31,.83-12.99-8.56-13.56-8.24-1.4,.79-12.73-8.65-12.01-8.91,1.59-.34-12.12-8.2-11.82-7.71,.72,1.2q-12.25-8.41-.1,.12c-13.43-8.67-14.71-8.7-3.07-.02-12.92-8.44-11.67-8.32,2.5,.72-12.52-8.13-12.67-7.97-.37,.39-12.73-8.19-13.03-8.17-.72,.05-12.87-8.28-13.14-8.36-.67-.22-12.75-8.23-12.58-8.13,.38,.25q-12.71-8.17-.1,.01c-12.69-8.17-12.63-8.17,.15,.02-12.48-8.03-12.25-7.85,.54,.44q-12.56-8.04-.04,.06c-12.67-8.19-12.73-8.27-.15-.18-12.54-7.99-12.49-7.9,.11,.24q-12.56-8.03-.02,.02c-12.96-8.18-13.19-8.29-.51-.21-12.5-7.93-12.33-7.8,.43,.34q-12.59-7.98-.03,.05c-14.02-9.17-14.69-10.18-1.72-1.79-12.54-7.24-11.98-6.21,1.36,2.49q-12.69-7.8-.04,.1c-13.79-8.66-14.34-9.36-1.36-1.27-12.87-7.85-12.75-7.61,.29,.59-12.96-7.72-13-7.46-.1,.62-13.11-7.9-13.28-7.98-.43-.18-13.03-7.87-12.83-7.73,.41,.33-13-7.3-13.02-6.81-.06,1.2-13.36-7.49-13.77-7.42-1,.18-13.48-7.47-13.78-7.44-.75,.08-13.34-7.47-12.47-7.4,1.79,.48-12.92-7.17-12.89-6.97,.07,.48-13.23-7.34-13.54-7.41-.77-.16-13.16-7.39-13.19-7.44-.08-.12q-13.1-7.27,.04,.12c-13.89-7.41-14.72-7.42-2.02,0-13.56-7.3-12.41-7.16,2.24,.76q-13.03-7.11,.07,.04-13.04-7.12,.01,.03c-13.33-7.02-13.62-6.91-.71,.26-13.2-7.05-12.88-7.1,.71-.05-13.05-6.91-13.06-6.77-.02,.36-13.83-7.36-14.72-7.62-2.16-.61-13.52-7.12-12.52-6.73,1.86,1.19-12.98-6.75-12.84-6.63,.33,.29-13.04-6.73-13.02-6.66,.02,.16-13.3-6.65-13.56-6.53-.64,.29q-13.18-6.69,0,0c-13.28-6.63-13.38-6.58-.25,.15-13.38-6.81-13.52-6.96-.36-.37-13.31-6.74-13.19-6.55,.24,.44-13.42-6.55-13.57-6.45-.38,.25-13.88-6.63-14.43-6.63-1.36,.01-13.64-6.58-13.19-6.51,.96,.27-14.05-6.03-14.63-5.44-1.42,1.44q-13.76-6.22-.03-.04-13.75-6.21,.02,.05-13.75-6.2,0,0c-13.69-6.09-13.57-5.83,.27,.62-13.95-6.06-14.21-6.06-.64,.02-13.83-6.06-13.52-6.01,.67,.18-14.29-5.66-14.88-5.22-1.42,1.09-14.15-5.8-14.31-5.82-.39-.06-14.08-5.79-13.94-5.73,.31,.14-14.51-5.26-14.97-4.69-1.1,1.4-14.26-5.45-13.56-6.1,1.67-1.1-13.61-5.54-13.29-5.34,.79,.49-13.64-5.28-13.56-4.99,.21,.71q-13.68-5.42-.04,.01c-13.84-5.37-14.01-5.32-.4,.13-15.17-5.39-16.66-5.04-3.57,.88-14.56-5.2-13.66-5.38,1.93-.08-14.46-5.01-14.78-4.77-.78,.57-14.63-5.05-14.96-5-.81,.13-14.48-5.06-14.22-5.05,.57,.07-15.18-4.34-15.95-3.49-1.87,2.08-14.77-4.58-14.1-5.17,1.6-1.04-14.14-4.71-13.87-4.61,.67,.23-13.95-4.5-13.56-4.15,.92,.88-14.39-3.92-14.64-3.21-.62,1.73-15.19-4.11-16.21-3.84-2.47,.67-14.75-4.03-14.09-4.16,1.44-.04q-14.47-4.04-.1,.02c-14.45-4.04-14-4.04,.98,.1-14.26-3.84-14.3-3.67-.07,.43-15.42-3.76-16.14-3.84-1.55,.06-13.98-3.68-13.36-3.53,1.5,.39-14.27-3.74-14.28-3.66-.02,.19-14.27-3.78-14.24-3.86,.07-.19-13.92-3.77-13.6-3.72,.79,.09-14.25-3.47-14.41-3.12-.39,.85-14.16-3.61-13.99-3.87,.43-.53-13.97-3.73-13.88-3.72,.22,.01-14.21-3.51-14.39-3.29-.46,.55-14.17-3.56-14.22-3.52-.12,.1-14.28-3.65-14.41-3.72-.34-.17-14.22-3.62-14.1-3.52,.26,.23q-14.19-3.54-.07,.06c-14.39-3.54-14.6-3.51-.52,.07-14.84-3.83-15.42-4.09-1.44-.62-14.61-3.67-14.16-3.38,.92,.75-14.82-3.39-15.23-3.24-1.01,.38-14.63-3.42-13.99-3.55,1.36-.04-14.22-3.33-14.11-3.2,.27,.29-14.32-3.28-14.37-3.19-.12,.22-14.65-3.52-15.02-3.7-.92-.45-14.5-3.42-14.11-3.13,.77,.74-14.45-3-14.57-2.74-.29,.64-16.12-3.28-17.97-2.89-4.4,.95-15.37-2.9-14.01-3.22,2.87-.05-14.26-2.86-13.76-2.78,1.23,.2-14.57-2.76-14.69-2.66-.28,.26-14.79-3.02-14.92-3.15-.33-.28-14.5-2.71-14.4-2.57,.25,.37-14.62-2.7-14.7-2.61-.2,.22q-14.58-2.74,0,0c-15.13-2.16-15.63-1.51-1.22,1.59-14.86-2.39-14.29-2.93,1.33-.99-14.51-2.37-14.45-2.14,.14,.57q-14.53-2.48,0,0c-14.47-2.25-14.4-2.03,.17,.54-15.46-1.84-16.37-1.08-2.2,1.82-15.32-1.86-15.67-1.76-.84,.26-15.17-1.9-14.88-1.93,.63-.02-15.24-1.64-15.44-1.36-.5,.68-15.14-1.75-14.75-2.1,.93-.67-14.68-1.88-14.39-1.85,.7,.08-14.68-1.81-14.59-1.73,.23,.18-15.15-1.73-15.4-1.69-.56,.12-14.59-1.79-14.34-1.77,.63,.05-14.76-1.6-14.81-1.4-.12,.51-15.72-1.29-16.68-.71-2.28,1.43-15.24-1.37-14.27-1.87,2.18-.63-14.79-1.19-14.81-.85-.04,.82-14.77-1.33-14.67-1.74,.3-.86-14.64-1.53-14.59-1.54,.14-.02-14.49-1.55-14.31-1.57,.45-.05-14.56-1.45-14.54-1.36,.04,.22q-14.59-1.46-.08,.08c-14.63-1.47-14.67-1.47-.08,0q-14.57-1.47,.06,.01c-15.17-.93-15.7-.28-1.3,1.57q-14.88-1.12-.03,.01-14.88-1.12,.02,0c-15.41-.26-15.86,.72-1.09,2.39-15.11-.59-14.4-1.81,1.88-2.16-14.65-1.11-14.59-1.16,.13-.12-14.73-1.02-14.8-.94-.16,.18q-14.7-1.05-.02,0-14.71-1.05,.02,0c-15.71,.1-16.46,1.62-1.75,3.65-15.6,.4-16.08,1.12-1.14,1.76-15.34,.15-14.58-.74,1.87-1.54-15.04-.02-15.15,.15-.27,.43-15.58,.27-16.17,.71-1.41,1.09-15.3,.15-14.27-.45,2.32-.77-14.69-.04-14.59-.06,.24-.04q-14.71,0,.04,.06c-15.05,.23-15.37,.51-.78,.68-14.9,.13-14.47-.12,.97-.44-14.65,.09-14.61,.14,.1,.12-16.08,.83-17.43,2.14-3.02,3.07-15.33,.74-14.47-.19,2.14-1.52-14.3,.11-13.65-.18,1.58-.71-15.01,.59-15.47,1.01-1.15,1.02-14.95,.26-15.04,.11-.23-.3-14.75,.57-14.68,.72,.16,.38-14.81,.53-14.85,.57-.08,.1-15.01,.61-15.22,.71-.52,.25-14.91,.57-14.75,.54,.36-.06-15,.77-15.15,.99-.38,.54-15.2,.7-15.49,.73-.71,.08-15.07,.7-14.8,.73,.59,.11-15.02,.83-15.08,.95-.17,.29-14.98,.78-14.86,.66,.29-.26-14.57,.81-14.13,.94,1.05,.32-15.37,1.22-15.81,1.4-.93,.49-14.33,.83-13.78,.72,1.33-.27-14.54,.92-14.49,1,.12,.19q-14.59,.91-.07,.06c-14.6,.81-14.61,.76-.03-.12-14.59,.93-14.59,.99,0,.14-15.13,1.4-15.64,1.97-1.24,1.4q-14.86,1.22,0,0c-15.01,1.42-15.14,1.63-.34,.52-15.71,1.82-16.45,2.44-1.8,1.49-15.34,1.66-14.77,1.31,1.31-.6-15.09,1.62-15.14,1.71-.11,.22-15.07,1.58-14.97,1.45,.24-.26-14.52,1.34-13.92,1.17,1.47-.42-14.66,1.42-14.62,1.42,.1-.02q-14.67,1.43-.02,.02-14.68,1.43,.03-.02c-14.48,1.38-14.29,1.35,.48-.09q-14.52,1.42,.1,.05-14.54,1.41,0,.01c-15.42,2.03-16.01,2.29-1.2,.71-14.25,1.48-13.73,1.35,1.31-.3-14.45,1.74-14.38,1.98,.18,.57-14.8,2.02-15.11,2.44-.75,1.03-14.82,1.85-15,1.83-.44-.04-14.74,1.85-14.57,1.9,.38,.14-14.8,2.12-14.95,2.36-.34,.6-14.73,2.02-14.52,1.77,.54-.52-14.39,2-14.12,2.13,.66,.33-15.87,3.1-17.03,4.7-2.75,3.8-15.08,2.82-14.22,1.67,2.18-1.98-14.25,2.5-13.82,2.68,1.04,.44q-14.37,2.51,.02,.06c-15.01,2.46-15.67,2.52-1.6,.16-14.72,2.53-14.51,2.54,.45,.05-14.54,2.69-14.45,2.84,.2,.36-14.87,2.74-15.05,2.79-.39,.14-14.47,2.65-14.29,2.63,.45-.03-14.18,3.3-13.75,3.89,1.04,1.44-14.95,3.18-15.58,3.48-1.53,.75-14.67,3.13-14.28,3,.87-.19-14.93,3.33-15.38,3.62-1.11,.69-14.72,3.24-14.03,2.96,1.53-.36-14.41,3.25-14.44,3.33-.07,.2-14.4,3.21-14.33,3.11,.15-.22-14.16,3.13-13.93,3.11,.55-.06-15.72,3.97-16.8,4.16-2.1,.83-14.41,3.35-14.11,3.35,.72,.01-14.06,3.44-13.57,3.51,1.19,.16-14.35,3.48-14.42,3.61-.17,.29-14.6,3.73-14.87,4.06-.65,.79-14.82,3.39-15.01,3.23-.45-.31-14.43,3.73-14.28,3.91,.35,.44-14.78,4.08-15.04,4.54-.63,1.14-14.62,3.9-14.36,3.56,.64-.66-14.88,4.13-15.27,4.56-.94,1.04-14.69,3.98-14.24,3.63,1.04-.64-14.36,3.86-14.27,3.87,.22,.04-14.39,3.9-14.39,3.95,.03,.13-14.79,3.99-15.01,4.03-.5,.13-14.29,3.93-14.07,3.93,.55,.03q-14.38,3.94,.02,.07c-14.7,5.33-14.73,6.9-.04,3.78-14.39,4.77-14.33,3.57,.53-2.42-14.12,4.58-13.94,4.92,.43,.82-14.18,4.49-14.17,4.57,.01,.19-14.47,4.54-14.75,4.64-.71,.25-14.33,4.51-14.01,4.46,.72-.04-14.15,4.77-14.13,5.05,.08,.67-14.55,5-14.93,5.38-.92,.95-14.36,4.86-13.62,4.32,1.71-.84-13.85,4.81-13.71,4.94,.33,.32-13.95,4.85-13.98,4.95-.09,.25-13.99,4.8-14.04,4.8-.14,0-13.96,4.8-13.9,4.82,.13,.04-14.15,5.48-14.29,6.19-.35,1.75-14.15,5.58-14.28,5.99-.29,1-14.77,5.23-15.16,5.06-.89-.3-13.94,5.62-13.59,5.85,.84,.59-14.13,5.78-14.18,6.08-.1,.75-14.11,5.65-14.01,5.35,.27-.64-13.98,5.55-13.91,5.59,.17,.11-13.98,5.91-13.93,6.3,.11,.95-13.98,5.74-13.96,5.42,.11-.7-13.86,5.59-13.77,5.59,.24,0-13.78,5.65-13.65,5.72,.31,.15-13.74,5.68-13.65,5.73,.23,.14q-13.82,5.65-.07,0-13.8,5.65,.09,.02c-13.78,5.66-13.81,5.71-.02,.05-14.11,5.69-14.43,5.72-.8,.08-13.96,5.68-13.64,5.71,.71,.13-14.1,6.46-14.32,7.28-.53,2-13.92,6.16-13.66,5.51,.73-1.3-13.81,6.02-13.85,6.16-.11,.36-13.79,5.95-13.56,5.51,.6-.86-13.41,5.84-13.16,5.93,.63,.23-13.86,6.45-14.13,7.16-.65,1.74q-13.66,6.21-.02,.03-13.66,6.2,.02-.02c-13.7,6.39-13.74,6.59-.1,.48-13.68,6.31-13.51,5.91,.45-.8-13.26,5.87-12.78,5.52,1.18-.79-13.03,6.2-12.73,6.4,.73,.52-13.21,6.13-13.27,6.19-.14,.15-13.23,6.16-13.27,6.22-.11,.15q-13.28,6.06-.1-.09c-13.2,6.16-13.17,6.21,.07,.12-13.48,6.48-13.72,6.86-.59,.92q-13.42,6.31-.1-.05-13.33,6.37,.09,.08c-13.95,7.51-14.32,8.9-.85,3.34-13.54,7.09-13.24,6.06,.97-1.99-13.26,6.64-13.2,6.62,.15-.04-13.84,7.74-14.21,9.03-.89,3.11-13.49,7.33-13.13,6.31,1.07-1.96-12.75,6.78-12.28,6.63,1.16-.37-12.94,6.91-12.88,7,.13,.23-13.43,7.54-13.86,8.28-1,1.82-13.18,7.27-12.8,6.75,.97-1.02-13.13,7.48-13.24,7.94-.28,1.13-13.12,7.39-13.21,7.51-.22,.26-13.79,7.77-14.46,8.3-1.64,1.3-13.44,7.64-12.9,7.3,1.28-.57-12.22,7.71-11.3,7.75,2.23,.12-12.85,7.94-13.02,8.35-.41,1.01-12.76,7.77-12.59,7.51,.4-.54-12.69,7.86-12.71,8.06-.04,.51-12.68,7.76-12.54,7.34,.38-.89-12.54,7.51-12.48,7.45,.14-.15-12.33,7.97-12.07,8.38,.63,1.01-13.13,8.78-13.74,9.29-1.08,1.26-12.32,7.86-12,7.68,.8-.46-12.56,8.1-12.63,8.26-.17,.41-12.69,8.06-12.87,8.1-.43,.09-12.62,8.05-12.44,8.05,.39,.02-12.69,8.52-12.82,9.01-.3,1.21-12.6,8.32-12.35,7.72,.68-1.17-12.33,8.08-12.21,8.1,.3,.05q-12.38,8.11,.01,.09-12.38,8.09,0,0c-12.62,8-12.75,7.93-.31-.13-12.33,8.16-12.22,8.25,.28,.23-12.7,9.08-12.83,10.17-.29,2.64-12.45,8.7-12.32,7.86,.56-1.67-12.29,8.46-12.25,8.58,.1,.32-12.53,8.61-12.67,8.72-.3,.26-12.23,8.4-12.1,8.33,.33-.16q-12.28,8.46,.03,.09-12.29,8.44,0-.1c-12.18,8.36-12.07,8.31,.27-.13-12.17,8.54-12.1,8.69,.17,.36-12.12,8.76-12.03,9.04,.22,.69-12.16,8.7-12.19,8.78-.05,.2-12.16,8.67-12.13,8.6,.07-.14-12.1,8.74-12.06,8.85,.1,.26-12.36,9.04-12.6,9.4-.57,.89-12.84,9.21-13.42,9.59-1.43,.95-12.56,9.1-12.06,8.87,1.13-.37-12.52,9.44-12.71,9.86-.46,1.06-12.41,9.26-12,8.64,1.05-1.19-11.91,8.94-11.63,8.89,.7-.11-12.05,9.03-12.06,9.09-.04,.15-12.62,9.39-13,9.56-.79,.46-11.92,9.05-11.63,8.99,.7-.15-12.33,10.12-12.44,11.27-.26,2.77q-12.11,9.71,0,.06-12.11,9.7,0-.02c-12.07,10.4-11.98,11.12,.24,1.77-12.06,10.09-12.03,8.59,.63-2.99-11.74,9.07-11.52,8.68,.54-.95-11.53,9.55-11.23,9.88,.73,.81-11.64,9.39-11.91,8.95-.49-1.01-11.6,9.08-11.46,8.99,.37-.22-11.52,9.04-11.37,8.96,.37-.2-11.47,9.05-11.36,9.03,.28-.06-11.9,10.01-12.26,10.52-.61,1.2-11.17,8.9-10.74,8.43,1.04-1.13-11.12,9.3-10.78,9.5,.81,.51q-11.24,9.19,.01,0c-11.35,9.29-11.45,9.38-.26,.24-11.43,9.31-11.55,9.39-.31,.19-11.59,9.31-11.72,9.31-.29,.02-11.35,9.31-11.27,9.32,.2,.05-11.54,9.4-11.69,9.49-.36,.25-11.47,9.35-11.28,9.28,.43-.13-11.87,9.88-12.31,10.54-1.07,1.61-11.61,9.68-10.95,8.87,1.63-1.34-11.2,9.36-11.15,9.33,.12-.08-11.29,9.84-11.34,10.32-.1,1.18-11.46,9.82-11.62,9.93-.38,.29-12.07,9.75-12.51,9.69-.97,0-11.19,9.84-10.84,9.96,.87,.29-11.63,10.02-11.91,10.31-.67,.71-11.5,9.92-11.08,9.61,.97-.53-11.68,10.36-12.04,10.98-.86,1.52-11.48,10.14-11.04,9.57,1.09-1.06-11.23,9.97-11.23,10.04,.01,.17-11.23,9.94-11.22,9.85,.03-.2q-11.18,9.86,.12-.09c-11.14,10.5-11.03,11.14,.27,1.57-11.14,10.22-11.14,9.54,.15-1.47-10.91,10.05-10.71,10.18,.48,.33-11.25,10.73-11.42,11.55-.39,1.99-11.7,10.95-12.11,11.22-.84,.66-10.93,10.44-10.59,10.32,.82-.31-11.1,10.73-11.1,10.98,0,.61-11.09,10.63-11.02,10.3,.22-.71-10.34,10.15-9.69,9.78,1.59-.9-10.69,10.33-10.68,10.4,.01,.16-10.73,10.35-10.79,10.4-.12,.12-10.71,10.33-10.66,10.3,.12-.08-10.67,10.44-10.65,10.56,.05,.31-10.68,10.66-10.65,10.94,.04,.68-10.75,10.58-10.84,10.63-.21,.11-10.89,10.62-11.07,10.69-.43,.16-10.81,10.6-10.74,10.59,.14-.02-10.99,10.69-11.11,10.74-.27,.12-10.49,10.58-10.17,10.53,.81-.12-10.65,10.65-10.64,10.71,.02,.15-10.75,10.7-10.85,10.76-.24,.18-10.71,10.66-10.59,10.61,.26-.09q-10.64,10.7,.03,.13-10.64,10.67,0,0c-10.59,10.93-10.53,11.18,.15,.62q-10.66,10.82-.07,.02-10.59,10.81,.08,0c-10.5,11.16-10.39,11.51,.29,.86-10.54,11.01-10.6,10.61-.05-.86q-10.51,10.81,.11,0c-10.48,10.91-10.43,11.02,.12,.25-10.5,10.87-10.53,10.76-.06-.25-10.42,10.81-10.34,10.8,.21-.01-10.36,11.24-10.22,11.67,.34,1.05-10.83,11.37-11.25,11.73-1.04,.89-10.62,11.24-9.92,10.83,1.59-.64-10.21,11.22-10.16,11.35,.13,.3-10.79,11.63-11.16,11.84-.75,.55-9.94,11.17-9.49,11.01,1.1-.38-10.09,11.35-10.02,11.48,.17,.34-10.63,11.57-10.95,11.7-.67,.34-9.94,11.31-9.63,11.26,.78-.14-10,11.5-9.89,11.68,.27,.43-10.68,12.01-11.11,12.29-.87,.71-9.78,11.42-9.36,11.24,1.05-.44-9.84,11.7-9.67,11.92,.41,.53-9.91,11.6-10.04,11.33-.24-.61-9.76,11.36-9.56,11.25,.48-.27-9.89,11.66-9.92,11.92-.07,.64-10.03,11.77-10.18,11.99-.37,.57-9.95,11.67-9.8,11.52,.35-.31-9.91,12.49-9.85,13.41,.17,2.26-9.84,12.11-9.79,11.05,.45-2.15-9.58,11.43-9.45,11.23,.34-.48-9.58,11.55-9.5,11.58,.19,.06q-9.62,11.53,0,0c-9.6,11.63-9.58,11.72,.06,.23-9.36,12.4-8.95,13.2,.99,1.94-10.43,12.28-11.11,12.3-1.41,.23-9.22,12.17-8.75,12.24,1.16,.17-9.95,12.85-10.39,13.69-1.06,2.07-9.68,12.56-8.96,11.51,1.83-1.85-9.13,12.31-8.97,12.47,.38,.39-9.12,12.39-9.05,12.54,.17,.37-10.02,12.74-10.61,12.88-1.2,.46-8.83,12.43-8.26,12.39,1.38-.11q-9.11,12.4,.01,.02-9.1,12.4,0-.02c-8.94,12.37-8.77,12.34,.4-.08-8.95,12.43-8.88,12.49,.16,.13-8.98,12.41-9.03,12.35-.11-.14-8.58,12.28-8.17,12.16,.99-.31-8.77,12.51-8.76,12.71,.04,.49-8.97,12.6-9.1,12.7-.26,.23-8.72,12.42-8.61,12.36,.27-.13-8.62,13.59-8.28,14.78,.82,2.87-8.59,13.08-8.73,12.31-.1-1.66-8.54,12.95-8.45,13.2,.21,.6-8.56,12.84-8.69,11.96,.04-1.83-8.34,12.9-8.08,13.36,.63,1.12-8.41,12.68-8.67,11.98-.33-1.54-8.31,12.34-8.13,12.34,.44,0-8.3,12.76-8.18,13.18,.3,1.01-8.19,12.89-8.03,13.21,.39,.79-8.71,13.31-9.14,13.95-1.03,1.55-8.46,13.09-8.1,12.67,.89-.79-8.38,13.48-8.44,14.08-.15,1.46-8.3,13.23-8.11,12.43,.67-1.6-7.83,13.31-7.48,13.73,.88,1.02-8.1,13.43-8.24,13.78-.33,.85-8.03,13.29-7.82,12.97,.51-.67-7.83,13.22-7.74,13.29,.21,.18-7.85,13.96-7.74,14.75,.26,1.93-7.79,14.01-7.76,14.42,.09,1-7.79,13.84-7.69,12.74,.58-2.24-7.48,13.46-7.3,13.57,.44,.29-7.56,13.4-7.75,13.22-.38-.44-7.61,13.21-7.57,13.1,.11-.26-7.3,13.77-6.92,14.28,.92,1.24-7.42,13.52-7.85,12.68-.63-1.89-7.48,12.92-7.39,12.73,.22-.46-7.2,12.97-6.8,12.95,.98-.04-7.21,13.68-7.03,14.38,.44,1.71-7.71,13.89-8.05,14.16-.7,.64-7.01,13.37-6.68,13.22,.81-.39-7,13.81-6.81,14.19,.48,.92-7.07,13.63-7.22,13.15-.21-1.07-6.87,13.26-6.63,13.11,.58-.36-7.26,14.14-7.4,15.03-.35,2.18-7.14,14.24-7.2,14.68-.14,1.1-7.09,14.04-7.03,13.84,.16-.43-7.03,14.23-7.01,14.52,.07,.71-7.04,14.11-6.96,13.26,.43-1.72-6.79,13.45-6.61,13.17,.44-.71-6.68,13.32-6.49,13.07,.45-.62-6.63,13.58-6.51,13.72,.29,.36-7.03,14.11-7.31,14.78-.68,1.65-6.83,13.87-6.48,13.23,.93-1.2-6.54,13.9-6.44,14.19,.24,.71q-6.59,13.79-.06,.07c-7.02,13.84-7.27,13.84-.56,.05-6.53,13.83-6.35,13.87,.44,.09-6.71,13.93-6.77,13.98-.13,.14-6.56,13.79-6.48,13.74,.2-.13-6.51,13.83-6.42,13.85,.22,.04-6.23,14.58-5.79,15.31,1.04,1.79-6.43,14.78-6.51,15.37-.19,1.44-6.36,14.54-6.2,14.01,.46-1.1-5.97,14.64-5.67,14.98,.75,.82-6.09,14.48-6.18,14.33-.19-.34-6.05,14.18-5.79,13.45,.75-1.58-5.87,14.26-5.77,14.46,.25,.5-5.95,14.23-6,14.29-.12,.16-5.93,14.2-5.87,14.14,.14-.12-5.22,15.39-4.24,16.53,2.37,2.76-5.38,14.78-6.29,13.6-1.36-2.74-5.75,13.98-5.82,13.78-.16-.5-5.34,14.6-4.92,15.11,1.04,1.27-5.46,14.48-5.44,14.62,.06,.33q-5.47,14.42,0-.05c-5.47,14.62-5.45,14.83,.03,.52-5.46,14.53-5.4,14.08,.25-.93-4.95,14.89-4.4,15.42,1.32,1.26-5.12,14.6-5.32,14.34-.41-.62-4.93,14.7-4.62,14.94,.74,.57-5.12,14.67-5.18,14.71-.11,.1-5.01,14.58-4.94,14.54,.15-.08-4.67,14.83-4.29,15.04,.94,.53-4.85,14.77-4.89,14.82-.07,.15-4.84,14.74-4.79,14.68,.11-.13q-4.82,14.71,.02,.01c-4.85,14.81-4.89,14.89-.1,.22-4.83,14.76-4.77,14.67,.15-.19-4.64,14.79-4.48,14.86,.39,.16-4.88,15.77-4.93,16.85-.1,2.64-4.74,15.34-4.52,13.84,1-2.92-4.34,14.32-4.12,13.93,.5-.95-4.31,14.56-4.21,14.63,.24,.18-4.16,14.65-3.94,14.77,.5,.29-4.8,14.94-5.16,15.09-.76,.41-3.94,14.6-3.5,14.5,1.1-.25q-4.16,14.63,.02,0c-4.29,15.08-4.38,15.55-.22,1.16-4.73,15.89-5.16,16.41-.78,1.25-4.06,14.92-3.76,14.66,.74-.62-4.22,15.64-4.18,16.28,.12,1.56-4.19,15.37-4.11,14.21,.61-2.31-3.81,14.58-3.58,14.29,.56-.7-3.7,14.75-3.45,14.79,.59,.1-3.49,15.64-3,16.55,1.19,2.19-3.53,15.21-3.69,14.86-.26-.79-3.09,14.8-2.62,14.53,1.14-.66-3.25,15.03-3.16,15.18,.22,.36-3.35,15.04-3.4,15.09-.09,.11q-3.26,14.96,.11-.08c-3.08,15.28-2.85,15.59,.56,.75-3.24,15.78-3.28,16.44-.07,1.64-3.18,15.5-3.06,14.89,.4-1.27-2.75,15.58-2.39,15.91,.9,.83-2.89,15.41-3.29,14.88-.71-1.22-2.53,15.48-1.98,15.79,1.37,.75-2.74,15.3-3.38,14.82-1.17-1.23-2.95,14.93-2.9,14.83,.12-.25-2.85,14.73-2.7,14.48,.35-.62-2.7,15.36-2.46,15.87,.59,1.27-2.76,15.12-2.97,14.39-.24-1.6-2.61,14.76-2.41,14.76,.49,0-2.66,15-2.6,15.23,.15,.58-2.89,15.38-3.06,15.9-.43,1.29-2.77,15.18-2.55,14.74,.57-.86-2.57,15.2-2.48,15.41,.21,.53q-2.64,15.12-.05,.02-2.59,15.11,.06-.01c-2.33,15.7-2.02,16.28,.78,1.43-2.42,15.42-2.67,14.74-.33-1.52-1.95,14.96-1.42,14.79,1.28-.41-2.21,16.6-2.46,17.59-.21,2.12-1.73,14.47-1.37,13.45,.89-2.46-1.78,14.76-1.51,14.59,.66-.41-1.69,15.15-1.48,15.48,.53,.82-2.61,15.54-3.17,15.74-1.13,.6-1.47,15.08-.93,14.98,1.33-.26-1.64,15.26-1.53,15.44,.26,.44-1.54,16.03-1.28,16.87,.64,2.07-1.73,16.01-1.85,16.21-.25,.46-1.46,15.62-1.34,15.49,.32-.32q-1.52,15.7,.03,.06-1.52,15.69-.01,.01-1.53,15.69,.02-.01c-1.28,16.2-.98,16.71,.72,1.24-1.36,15.96-1.61,15.3-.35-1.48-1.32,15.55-1.19,15.47,.3-.2-1.36,15.7-1.36,15.8,.03,.27-1.37,15.65-1.35,15.55,.04-.23-1.15,16.16-.9,16.73,.63,1.36-1.22,15.9-1.46,15.12-.24-1.75-1.01,15.3-.76,15.08,.62-.54-.79,16.08-.37,16.75,1.05,1.64-.9,15.76-1.23,15.04-.49-1.61q-.99,15.42,.06,.05c-1,15.41-1.03,15.36-.06-.09-1.05,15.21-1.09,15.02-.09-.47-.91,15.15-.8,15.01,.29-.34-.52,15.19-.06,15.12,1.13-.16-.32,15.9-.15,16.37,.46,.98-.65,14.95-.72,14.52-.16-1.06-.6,15.14-.56,15.14,.11-.03-.62,15.15-.68,15.15-.12,0-.67,15.04-.69,14.94-.05-.26-.41,15.17-.15,15.24,.63,.16-.75,16.55-1.17,17.38-.53,1.84-.36,15.2-.1,14.85,.62-.86-.6,16.25-.61,17.2,.01,2.33-.5,15.86-.38,14.67,.67-2.36,.45,16.48,1.55,17.5,2.67,2.45,.4,16.16,.56,16.43,.41,.67,.33,16.03-.07,15-.45-2.25,.29,15.34,.36,15.12,.18-.56,.49,15.7,.73,15.99,.59,.7,.41,15.56,.13,15.09-.44-1.09,.39,15.12,.48,14.92,.22-.51q.36,15.22,.01,.03c.29,15.35,.25,15.43-.09,.18,.39,15.2,.43,15.15,.11-.12q.36,15.24,.01,.03c.52,15.58,.72,15.91,.47,.82,.26,15.59,.13,15.68-.27,.22,.55,15.41,.68,15.36,.33-.13,.63,15.65,.8,15.88,.4,.53,.61,15.64,.65,15.74,.1,.22,.59,15.6,.58,15.53-.03-.15,1.35,16.43,2.33,17.18,2.37,1.8,1.11,15.97,.52,15.45-1.08-1.26,.84,15.17,.82,14.24,.09-2.17q.93,15.18,.08-.06c1.06,15.41,1.21,15.62,.39,.52,.86,16.72,.57,17.56-.35,1.84,1.28,15.15,1.59,14.57,.75-1.41,1.54,15.84,2.05,16.26,1.26,.99,1.37,15.62,.75,14.98-1.04-1.55,1.21,15.07,1.28,14.87,.16-.5,1.48,15.68,1.84,16.19,.88,1.23,1.35,15.54,1.33,15.61-.03,.13,1.39,15.43,1.4,15.39,.06-.11,1.42,15.51,1.46,15.56,.11,.13,1.4,15.48,1.36,15.4-.08-.18,1.57,15.08,1.74,14.72,.42-.89,1.59,15.53,1.72,15.8,.33,.69,1.5,15.54,1.46,15.61-.07,.18,1.57,15.38,1.6,15.33,.09-.13,1.97,16.19,2.51,16.95,1.32,1.82,1.84,15.81,1.32,14.87-.75-2.12,1.75,15.37,1.81,15.41,.16,.08,1.71,15.35,1.63,15.28-.18-.16,1.65,15.2,1.62,15.09-.06-.28,1.77,15.21,1.89,15.16,.27-.12,2.14,15.51,2.59,15.77,1.1,.62,1.99,15.55,2.01,15.72,.06,.43,1.98,15.46,1.99,15.29,.04-.39,2.66,15.68,3.38,15.91,1.76,.55,2.38,15.5,1.53,15.08-1.64-1.17,2.03,15.13,2.06,15.03,.07-.27,2.27,15.24,2.52,15.29,.61,.12,2.16,15.21,1.9,15.09-.56-.31,2.1,14.94,2.16,14.73,.15-.51,2.4,15.49,2.77,15.93,.93,1.09,2.28,15.27,1.9,14.65-.61-1.41q2.14,14.95,0,0c2.62,15.49,3.19,15.97,1.39,1.17,2.41,15.33,2.39,15.42-.06,.17,2.48,15.19,2.52,15.13,.09-.15,2.95,15.52,3.48,15.77,1.31,.63,2.75,15.36,2.46,15.15-.6-.51,2.64,15.16,2.67,15.02,.08-.31,2.79,15.47,2.88,15.65,.2,.39,2.63,15.02,2.58,14.78-.13-.59,2.68,15.04,2.71,14.94,.08-.25,2.7,15.14,2.74,15.2,.08,.15,2.62,15.22,2.57,15.29-.1,.15,2.72,15.1,2.76,15.05,.12-.11,2.76,15.22,2.83,15.33,.17,.26,2.59,15.44,2.5,15.58-.19,.33,2.79,15.15,2.88,15.05,.24-.25,3,15.57,3.26,15.94,.67,.9q2.89,15.43,.01,.08,2.89,15.41,0-.06,2.9,15.41,.02,.03c2.9,15.41,2.88,15.36-.02-.04,2.92,15.18,3.01,14.55,.31-1.41,3.6,15.2,4.25,15.25,1.61,.14,3.47,15.36,3.63,15.59,.39,.58,2.73,16.1,2.2,16.53-.99,1.05,3.73,15.22,4.24,14.93,1.24-.71,3.8,15.72,4.15,16.12,.89,.96,3.67,15.53,3.34,15.02-.58-1.18,3.63,15.2,3.71,15.14,.22-.16,3.8,15.34,4.02,15.45,.54,.26,3.7,15.29,3.51,15.13-.4-.38,3.87,14.99,4.11,14.77,.59-.55,3.95,15.17,4.17,15.25,.52,.2,3.9,15.3,3.95,15.47,.11,.42,3.89,15.22,3.89,15.05,0-.38,3.94,15.15,3.98,15.17,.12,.04,3.99,15.27,4.07,15.4,.19,.32,3.96,15.22,3.92,15.09-.08-.28,5.3,15.56,6.82,15.69,3.67,.3,4.76,15.22,3.65,15.06-2.21-.71,4.43,15.08,4.6,15.11,.41,.05,4.36,15.07,3.4,14.74-1.87-1.04,4.1,14.59,4.26,14.32,.37-.65,4.15,14.44,4.26,14.16,.28-.67,4.31,14.47,4.52,14.38,.53-.22,4.23,14.61,4.26,14.71,.07,.26,4.22,14.56,4.22,14.43,0-.29q4.22,14.49,.01,0c4.22,14.49,4.27,14.54,.06,.06q4.23,14.51-.04-.07c4.49,14.36,4.75,14.22,.63-.35,4.81,15.46,5.56,16.41,1.79,2.28,4.78,15.08,4.78,15.17,.02,.2,4.78,14.9,4.79,14.83,.03-.17,5.05,15.15,5.36,15.36,.74,.51,4.94,15.04,4.57,14.68-.68-.88,4.84,14.47,4.88,14.1,.1-.92,5.08,14.8,5.36,14.94,.69,.35,5.16,15.23,5.23,15.54,.22,.67,5.01,14.63,5,14.39-.02-.58,5.55,14.97,6.13,15.15,1.41,.44,5.32,14.84,4.55,14.44-1.48-1.09,4.96,14.32,4.91,14.07-.11-.64,5.7,14.62,6.49,14.68,1.92,.15,5.82,15.69,5.91,16.48,.43,1.63,5.58,14.14,5.59,13.46,.06-1.68,5.66,14.46,5.81,14.44,.39-.05,5.59,14.47,5.41,14.45-.4-.06,5.48,14.29,5.47,14.14-.03-.38,6.92,15.39,8.69,16.1,4.26,1.69,6.44,14.74,5.18,14.2-2.38-1.57,6,14.43,6.08,14.46,.21,.08,6.1,14.55,6.24,14.68,.35,.33,6.03,14.48,5.98,14.41-.11-.18,6.58,14.84,7.21,15.19,1.55,.86,6.35,14.64,5.96,14.33-.78-.75q6.21,14.47,.07,.02c6.2,14.47,6.14,14.44-.11-.05,5.79,14.04,5.33,13.48-1.07-1.38q5.93,14.14-.02-.04c6.04,14.08,6.16,14.02,.29-.15,6.48,14.35,6.99,14.54,1.26,.47,6.91,14.68,7.63,15.09,1.76,.97,6.66,14.43,6.23,14.12-.85-.78,7.69,14.42,9,14.37,3.16-.15,7.18,14.22,5.7,14.17-2.95-.75,6.05,13.87,5.55,13.64-1.23-.56,6.35,13.86,6.44,13.76,.24-.21,6.4,14.07,6.51,14.24,.27,.43,6.36,13.98,6.27,13.75-.15-.54,6.4,13.8,6.46,13.74,.16-.15,6.82,14.23,7.1,14.54,.7,.69,6.53,14.09,6.55,14.16,.02,.15q6.52,13.97,.01-.11,6.53,13.99,.03,.03,6.53,14-.03-.05c6.61,13.29,6.63,12.62,.06-1.66q6.57,13.58,.07-.09c6.67,13.43,6.77,13.24,.26-.44,7.61,14.27,8.9,14.79,3.08,1.2,7.3,13.77,6.65,13.52-1.27-.72,7.38,13.83,7.76,14.05,.93,.53,7.22,13.72,6.77,13.34-.89-.93,7.4,13.57,7.78,13.59,.93,.05,7.81,13.92,8.45,14.26,1.58,.82,7.59,13.71,7.08,13.36-.96-.87,7.69,13.47,8.02,13.41,.8-.15,7.76,13.65,7.99,13.82,.54,.41,7.67,13.72,7.67,13.8,0,.19,7.68,13.55,7.7,13.49,.03-.16,7.88,13.71,8.07,13.85,.49,.32,7.79,13.65,7.57,13.43-.44-.53,7.8,13,7.89,12.47,.21-1.3,8.16,13.62,8.63,13.97,1.16,.85,7.99,13.43,7.35,12.79-1.11-1.55,7.75,12.9,7.75,12.7,0-.47,8.33,13.16,8.95,13.26,1.51,.25,8.26,13.31,8.45,13.58,.48,.66,8.19,13.19,8.06,12.9-.24-.65,8.55,13.05,8.98,13.04,1.05-.04,8.37,13.03,7.82,12.95-1.16-.33,8.06,12.78,8.02,12.58-.11-.49,8.64,12.97,9.22,13.02,1.41,.12,8.4,12.88,7.96,12.78-.91-.34,8.67,12.12,9.06,11.41,.95-1.72,8.46,12.36,8.51,12.29,.12-.16,9.6,13.36,10.16,14.13,1.41,1.42,8.53,12.12,8.25,11.57-.67-1.35,8.94,12.48,9.29,12.54,.85,.14,9.35,12.72,9.96,12.92,1.49,.52,9.29,12.76,9.46,12.98,.43,.52,9.22,12.66,9.11,12.46-.22-.48,9.48,12.61,9.79,12.66,.78,.1,9.34,12.58,8.9,12.43-.9-.44,9.11,12.39,9.08,12.3-.08-.23,9.6,12.38,10.1,12.29,1.19-.22,9.39,12.38,8.77,12.37-1.31-.19,9.05,12.18,9,12-.11-.43,9.26,12.25,9.46,12.23,.48-.02,9.18,12.24,8.95,12.2-.51-.13,9.04,12.08,9,11.95-.07-.33q9.04,12.1-.02-.09c9.1,12.18,9.15,12.24,.13,.15,9.07,12.15,9.04,12.08-.08-.15,9.26,12.25,9.45,12.38,.49,.32,9.19,12.27,9.2,12.32,.03,.11q9.17,12.18,0-.09c9.57,12.42,9.99,12.63,1.02,.51,9.58,12.49,9.76,12.67,.45,.44,9.5,12.4,9.4,12.27-.19-.33,9.85,12.5,10.25,12.65,1,.37,9.68,12.41,9.01,12-1.32-1.05,9.29,11.96,9.2,11.71-.23-.61,9.68,11.37,9.94,10.68,.64-1.67,9.58,11.79,9.68,11.91,.25,.29,9.54,11.74,9.43,11.54-.21-.45,9.52,11.52,9.54,11.41,.06-.28,9.94,11.51,10.37,11.41,1.07-.25,11.42,13.03,12.16,14.31,1.98,2.28,9.9,11.02,9.5,10.09-.95-2.28,10.52,11.83,11.12,12.11,1.45,.68,10.29,11.67,9.63,11.21-1.28-1.18,10.58,11.11,11.14,10.75,1.37-.88,10.37,11.86,10.36,12.25,.04,.85,10.42,11.01,10.5,10.63,.2-.94,10.82,11.34,11.3,11.46,1.17,.28,10.63,11.25,10.08,11.02-1.11-.67,10.42,10.81,10.45,10.53,.07-.71,10.54,10.95,10.68,10.95,.35,0,10.47,10.95,10.32,10.91-.34-.09,10.42,10.41,10.41,9.89-.02-1.26,10.66,10.64,10.93,10.61,.67-.06q10.54,10.63,.01,0c11.26,11.58,11.56,12.25,.84,1.33,10.61,10.32,10.44,9.74-.4-1.42,11.02,10.52,11.4,10.39,.93-.31,11.31,11.16,11.87,11.75,1.36,1.43,11.15,10.86,10.63,10.14-.86-1.66q10.99,10.48,.08-.04,11,10.51,.07,.08,10.99,10.5-.05-.09c11.17,10.38,11.36,10.27,.47-.27,11.23,10.53,11.38,10.65,.36,.27,11.16,10.48,11.03,10.34-.26-.34q11.15,10.38,.12-.08c11.13,10.39,11.07,10.41-.15,.05,11.01,10.26,10.9,10.11-.26-.39,11.37,10.12,11.7,9.9,.8-.53,11.22,10.19,10.8,10.37-.94,.28,10.89,10.05,10.76,9.81-.31-.58q10.96,10.09,.04-.09c11.28,10.4,11.46,10.59,.41,.4,10.91,9.95,10.76,9.7-.35-.6,11.04,9.85,11.1,9.64,.16-.53,11.48,9.78,11.95,9.57,1.16-.52,11.81,10.36,12.43,10.85,1.54,1.18,11.6,10.09,11,9.48-1.07-1.47,11.67,9.57,11.97,9.35,.74-.54,11.64,9.67,11.76,9.68,.29,.05,11.88,10.22,12,10.57,.33,.75,11.64,9.53,11.6,9.25-.1-.71,12.18,9.73,12.74,9.75,1.35,.05,11.94,9.68,11.26,9.53-1.41-.53,12.41,9.73,12.84,9.92,.99,.29,11.4,9.27,10.92,8.97-1.14-.75,11.53,9.2,11.45,8.95-.19-.62,12.49,9.86,13.55,10.26,2.61,.95,12.13,9.53,10.97,9-2.13-1.55,11.48,9.02,11.3,8.83-.45-.45,12.2,9.01,12.86,8.83,1.59-.44,12.73,9.03,13.59,8.95,2.09-.2,12.9,9.55,13.15,9.97,.63,.83,12.41,8.78,12.28,8.45-.3-.83,12.73,9.02,13.01,9.08,.7,.15,12.61,8.98,12.36,8.87-.53-.29q12.5,8.92,.03,0,12.5,8.92-.04,0c12.37,8.85,12.25,8.77-.31-.19,12.38,8.79,12.34,8.71-.1-.2,12.6,8.89,12.82,8.95,.52,.14,12.51,8.86,12.18,8.7-.68-.44,12.12,8.32,11.86,7.91-.65-1.02,12.3,8.52,12.38,8.49,.2-.06q12.32,8.57,.07,.06,12.26,8.51-.05-.07c12.98,8.32,13.69,8.04,1.75-.69,12.66,8.37,11.65,8.6-2.16,.12q12.18,8.4-.01-.02c12.26,8.27,12.34,8.14,.2-.31,12.41,8.41,12.59,8.5,.47,.2,12.32,8.37,12.13,8.23-.4-.33,12.42,7.96,12.58,7.61,.38-.86q12.34,8.1,.06-.01c12.67,8.34,13.03,8.56,.89,.54,12.53,8.22,12.09,7.83-.82-.95,12.39,7.82,12.44,7.62,.11-.48,12.58,7.82,12.8,7.72,.52-.25,12.95,8.03,13.45,8.18,1.21,.36,12.76,7.93,12.32,7.71-.87-.57,12.65,7.75,12.73,7.71,.2-.12,12.74,7.86,12.88,7.93,.34,.19,12.68,7.82,12.56,7.72-.26-.25q12.67,7.73,.12-.08c12.78,7.98,12.84,8.12,.16,.31,12.66,7.66,12.62,7.51-.08-.37,13.29,7.28,13.88,6.73,1.44-1.35,13.15,7.52,13.23,7.58,.2,.12,12.97,7.39,12.9,7.32-.16-.17,13.09,7.31,13.19,7.19,.24-.29,13.32,7.46,13.48,7.54,.35,.15,13.01,7.29,12.89,7.2-.3-.23q13.08,7.31,.06-.08c13.62,7.32,14.18,7.25,1.36-.16,13.38,7.29,12.86,7.26-1.1-.2,13.27,7.04,13.4,6.82,.32-.53,14.08,7.65,14.53,8.07,1.09,.77,13.1,6.78,12.73,6.31-.9-1.16,13.31,6.95,13.37,6.85,.16-.24,13.48,6.91,13.69,6.83,.5-.21,13.39,6.94,13.02,7-.81,.07,13.27,6.93,13.33,6.9,.15-.08,13.83,6.61,14.37,6.19,1.33-1.02,13.74,6.63,13.93,6.56,.48-.2,13.65,6.67,13.5,6.69-.31,.04,13.73,6.51,13.89,6.34,.38-.43,14,6.52,14.35,6.44,.85-.19,13.85,6.54,13.55,6.54-.67-.04,14.17,5.91,14.59,5.2,1.02-1.72q13.95,6.14,.04-.02,13.94,6.14-.04,0c14.01,5.99,14.09,5.82,.19-.41,13.97,6.05,13.81,6.27-.38,.44,13.41,6.21,12.35,6.29-2.44-.05,13.22,6.13,13.08,6.1-.33-.05q13.27,6.11,.01-.06c13.9,6.14,14.26,6.22,.81,.09,13.25,6.03,13.04,5.94-.5-.23,13.64,5.98,13.94,5.86,.73-.31,13.51,6.01,13.07,6.1-.96,.08q13.29,6.03,0-.02c13.35,5.94,13.39,5.86,.11-.21,13.65,5.97,13.98,5.94,.82-.07,13.5,5.96,13.17,5.93-.71-.15,13.38,5.87,13.41,5.8,.08-.16,13.56,5.98,13.77,6.06,.52,.19q13.45,6-.03,.08,13.49,5.93,.05-.08c14.17,6.17,14.92,6.33,1.82,.37,13.88,6.02,13.51,5.89-.77-.36,13.82,5.94,13.94,5.95,.27,0,13.77,5.94,13.43,5.86-.72-.26,13.49,5.81,13.36,5.73-.31-.2,13.99,5.06,14.32,4.26,.81-1.94,13.8,5.44,13.87,5.49,.19,.1,13.76,5.43,13.68,5.36-.18-.16,13.75,5.29,13.78,5.17,.07-.27,13.92,5.47,14.09,5.61,.45,.33,13.84,5.41,13.63,5.19-.41-.54,13.79,5.04,13.82,4.79,.08-.6,13.85,4.95,13.93,4.75,.2-.51,14.07,5.03,14.29,5.04,.56,0,14.18,5.69,14.27,6.09,.28,.86,14,4.89,13.99,4.54-.02-.85,14.22,5.06,14.36,5.08,.3,.03,13.93,5,13.8,4.96-.31-.12q13.99,4.98-.01-.11c14.6,5.11,15.24,5.16,1.58,.14,14.33,5.03,13.52,4.82-1.63-.68q13.97,4.88,0-.02,13.97,4.88,0,0c13.93,4.6,13.87,4.33-.12-.67,14.11,4.73,14.28,4.73,.41-.01,14.04,4.73,13.83,4.68-.44-.12q13.93,4.66-.02-.08c14,4.61,14.06,4.53,.16-.19,14.69,4.99,15.08,5.3,.91,.54,13.94,4.47,13.7,4.2-.59-.67,14.1,4.6,14.16,4.59,.15-.03,14.07,4.61,13.99,4.61-.2-.01q13.99,4.58-.08-.08c14.07,4.5,14.13,4.41,.15-.21,14.46,4.84,14.67,5.05,.52,.41,14.06,4.47,13.95,4.33-.26-.37,14.53,4.65,14.96,4.72,1.07,.17,14.34,4.59,13.8,4.39-1.09-.57,14.29,4.16,14.47,3.84,.44-.78,14.26,4.36,14.32,4.43,.16,.17,14.23,4.33,14.17,4.22-.13-.23,14.23,4.22,14.25,4.17,.07-.13,15.44,4.57,16.78,4.68,3.26,.25,14.94,4.3,13.47,4.07-2.87-1.09,14.14,3.97,13.97,3.86-.41-.23,14.53,3.92,14.85,3.81,.78-.27,14.41,4.03,14.43,4.09,.03,.12,14.39,3.91,14.39,3.86,0-.13,14.63,3.83,14.87,3.73,.59-.29,14.52,3.88,14.26,3.95-.59,.09,14.39,3.4,14.34,2.91-.1-1.2,15.06,3.38,15.75,3.01,1.68-.92,14.74,3.43,13.92,3.78-1.78,.37q14.34,3.48-.02-.08,14.36,3.47,.05-.05,14.35,3.48,0,0c14.67,3.17,14.96,2.83,.72-.85,14.72,3.19,14.93,3.1,.5-.26,14.62,3.24,14.46,3.28-.37,.08,15.11,2.41,15.58,1.42,1.12-2.41,14.79,2.72,14.22,3.72-1.51,1.8,14.3,3.08,14.1,3.02-.47-.15q14.35,3.09,0-.02c14.58,3.11,14.8,3.15,.56,.07,14.48,3.1,14.22,3-.55-.25,14.35,2.9,14.35,2.76,0-.34,14.51,2.89,14.67,2.81,.38-.2,16.2,1.87,17.64,.02,3.34-4.31,15.18,1.96,14.37,3.17-2.1,2.07,14.52,2.57,14.31,2.72-.51,.37,14.34,2.06,14.06,1.66-.7-1,15.49,1.66,16.49,.78,2.38-2.12,14.97,1.81,13.95,2.6-2.37,1.18,14.78,1.7,15.07,1.29,.73-1.01q14.64,1.88,.04,.04,14.61,1.84-.03-.06c14.81,1.51,15,1.15,.45-.88q14.74,1.67,.06,.05,14.73,1.66-.06-.07c14.76,1.53,14.81,1.42,.12-.28,14.84,1.53,14.93,1.48,.23-.13,15.32,1.32,15.85,1.03,1.28-.72,15.08,1.4,14.93,1.45-.34,.11,15.38,1.14,15.75,.83,.91-.76,15.2,1.25,14.21,1.82-2.2,.79,14.71,1.43,14.65,1.56-.05,.11Z");
    // bytes memory a = bytes(abi.encodePacked("M189.63,130.1c14.75,1.35,14.81,1.25,.12-.25"));
    bytes memory pack;
    bytes memory a = bytes(abi.encodePacked("5"));
    // pack = abi.encodePacked(pack, '  <path d="', a, '"', 'red',' />\n');
    // return string(pack);
    return a;
  }

  function getAge(uint256 tokenId) external view returns (uint256) {
    require(_exists(tokenId), "nonexistent token");
    return block.timestamp - _generatedAt[tokenId];
  }

  function getElapsedTimeFromLastWaterChanged(uint256 tokenId) public view returns (uint256) {
    require(_exists(tokenId), "nonexistent token");
    return block.timestamp - _lastWaterChangedAt[tokenId];
  }

  function getLastSize(uint256 tokenId) internal view returns (uint16) {
    require(_exists(tokenId), "nonexistent token");
    return _lastSize[tokenId] > 0 ? _lastSize[tokenId] : 250;
  }

  function getCurrentSize(uint256 tokenId) public view returns (uint16) {
    require(_exists(tokenId), "nonexistent token");
    uint256 elapsedMinutes = getElapsedTimeFromLastWaterChanged(tokenId) / 60;
    uint256 unitTime = 900;
    if (elapsedMinutes < 24 * 60 * 6) {
      return uint16((100 * elapsedMinutes) / unitTime / 100  + getLastSize(tokenId));
    } else if (elapsedMinutes <= 24 * 60 * 15) {
      return uint16((95 * elapsedMinutes + 432 * 100) / unitTime / 100 + getLastSize(tokenId));
    } else if (elapsedMinutes <= 24 * 60 * 24) {
      return uint16((50 * elapsedMinutes + 10152 * 100) / unitTime / 100 + getLastSize(tokenId));
    } else if (elapsedMinutes <= 24 * 60 * 30) {
      return uint16((10 * elapsedMinutes + 23976 * 100) / unitTime / 100 + getLastSize(tokenId));
    } else {
      return uint16(getLastSize(tokenId) + (28296 / unitTime));
    }
  }

  function changeWater(uint256 tokenId) external {
    require(_exists(tokenId), "nonexistent token");
    require(block.timestamp - _lastWaterChangedAt[tokenId] > 1 days, "changeWater can only be called once a day");
    _lastSize[tokenId] = getCurrentSize(tokenId); // update lastSize before update lastWaterChangedAt
    _lastWaterChangedAt[tokenId] = block.timestamp;
  }

  function publicMint(uint256 quantity) external returns (uint256) {
    require(totalSupply() + quantity <= collectionSize, "reached max supply");
    require(_numberMinted(msg.sender) + quantity <= maxPerAddressDuringMint, "can not mint this many");

    uint256 nextTokenId = _nextTokenId();
    for (uint256 i = nextTokenId; i < nextTokenId + quantity; i++) {
      _generatedAt[i] = block.timestamp;
      _lastWaterChangedAt[i] = block.timestamp;
      tokenStats[i] = _computeStats(i);
      emit ChangedStats(i);
    }
    _mint(msg.sender, quantity);
    return nextTokenId;
  }

  function _startTokenId() internal pure override returns (uint256) {
    return 1;
  }

  function withdraw() public onlyOwner {
    payable(owner()).transfer(address(this).balance);
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return baseURI;
  }

  function setBaseURI(string memory _newBaseURI) public onlyOwner {
    baseURI = _newBaseURI;
  }

  function _computeStats(uint256 tokenId) internal view returns (Stats memory) {
    uint256 pseudorandomness = uint256(
        keccak256(abi.encodePacked(blockhash(block.number - 1), tokenId))
    );

    uint8 power   = uint8(pseudorandomness) % 8 + 1;
    uint8 speed   = uint8(pseudorandomness >> 8 * 1) % 8 + 1;
    uint8 stamina = uint8(pseudorandomness >> 8 * 2) % 8 + 1;
    uint8 luck    = uint8(pseudorandomness >> 8 * 3) % 8 + 1;
    return Stats(power, speed, stamina, luck);
  }

  mapping(uint256 => bytes) private parts;
  function registerPart(uint256 tokenId, bytes memory _part) external onlyOwner{
    parts[tokenId] = _part;
  }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)

pragma solidity ^0.8.0;

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 */
library Counters {
    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }

    function decrement(Counter storage counter) internal {
        uint256 value = counter._value;
        require(value > 0, "Counter: decrement overflow");
        unchecked {
            counter._value = value - 1;
        }
    }

    function reset(Counter storage counter) internal {
        counter._value = 0;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)

pragma solidity ^0.8.0;

import "./IERC721.sol";
import "./IERC721Receiver.sol";
import "./extensions/IERC721Metadata.sol";
import "../../utils/Address.sol";
import "../../utils/Context.sol";
import "../../utils/Strings.sol";
import "../../utils/introspection/ERC165.sol";

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[owner];
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: invalid token ID");
        return owner;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        _requireMinted(tokenId);

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not token owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        _requireMinted(tokenId);

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
        _safeTransfer(from, to, tokenId, data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits an {Approval} event.
     */
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Reverts if the `tokenId` has not been minted yet.
     */
    function _requireMinted(uint256 tokenId) internal view virtual {
        require(_exists(tokenId), "ERC721: invalid token ID");
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    /// @solidity memory-safe-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
// ERC721A Contracts v4.2.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import './IERC721A.sol';

/**
 * @dev Interface of ERC721 token receiver.
 */
interface ERC721A__IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

/**
 * @title ERC721A
 *
 * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)
 * Non-Fungible Token Standard, including the Metadata extension.
 * Optimized for lower gas during batch mints.
 *
 * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)
 * starting from `_startTokenId()`.
 *
 * Assumptions:
 *
 * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).
 */
contract ERC721A is IERC721A {
    // Reference type for token approval.
    struct TokenApprovalRef {
        address value;
    }

    // =============================================================
    //                           CONSTANTS
    // =============================================================

    // Mask of an entry in packed address data.
    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;

    // The bit position of `numberMinted` in packed address data.
    uint256 private constant _BITPOS_NUMBER_MINTED = 64;

    // The bit position of `numberBurned` in packed address data.
    uint256 private constant _BITPOS_NUMBER_BURNED = 128;

    // The bit position of `aux` in packed address data.
    uint256 private constant _BITPOS_AUX = 192;

    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.
    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;

    // The bit position of `startTimestamp` in packed ownership.
    uint256 private constant _BITPOS_START_TIMESTAMP = 160;

    // The bit mask of the `burned` bit in packed ownership.
    uint256 private constant _BITMASK_BURNED = 1 << 224;

    // The bit position of the `nextInitialized` bit in packed ownership.
    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;

    // The bit mask of the `nextInitialized` bit in packed ownership.
    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;

    // The bit position of `extraData` in packed ownership.
    uint256 private constant _BITPOS_EXTRA_DATA = 232;

    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.
    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;

    // The mask of the lower 160 bits for addresses.
    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;

    // The maximum `quantity` that can be minted with {_mintERC2309}.
    // This limit is to prevent overflows on the address data entries.
    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}
    // is required to cause an overflow, which is unrealistic.
    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;

    // The `Transfer` event signature is given by:
    // `keccak256(bytes("Transfer(address,address,uint256)"))`.
    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =
        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;

    // =============================================================
    //                            STORAGE
    // =============================================================

    // The next token ID to be minted.
    uint256 private _currentIndex;

    // The number of tokens burned.
    uint256 private _burnCounter;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned.
    // See {_packedOwnershipOf} implementation for details.
    //
    // Bits Layout:
    // - [0..159]   `addr`
    // - [160..223] `startTimestamp`
    // - [224]      `burned`
    // - [225]      `nextInitialized`
    // - [232..255] `extraData`
    mapping(uint256 => uint256) private _packedOwnerships;

    // Mapping owner address to address data.
    //
    // Bits Layout:
    // - [0..63]    `balance`
    // - [64..127]  `numberMinted`
    // - [128..191] `numberBurned`
    // - [192..255] `aux`
    mapping(address => uint256) private _packedAddressData;

    // Mapping from token ID to approved address.
    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    // =============================================================
    //                          CONSTRUCTOR
    // =============================================================

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    // =============================================================
    //                   TOKEN COUNTING OPERATIONS
    // =============================================================

    /**
     * @dev Returns the starting token ID.
     * To change the starting token ID, please override this function.
     */
    function _startTokenId() internal view virtual returns (uint256) {
        return 0;
    }

    /**
     * @dev Returns the next token ID to be minted.
     */
    function _nextTokenId() internal view virtual returns (uint256) {
        return _currentIndex;
    }

    /**
     * @dev Returns the total number of tokens in existence.
     * Burned tokens will reduce the count.
     * To get the total number of tokens minted, please see {_totalMinted}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        // Counter underflow is impossible as _burnCounter cannot be incremented
        // more than `_currentIndex - _startTokenId()` times.
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    /**
     * @dev Returns the total amount of tokens minted in the contract.
     */
    function _totalMinted() internal view virtual returns (uint256) {
        // Counter underflow is impossible as `_currentIndex` does not decrement,
        // and it is initialized to `_startTokenId()`.
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    /**
     * @dev Returns the total number of tokens burned.
     */
    function _totalBurned() internal view virtual returns (uint256) {
        return _burnCounter;
    }

    // =============================================================
    //                    ADDRESS DATA OPERATIONS
    // =============================================================

    /**
     * @dev Returns the number of tokens in `owner`'s account.
     */
    function balanceOf(address owner) public view virtual override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;
    }

    /**
     * Returns the number of tokens minted by `owner`.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;
    }

    /**
     * Returns the number of tokens burned by or on behalf of `owner`.
     */
    function _numberBurned(address owner) internal view returns (uint256) {
        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;
    }

    /**
     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).
     */
    function _getAux(address owner) internal view returns (uint64) {
        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);
    }

    /**
     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).
     * If there are multiple variables, please pack them into a uint64.
     */
    function _setAux(address owner, uint64 aux) internal virtual {
        uint256 packed = _packedAddressData[owner];
        uint256 auxCasted;
        // Cast `aux` with assembly to avoid redundant masking.
        assembly {
            auxCasted := aux
        }
        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);
        _packedAddressData[owner] = packed;
    }

    // =============================================================
    //                            IERC165
    // =============================================================

    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30000 gas.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        // The interface IDs are constants representing the first 4 bytes
        // of the XOR of all function selectors in the interface.
        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)
        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)
        return
            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.
            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.
            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.
    }

    // =============================================================
    //                        IERC721Metadata
    // =============================================================

    /**
     * @dev Returns the token collection name.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, it can be overridden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return '';
    }

    // =============================================================
    //                     OWNERSHIPS OPERATIONS
    // =============================================================

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        return address(uint160(_packedOwnershipOf(tokenId)));
    }

    /**
     * @dev Gas spent here starts off proportional to the maximum mint batch size.
     * It gradually moves to O(1) as tokens get transferred around over time.
     */
    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {
        return _unpackedOwnership(_packedOwnershipOf(tokenId));
    }

    /**
     * @dev Returns the unpacked `TokenOwnership` struct at `index`.
     */
    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {
        return _unpackedOwnership(_packedOwnerships[index]);
    }

    /**
     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.
     */
    function _initializeOwnershipAt(uint256 index) internal virtual {
        if (_packedOwnerships[index] == 0) {
            _packedOwnerships[index] = _packedOwnershipOf(index);
        }
    }

    /**
     * Returns the packed ownership data of `tokenId`.
     */
    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr)
                if (curr < _currentIndex) {
                    uint256 packed = _packedOwnerships[curr];
                    // If not burned.
                    if (packed & _BITMASK_BURNED == 0) {
                        // Invariant:
                        // There will always be an initialized ownership slot
                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)
                        // before an unintialized ownership slot
                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)
                        // Hence, `curr` will not underflow.
                        //
                        // We can directly compare the packed value.
                        // If the address is zero, packed will be zero.
                        while (packed == 0) {
                            packed = _packedOwnerships[--curr];
                        }
                        return packed;
                    }
                }
        }
        revert OwnerQueryForNonexistentToken();
    }

    /**
     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.
     */
    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {
        ownership.addr = address(uint160(packed));
        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);
        ownership.burned = packed & _BITMASK_BURNED != 0;
        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);
    }

    /**
     * @dev Packs ownership data into a single uint256.
     */
    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {
        assembly {
            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.
            owner := and(owner, _BITMASK_ADDRESS)
            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.
            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))
        }
    }

    /**
     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.
     */
    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {
        // For branchless setting of the `nextInitialized` flag.
        assembly {
            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.
            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))
        }
    }

    // =============================================================
    //                      APPROVAL OPERATIONS
    // =============================================================

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the
     * zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);

        if (_msgSenderERC721A() != owner)
            if (!isApprovedForAll(owner, _msgSenderERC721A())) {
                revert ApprovalCallerNotOwnerNorApproved();
            }

        _tokenApprovals[tokenId].value = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId].value;
    }

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom}
     * for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        if (operator == _msgSenderERC721A()) revert ApproveToCaller();

        _operatorApprovals[_msgSenderERC721A()][operator] = approved;
        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);
    }

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted. See {_mint}.
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return
            _startTokenId() <= tokenId &&
            tokenId < _currentIndex && // If within bounds,
            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.
    }

    /**
     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.
     */
    function _isSenderApprovedOrOwner(
        address approvedAddress,
        address owner,
        address msgSender
    ) private pure returns (bool result) {
        assembly {
            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.
            owner := and(owner, _BITMASK_ADDRESS)
            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.
            msgSender := and(msgSender, _BITMASK_ADDRESS)
            // `msgSender == owner || msgSender == approvedAddress`.
            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))
        }
    }

    /**
     * @dev Returns the storage slot and value for the approved address of `tokenId`.
     */
    function _getApprovedSlotAndAddress(uint256 tokenId)
        private
        view
        returns (uint256 approvedAddressSlot, address approvedAddress)
    {
        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];
        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId]`.
        assembly {
            approvedAddressSlot := tokenApproval.slot
            approvedAddress := sload(approvedAddressSlot)
        }
    }

    // =============================================================
    //                      TRANSFER OPERATIONS
    // =============================================================

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token
     * by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);

        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();

        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);

        // The nested ifs save around 20+ gas over a compound boolean condition.
        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();

        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner.
        assembly {
            if approvedAddress {
                // This is equivalent to `delete _tokenApprovals[tokenId]`.
                sstore(approvedAddressSlot, 0)
            }
        }

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.
        unchecked {
            // We can directly increment and decrement the balances.
            --_packedAddressData[from]; // Updates: `balance -= 1`.
            ++_packedAddressData[to]; // Updates: `balance += 1`.

            // Updates:
            // - `address` to the next owner.
            // - `startTimestamp` to the timestamp of transfering.
            // - `burned` to `false`.
            // - `nextInitialized` to `true`.
            _packedOwnerships[tokenId] = _packOwnershipData(
                to,
                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)
            );

            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .
            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {
                uint256 nextTokenId = tokenId + 1;
                // If the next slot's address is zero and not burned (i.e. packed value is zero).
                if (_packedOwnerships[nextTokenId] == 0) {
                    // If the next slot is within bounds.
                    if (nextTokenId != _currentIndex) {
                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.
                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;
                    }
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token
     * by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement
     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        transferFrom(from, to, tokenId);
        if (to.code.length != 0)
            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {
                revert TransferToNonERC721ReceiverImplementer();
            }
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token IDs
     * are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * `startTokenId` - the first token ID to be transferred.
     * `quantity` - the amount to be transferred.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Hook that is called after a set of serially-ordered token IDs
     * have been transferred. This includes minting.
     * And also called after one token has been burned.
     *
     * `startTokenId` - the first token ID to be transferred.
     * `quantity` - the amount to be transferred.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.
     *
     * `from` - Previous owner of the given token ID.
     * `to` - Target address that will receive the token.
     * `tokenId` - Token ID to be transferred.
     * `_data` - Optional data to send along with the call.
     *
     * Returns whether the call correctly returned the expected magic value.
     */
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (
            bytes4 retval
        ) {
            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    // =============================================================
    //                        MINT OPERATIONS
    // =============================================================

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event for each mint.
     */
    function _mint(address to, uint256 quantity) internal virtual {
        uint256 startTokenId = _currentIndex;
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // `balance` and `numberMinted` have a maximum limit of 2**64.
        // `tokenId` has a maximum limit of 2**256.
        unchecked {
            // Updates:
            // - `balance += quantity`.
            // - `numberMinted += quantity`.
            //
            // We can directly add to the `balance` and `numberMinted`.
            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);

            // Updates:
            // - `address` to the owner.
            // - `startTimestamp` to the timestamp of minting.
            // - `burned` to `false`.
            // - `nextInitialized` to `quantity == 1`.
            _packedOwnerships[startTokenId] = _packOwnershipData(
                to,
                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)
            );

            uint256 toMasked;
            uint256 end = startTokenId + quantity;

            // Use assembly to loop and emit the `Transfer` event for gas savings.
            assembly {
                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.
                toMasked := and(to, _BITMASK_ADDRESS)
                // Emit the `Transfer` event.
                log4(
                    0, // Start of data (0, since no data).
                    0, // End of data (0, since no data).
                    _TRANSFER_EVENT_SIGNATURE, // Signature.
                    0, // `address(0)`.
                    toMasked, // `to`.
                    startTokenId // `tokenId`.
                )

                for {
                    let tokenId := add(startTokenId, 1)
                } iszero(eq(tokenId, end)) {
                    tokenId := add(tokenId, 1)
                } {
                    // Emit the `Transfer` event. Similar to above.
                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)
                }
            }
            if (toMasked == 0) revert MintToZeroAddress();

            _currentIndex = end;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * This function is intended for efficient minting only during contract creation.
     *
     * It emits only one {ConsecutiveTransfer} as defined in
     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),
     * instead of a sequence of {Transfer} event(s).
     *
     * Calling this function outside of contract creation WILL make your contract
     * non-compliant with the ERC721 standard.
     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309
     * {ConsecutiveTransfer} event is only permissible during contract creation.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {ConsecutiveTransfer} event.
     */
    function _mintERC2309(address to, uint256 quantity) internal virtual {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();
        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.
        unchecked {
            // Updates:
            // - `balance += quantity`.
            // - `numberMinted += quantity`.
            //
            // We can directly add to the `balance` and `numberMinted`.
            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);

            // Updates:
            // - `address` to the owner.
            // - `startTimestamp` to the timestamp of minting.
            // - `burned` to `false`.
            // - `nextInitialized` to `quantity == 1`.
            _packedOwnerships[startTokenId] = _packOwnershipData(
                to,
                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)
            );

            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);

            _currentIndex = startTokenId + quantity;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Safely mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement
     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
     * - `quantity` must be greater than 0.
     *
     * See {_mint}.
     *
     * Emits a {Transfer} event for each mint.
     */
    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal virtual {
        _mint(to, quantity);

        unchecked {
            if (to.code.length != 0) {
                uint256 end = _currentIndex;
                uint256 index = end - quantity;
                do {
                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {
                        revert TransferToNonERC721ReceiverImplementer();
                    }
                } while (index < end);
                // Reentrancy protection.
                if (_currentIndex != end) revert();
            }
        }
    }

    /**
     * @dev Equivalent to `_safeMint(to, quantity, '')`.
     */
    function _safeMint(address to, uint256 quantity) internal virtual {
        _safeMint(to, quantity, '');
    }

    // =============================================================
    //                        BURN OPERATIONS
    // =============================================================

    /**
     * @dev Equivalent to `_burn(tokenId, false)`.
     */
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);

        address from = address(uint160(prevOwnershipPacked));

        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);

        if (approvalCheck) {
            // The nested ifs save around 20+ gas over a compound boolean condition.
            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        // Clear approvals from the previous owner.
        assembly {
            if approvedAddress {
                // This is equivalent to `delete _tokenApprovals[tokenId]`.
                sstore(approvedAddressSlot, 0)
            }
        }

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.
        unchecked {
            // Updates:
            // - `balance -= 1`.
            // - `numberBurned += 1`.
            //
            // We can directly decrement the balance, and increment the number burned.
            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.
            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;

            // Updates:
            // - `address` to the last owner.
            // - `startTimestamp` to the timestamp of burning.
            // - `burned` to `true`.
            // - `nextInitialized` to `true`.
            _packedOwnerships[tokenId] = _packOwnershipData(
                from,
                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)
            );

            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .
            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {
                uint256 nextTokenId = tokenId + 1;
                // If the next slot's address is zero and not burned (i.e. packed value is zero).
                if (_packedOwnerships[nextTokenId] == 0) {
                    // If the next slot is within bounds.
                    if (nextTokenId != _currentIndex) {
                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.
                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;
                    }
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
        unchecked {
            _burnCounter++;
        }
    }

    // =============================================================
    //                     EXTRA DATA OPERATIONS
    // =============================================================

    /**
     * @dev Directly sets the extra data for the ownership data `index`.
     */
    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {
        uint256 packed = _packedOwnerships[index];
        if (packed == 0) revert OwnershipNotInitializedForExtraData();
        uint256 extraDataCasted;
        // Cast `extraData` with assembly to avoid redundant masking.
        assembly {
            extraDataCasted := extraData
        }
        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);
        _packedOwnerships[index] = packed;
    }

    /**
     * @dev Called during each token transfer to set the 24bit `extraData` field.
     * Intended to be overridden by the cosumer contract.
     *
     * `previousExtraData` - the value of `extraData` before transfer.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _extraData(
        address from,
        address to,
        uint24 previousExtraData
    ) internal view virtual returns (uint24) {}

    /**
     * @dev Returns the next extra data for the packed ownership data.
     * The returned result is shifted into position.
     */
    function _nextExtraData(
        address from,
        address to,
        uint256 prevOwnershipPacked
    ) private view returns (uint256) {
        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);
        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;
    }

    // =============================================================
    //                       OTHER OPERATIONS
    // =============================================================

    /**
     * @dev Returns the message sender (defaults to `msg.sender`).
     *
     * If you are writing GSN compatible contracts, you need to override this function.
     */
    function _msgSenderERC721A() internal view virtual returns (address) {
        return msg.sender;
    }

    /**
     * @dev Converts a uint256 to its ASCII string decimal representation.
     */
    function _toString(uint256 value) internal pure virtual returns (string memory ptr) {
        assembly {
            // The maximum value of a uint256 contains 78 digits (1 byte per digit),
            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.
            // We will need 1 32-byte word to store the length,
            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.
            ptr := add(mload(0x40), 128)
            // Update the free memory pointer to allocate.
            mstore(0x40, ptr)

            // Cache the end of the memory to calculate the length later.
            let end := ptr

            // We write the string from the rightmost digit to the leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            // Costs a bit more than early returning for the zero case,
            // but cheaper in terms of deployment and overall runtime costs.
            for {
                // Initialize and perform the first pass without check.
                let temp := value
                // Move the pointer 1 byte leftwards to point to an empty character slot.
                ptr := sub(ptr, 1)
                // Write the character to the pointer.
                // The ASCII index of the '0' character is 48.
                mstore8(ptr, add(48, mod(temp, 10)))
                temp := div(temp, 10)
            } temp {
                // Keep dividing `temp` until zero.
                temp := div(temp, 10)
            } {
                // Body of the for loop.
                ptr := sub(ptr, 1)
                mstore8(ptr, add(48, mod(temp, 10)))
            }

            let length := sub(end, ptr)
            // Move the pointer 32 bytes leftwards to make room for the length.
            ptr := sub(ptr, 32)
            // Store the length.
            mstore(ptr, length)
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides a set of functions to operate with Base64 strings.
 *
 * _Available since v4.5._
 */
library Base64 {
    /**
     * @dev Base64 Encoding/Decoding Table
     */
    string internal constant _TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /**
     * @dev Converts a `bytes` to its Bytes64 `string` representation.
     */
    function encode(bytes memory data) internal pure returns (string memory) {
        /**
         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence
         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol
         */
        if (data.length == 0) return "";

        // Loads the table into memory
        string memory table = _TABLE;

        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter
        // and split into 4 numbers of 6 bits.
        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up
        // - `data.length + 2`  -> Round up
        // - `/ 3`              -> Number of 3-bytes chunks
        // - `4 *`              -> 4 characters for each chunk
        string memory result = new string(4 * ((data.length + 2) / 3));

        /// @solidity memory-safe-assembly
        assembly {
            // Prepare the lookup table (skip the first "length" byte)
            let tablePtr := add(table, 1)

            // Prepare result pointer, jump over length
            let resultPtr := add(result, 32)

            // Run over the input, 3 bytes at a time
            for {
                let dataPtr := data
                let endPtr := add(data, mload(data))
            } lt(dataPtr, endPtr) {

            } {
                // Advance 3 bytes
                dataPtr := add(dataPtr, 3)
                let input := mload(dataPtr)

                // To write each character, shift the 3 bytes (18 bits) chunk
                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
                // and apply logical AND with 0x3F which is the number of
                // the previous character in the ASCII table prior to the Base64 Table
                // The result is then added to the table to get the character to write,
                // and finally write it in the result pointer but with a left shift
                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits

                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance
            }

            // When data `bytes` is not exactly 3 bytes long
            // it is padded with `=` characters at the end
            switch mod(mload(data), 3)
            case 1 {
                mstore8(sub(resultPtr, 1), 0x3d)
                mstore8(sub(resultPtr, 2), 0x3d)
            }
            case 2 {
                mstore8(sub(resultPtr, 1), 0x3d)
            }
        }

        return result;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int)", p0));
	}

	function logUint(uint p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
	}

	function log(uint p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
	}

	function log(uint p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
	}

	function log(uint p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
	}

	function log(string memory p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
	}

	function log(uint p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
	}

	function log(uint p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
	}

	function log(uint p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
	}

	function log(uint p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
	}

	function log(uint p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
	}

	function log(uint p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
	}

	function log(uint p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
	}

	function log(uint p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
	}

	function log(uint p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
	}

	function log(uint p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
	}

	function log(uint p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
	}

	function log(uint p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
	}

	function log(bool p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
	}

	function log(bool p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
	}

	function log(bool p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
	}

	function log(address p0, uint p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
	}

	function log(address p0, uint p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
	}

	function log(address p0, uint p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// ERC721A Contracts v4.2.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

/**
 * @dev Interface of ERC721A.
 */
interface IERC721A {
    /**
     * The caller must own the token or be an approved operator.
     */
    error ApprovalCallerNotOwnerNorApproved();

    /**
     * The token does not exist.
     */
    error ApprovalQueryForNonexistentToken();

    /**
     * The caller cannot approve to their own address.
     */
    error ApproveToCaller();

    /**
     * Cannot query the balance for the zero address.
     */
    error BalanceQueryForZeroAddress();

    /**
     * Cannot mint to the zero address.
     */
    error MintToZeroAddress();

    /**
     * The quantity of tokens minted must be more than zero.
     */
    error MintZeroQuantity();

    /**
     * The token does not exist.
     */
    error OwnerQueryForNonexistentToken();

    /**
     * The caller must own the token or be an approved operator.
     */
    error TransferCallerNotOwnerNorApproved();

    /**
     * The token must be owned by `from`.
     */
    error TransferFromIncorrectOwner();

    /**
     * Cannot safely transfer to a contract that does not implement the
     * ERC721Receiver interface.
     */
    error TransferToNonERC721ReceiverImplementer();

    /**
     * Cannot transfer to the zero address.
     */
    error TransferToZeroAddress();

    /**
     * The token does not exist.
     */
    error URIQueryForNonexistentToken();

    /**
     * The `quantity` minted with ERC2309 exceeds the safety limit.
     */
    error MintERC2309QuantityExceedsLimit();

    /**
     * The `extraData` cannot be set on an unintialized ownership slot.
     */
    error OwnershipNotInitializedForExtraData();

    // =============================================================
    //                            STRUCTS
    // =============================================================

    struct TokenOwnership {
        // The address of the owner.
        address addr;
        // Stores the start time of ownership with minimal overhead for tokenomics.
        uint64 startTimestamp;
        // Whether the token has been burned.
        bool burned;
        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.
        uint24 extraData;
    }

    // =============================================================
    //                         TOKEN COUNTERS
    // =============================================================

    /**
     * @dev Returns the total number of tokens in existence.
     * Burned tokens will reduce the count.
     * To get the total number of tokens minted, please see {_totalMinted}.
     */
    function totalSupply() external view returns (uint256);

    // =============================================================
    //                            IERC165
    // =============================================================

    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    // =============================================================
    //                            IERC721
    // =============================================================

    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables
     * (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in `owner`'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`,
     * checking first that contract recipients are aware of the ERC721 protocol
     * to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move
     * this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement
     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}
     * whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token
     * by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the
     * zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom}
     * for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    // =============================================================
    //                        IERC721Metadata
    // =============================================================

    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);

    // =============================================================
    //                           IERC2309
    // =============================================================

    /**
     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`
     * (inclusive) is transferred from `from` to `to`, as defined in the
     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.
     *
     * See {_mintERC2309} for more details.
     */
    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);
}