// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

library StakingLibrary {

    enum UnstakingCategories {
        REWARD_0pc,
        REWARD_30pc,
        REWARD_50pc,
        REWARD_100pc
    }

    enum MembershipCategories {
        REGULAR,
        UPGRAGE,
        PREMIUIM,
        TEAM
    }

    enum CampaignCategories {
        SILVER,
        GOLD,
        DIAMOND
    }

    struct PoolInfo {
        uint256 poolId;
        address poolAddress;
        uint256 remainingPool;
        uint256 totalTokensStaked;
        uint256 totalParicipants;
        uint256 tokenCounter;
        address poolOwner;
    }

    enum ProfileType {NONE, TEAM, USER}

    struct ProjectInfo {
        CampaignCategories category;
        string projectName;
        string projectSymbol;
        address tokenAddress;
        uint8 tokenDecimals;
        string tokenSymbol;
        ProfileType profileType;
        uint256 profileId;
    }

    struct RewardPoolInfo {
        uint256 startedAt;
        uint256 poolAmount;
    }

    struct Images {
        string image_3_months;
        string image_6_months;
        string image_12_months;
    }
       
    struct TokenData {
        uint256 poolId;
        uint256 tokenStaked;
        address tokenAddress;
        address owner;
        address creator;
        uint256 tokenId;
        string tokenUri;
        uint8 stakingType;
        uint256 stakingTime;
        uint256 unlockTime;
        uint256 expectedReward;
        bool isUnskated;
        uint256 redeemedReward;
        uint8 pcReceived;
    }

    struct PoolFullInfo {
        PoolInfo poolInfo;
        ProjectInfo projectInfo; 
        RewardPoolInfo rewardPoolInfo; 
        Images images;
    }

    struct UserDetail {
        uint256 memberSince;
        uint256 memberId;
        bool isPremium;
    }




}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "../library/StakingLibrary.sol";
import "../interfaces/IUniswapV2Router02.sol";

contract MembershipFeeManager is Ownable {
    /**
    * Network: Goerli
    * Aggregator: ETH/USD
    * Address: 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
    */


    /**
    * Network: BNB Chain Mainnet
    * Aggregator: BNB/USD
    * Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE
    */

    AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);

    // IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); //Pancakeswap router mainnet - BSC
    IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Uniswap router goerli testnet - ETH

    mapping (StakingLibrary.MembershipCategories => uint256) public membershipFee;
    
    address DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    event Received(address, uint);
    
    FeeDistributionScheme public feeDistributionScheme;
    struct FeeDistributionScheme {
        uint8 buyBackAndburn;
        uint8 rewardPool;
        uint8 corporate;
    }

    FeeDistributionWallets public feeDistributionWallets;
    struct FeeDistributionWallets {
        address payable buyBackAndburn;
        address payable rewardPool;
        address payable corporate;
    }

    constructor( uint256 regular, uint256 upgrade, uint256 premium, uint256 team) {
        membershipFee[StakingLibrary.MembershipCategories.REGULAR] = regular;
        membershipFee[StakingLibrary.MembershipCategories.UPGRAGE] = upgrade;
        membershipFee[StakingLibrary.MembershipCategories.PREMIUIM] = premium;
        membershipFee[StakingLibrary.MembershipCategories.TEAM] = team;
    }

    function getMembershipFee(StakingLibrary.MembershipCategories category) public view returns (uint256){
        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());
        return membershipFee[category] * priceOfOneUSD;
    }

    enum FeesType {USD, BNB}

    function getAllFees(FeesType feeType) public view returns (
        uint256 regular,
        uint256 upgrade,
        uint256 premium,
        uint256 team
    ){
            regular = membershipFee[StakingLibrary.MembershipCategories.REGULAR];
            upgrade = membershipFee[StakingLibrary.MembershipCategories.UPGRAGE];
            premium = membershipFee[StakingLibrary.MembershipCategories.PREMIUIM];
            team = membershipFee[StakingLibrary.MembershipCategories.TEAM];

            if(feeType == FeesType.BNB){
                uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());
                regular = regular * priceOfOneUSD;
                upgrade = upgrade * priceOfOneUSD;
                premium = premium * priceOfOneUSD;
                team = team * priceOfOneUSD;
            }

    }

    function setMembershipFee(uint256 regular, uint256 upgrade, uint256 premium, uint256 team) public onlyOwner {
        membershipFee[StakingLibrary.MembershipCategories.REGULAR] = regular;
        membershipFee[StakingLibrary.MembershipCategories.UPGRAGE] = upgrade;
        membershipFee[StakingLibrary.MembershipCategories.PREMIUIM] = premium;
        membershipFee[StakingLibrary.MembershipCategories.TEAM] = team;
    }

    function setDistributionScheme(uint8 buyBackAndburn, uint8 rewardPool, uint8 corporate ) public onlyOwner {
        feeDistributionScheme.buyBackAndburn = buyBackAndburn;
        feeDistributionScheme.rewardPool = rewardPool;
        feeDistributionScheme.corporate = corporate;
    }

    function setFeeDistributionWallets(address buyBackAndburn, address rewardPool, address corporate) public onlyOwner {
        feeDistributionWallets.buyBackAndburn = payable(buyBackAndburn);
        feeDistributionWallets.rewardPool = payable(rewardPool);
        feeDistributionWallets.corporate = payable(corporate);
    }

    function SplitFunds() public onlyOwner {

        require(
            feeDistributionWallets.buyBackAndburn != address(0) && 
            feeDistributionWallets.rewardPool != address(0) && 
            feeDistributionWallets.corporate != address(0), 
            "Distribution wallets are not being set" 
        );

        uint256 totalBalance = address(this).balance;
        require(totalBalance > 0, "No balance avaialble for split");

        uint256 corporateShare =  (totalBalance * feeDistributionScheme.corporate) / 100;
        uint256 rewardPoolShare =  (totalBalance * feeDistributionScheme.rewardPool) / 100;
        uint256 buyBackAndBurnShare =  totalBalance - corporateShare - rewardPoolShare;

        feeDistributionWallets.corporate.transfer(corporateShare);
        feeDistributionWallets.rewardPool.transfer(rewardPoolShare);
        swapETHForTokensNoFee(feeDistributionWallets.buyBackAndburn, DEAD_ADDRESS, buyBackAndBurnShare);
        // swapETHForTokens(feeDistributionWallets.buyBackAndburn, sendTokensto, buyBackAndBurnShare);
        
    }

    function emergencyWithdraw() public onlyOwner {
        uint256 totalBalance = address(this).balance;
        require(totalBalance > 0, "No balance avaialble for withdraw");
        payable(owner()).transfer(totalBalance);
    }

    function setRouter(IUniswapV2Router02 _uniswapV2Router) public onlyOwner {
        uniswapV2Router = _uniswapV2Router;
    }

    function swapETHForTokensNoFee(
        address tokenAddress,
        address toAddress,
        uint256 amount
    ) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = uniswapV2Router.WETH();
        path[1] = tokenAddress;

        uniswapV2Router.swapExactETHForTokens{
            value: amount
        }(
            0, // accept any amount of Tokens
            path,
            toAddress, // The contract
            block.timestamp + 500
        );      

    }

    function getLatestPriceOfOneUSD() public view returns (int) {
        (
            ,
            /*uint80 roundID*/ int price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,
            ,
            ,

        ) = priceFeed.latestRoundData();
        
        // this is the price of 1 Eth in USDs  => 1 ETh = price USDs
        // Find price of 1 USD => 1 USD = 1/price ETH

        int ONE_ETH = 1 ether;
        return (ONE_ETH * 10**8)/price;
        // int random = 756881949122395;
        // return random;

        // return price;
    }

    receive() external payable {
        emit Received(msg.sender, msg.value);
    }

}