/**
 *Submitted for verification at Etherscan.io on 2022-10-01
*/

// SPDX-License-Identifier: Unlicensed

/**
                           ,▄▄███,                                              
                    ,▄▄███████████▄                                             
              ▄▄▄███████████████████                                            
         ,▄██████████████████████████⌐                                          
      ▄███████████████████████████████▄                                         
   ▄███████████████████████████████████▄                                        
  ██████████████████████████████████████▄                                       
   ▀█████████████████████████████████████▄                                      
     █████████████████████████████████████▄           ,▄▄▄████▌                 
      ▀████████████████████████████████████▌   ,▄▄▄██████████▀                  
        ███████████████████████████▀▀▀' ,▄▄██████████████▀▀'                    
         ▀██████████████████▀▀▀` ,▄▄▄████████████▀▀▀'                           
          ╙███████████▀▀"  ,▄▄██████████████████▄                               
            ███▀▀`  ,▄▄▄██████████████▀▀▀` -`` "▀▀█▄,                           
             ▀█▄▄███████████████▀▀' ▄▄▄             ▀█,                         
         ,▄▄███████████████▀▀` ▄      ▀▀███████████   █▄                        
    ▄▄████████████████▀▀'   ,,,▐█       ██▀,▄▄∞██▀█    █▌                       
▄███████████▀▀ ████▀   ▄▄██▀▀▀▀██▌      ███▀   ▀▀▐█    ▐█      ,▄▄              
▐█████▀▀▀     ███▀   ▄█" █▀  ,█╓██▌     ▀█▄    ,▄█`,▄▄▄▄██▄,   `▀██             
 ▀▀          ▐██▌  ╓██ ,█▀  ╓█▄▀ ▐█        ▀▀▀▀▀▀▄████████████████▀             
             ███  ▄██▌▄█▀  ▄▀▄▀ ▄▀█    ,▄███████████▀   ▐█  ▀▀`                 
            ▐██▌ ▐█ ▀██▌  ▄▀▄` █`▄▌   ████▀▀▀████▀▀'▄▄   █▌                     
            ▐██▌  █   '▀██▌█,▄█▄█▀  ╓███▀  ▄r ,▄▄▄▄▄ ▐▌ ]█                      
            ▐██▌  █U      `▀▀▀▀ ▄▄ ¿███   ]█▌ ▀╓▄M+  '  ██                      
             ███  ▐▌           ╘█▄▄██▀     ▀▀          ╓█▌                      
             ███▌ j█              -                   ╓█▀                       
              ███▄ █                                 ▄█▀                ▄██████▄
               █████                               ▄██▀               ,██▀ `▀▀` 
                ▀████▄                          ▄▄██▀                ▄█▀        
                   ▀████▄▄                 ,▄▄███▀██▄               ██          
                      ▀▀▀████████▄▄██████████▀  █  ▐██▄▄          ,██           
                          ▀█▄ -'▀█   ╙█  █`  ▀██▌ █▀ ▐█▀███▄▄▄  ▄██▀            
                           ╙█▄   █▌   █▌██▄   █▀▀▄ █▄▐█µ  ▀▀█████▀              
                            ▐██   ▀▀█ ▐█▀  ████  ╙█ ▐▄▀█                        
                            ████   ]█  █   ▐█ "█,  █▀  ▀█                       
                           ▄█▀▀██   ╙█▄▐▄  █▌   █▄ ▐█   ▀█                      
                          ▐█▌  ██     ▀██▄ █▌    █▄ █    ██                     
                          ██   ██▌      ▀█▄▀█,   █▌██     █▌                    
                         ██`   ███▄█▄▄    ██m██▄█▀ ▐█     ▐█                    
                        ▐██▄██▀██`╒█▀▀▀▀▀▀ ▀█▄  █  █▀      █`                   
                        ▀▀'    ██ █▌          ▀▀██▀        █▌                   
                              '▀  '              ▀         ▀`   
    
    ▄▄███▄▄·██╗██████╗     ████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗
    ██╔════╝██║██╔══██╗    ╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║
    ███████╗██║██████╔╝       ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║
    ╚════██║██║██╔══██╗       ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║
    ███████║██║██║  ██║       ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║
    ╚═▀▀▀══╝╚═╝╚═╝  ╚═╝       ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝

    initial supply 1.000.000.000 $IR
    to be burned     750.000.000 $IR
    final supply     250.000.000 $IR

    TAXES -------------------------------------------------------------

    - on sell 2% buyback & burn on the mainnet
      (on other networks added to treasury tax)
    - on buy, 2% added to liquidity
    - treasury 8%

    wallet to wallet is not taxed

    Burn and sell tax will end when the burn is completed.
    Auto buyback and burn works only on eth mainnet.

    Slippage up to 12% will be required on sell/buy because of taxes!

    LIQUIDITY LOCK ----------------------------------------------------

    After address [0xAB] provides liquidity, we simply lock any 
    interactions, from this address, with tokens in liquidity.
    Liquidity can't be removed manually before the set time (there is no such 
    function in the contract), nor can it be removed using Uniswap Dapp. 
    (Same goes for other networks).

    setLock(address, timestamp) and [0xAB] (POOL) tokens are locked.

    Lock time can't be shortened but it can be increased.
    We will not remove any liquidity until our next project is launched.
    If we can't open our next platform to the public on time, we will extend
    the liquidity lock every day until we are sure we can open our next 
    platform to the public.

    setLock(address, timestamp) sets or extends lock timestamp.

    All these actions are ofc logged on the blockchain.
    
    isLiqudityLocked() returns true or false.
    LiqudityIsLockedUntil() returns timestamp.
    unlock() unlocks liquidity if timer expired.

    Details and info on: https://dapp.sirtoken.com

    LOCKED TOKENS -----------------------------------------------------

    There are only three wallets with locked tokens ...
    Key.SEED 90 days 37.5 mil.
    Key.TEAM 90 days 10 mil.
    Key.RESERVE 60 days 30 mil.

    There is no function in the contract that would enable unlocking before
    previously set unlock time.
    
    setLocked(address, timestamp) to lock or extend lock time.
    AccountIsLockedUntil() returns timestamp.
    isAccountLocked(address) returns true/false

    TRANSFERS ---------------------------------------------------------
    
    The default max transfer amount by default is 1% of the current supply.
    This can be checked with getMaxTransactionAmount()
    or on https://dapp.sirtoken.com

    The default max sell amount by default is 1% of current liquidity tokens.
    This can be checked with getMaxSellAmount()
    or on https://dapp.sirtoken.com

    The default max buy amount by default is 1% of current liquidity tokens.
    This can be checked with getMaxBuyAmount()
    or on https://dapp.sirtoken.com

    All transfer limits are disabled after the burn ends.

    Be aware:
        - if you ware to provide the liquidity you will be taxed the 
        same as if you were selling tokens!
        - maximum liquidity that you could add is also limited to default
        1% of current liquidity tokens.

    -------------------------------------------------------------------

    
    web: https://sirtoken.com
    dapp: https://dapp.sirtoken.com
    twitter: https://twitter.com/likeaSIRtoken
    telegram: https://t.me/SirToken

    dev: [email protected]

    indexes
    --------------
    BURN      0xA0 | LIQUIDITY 0xA1 | TREASURY  0xA2 | PROXY     0xA3
    DEV       0xA4 | ADVISORS  0xA5 | TEAM      0xA6 | MARKETING 0xA7
    RESERVE   0xA8 | SEED      0xA9 | AIRDROPS  0xAA | LP PROV.  0xAB
    PAIR      0xAC | FACTORY   0xAD | ROUTER    0xAE | WETH      0xAF
    LP        0xB0 |

    Error codes:
    00  Zero amount
    01  Zero address
    02  balance is zero 
    03  this tax no longer applies
    04  amount > than the allowance
    05  amount > than balance
    06  buy amount over the maximum
    07  base fee is over 8%
    08  Caller is not the owner
    09  value same as current
    10  LP time locked
    11  address time locked
    12  trading is not enabled
    13  transaction amount over the maximum
    14  sell amount over the maximum
    15  timestamp is in past
    16  amount > than the current Ethereum balance
    17  total tax is over 15%
    18  we are at the max burn
    19  we are not on the Etherum mainnet
    20  values can be only 1 to 10
    21  BuyBack&burn is not enabled
    22  over maximum
    23  only non-native token
    24  already used
    25  Invalid index
    26  timestamp must extend the lock time
    27  amount to low
    28  not over threshold
    29  tax not enabled
    30  SafeMath: addition overflow
    31  SafeMath: multiplication overflow
    32  SafeMath: subtraction overflow
    33  SafeMath: division by zero
*/

pragma solidity 0.8.17;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IUniswapV2Pair {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function sync() external;
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

contract Ownable is Context {
    address private _owner;
    address private _previousOwner;

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "08");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    function transferOwnership(address newOwner) public virtual onlyOwner {
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


library UniswapV2Library {
    //using SafeMath for uint;

    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {
        require(tokenA != tokenB, "09");
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "01");
    }

    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint160(uint(keccak256(
            abi.encodePacked(hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), 
            hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"
        )))));
    }

    function getReserves(address factory, address tokenA, address tokenB) internal view returns(uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
}

library EnumerableSet {
    struct Set {
        bytes32[] _values;
        mapping(bytes32 => uint256) _indexes;
    }

    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    function _remove(Set storage set, bytes32 value) private returns (bool) {
        uint256 valueIndex = set._indexes[value];
        if (valueIndex != 0) {
            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;
            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];
                set._values[toDeleteIndex] = lastValue;
                set._indexes[lastValue] = valueIndex;
            }
            set._values.pop();
            delete set._indexes[value];
            return true;
        } else {
            return false;
        }
    }

    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    struct AddressSet {
        Set _inner;
    }

    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}

contract Proxy {
    address private main;

    receive() external payable {}
    fallback() external payable {}

    modifier onlyMainContract {
        require(msg.sender == main, "19");
        _;
    }

    constructor(address address_) payable {
        main = address_;
    }

    function sendEth() public onlyMainContract {
        payable(main).transfer(address(this).balance);
    }
}

contract SirToken is IERC20, Context {
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _locked;
    mapping(bytes1 => address) private _address;

    EnumerableSet.AddressSet private ExcludedFromFee;
    EnumerableSet.AddressSet private ExcludedFromMaxTransaction;
    EnumerableSet.AddressSet private Airdrops;

    IUniswapV2Router02 private _dexRouter;
    address private _dexPair;
    address private _owner;
    
    Proxy public proxy;

    bytes1 constant private idx0 = 0xA0;
    bytes1 constant private idx1 = 0xA1;
    bytes1 constant private idx2 = 0xA2;

    uint8 private constant _decimals = 18;
    string private constant _name = "SIR Token";
    string private constant _symbol = "$IR";

    uint256 private constant multiplier = 10 ** _decimals;
    uint256 private constant _initialSupply = 1000000000 * multiplier;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 private tradingStartTime;

    struct Booleans {
        bool buy;
        bool sell;
        bool transfer;
        bool buyBack;
        bool isMainNet;
        bool isTradingEnabled;
        bool autoDistributeFees;
        bool limitsEnabled;
        bool feesEnabled;
        bool autoProcessFees;
        bool swapEnabled;
        bool inSwap;
        bool feesProcessed;
    }
    Booleans private Bool;

    struct Taxes {
        bool enabled;
        bool previousState;
        uint256 percentage;
        uint256 percent;
        uint256 previousPercent;
        uint256 tBalance;
        uint256 eBalance;
        uint256 rBalance;
        uint256 tThreshold;
        uint256 eThreshold;
    }
    mapping(bytes1 => Taxes) private Tax;
    
    struct Totals {
        uint8 lockedAccounts;
        uint256 baseTax;
        uint256 buyTax;
        uint256 sellTax;
        uint256 supply;
        uint256 burned;
        uint256 liquidatedTokens;
        uint256 liquidatedEthers;
        uint256 airdropped;
    }
    Totals private Total;

    struct MaxVal {
        uint256 sellPercent;
        uint256 buyPercent;
        uint256 transactionPercent;
        uint256 sellAmount;
        uint256 buyAmount;
        uint256 transactionAmount;
        uint256 burn;
        uint256 airdrop;
    }
    MaxVal private Max = MaxVal({
        sellPercent: 100,
        buyPercent: 100,
        transactionPercent: 100,
        sellAmount: 0,
        buyAmount: 0,
        transactionAmount: 0,
        burn: 750000000 * multiplier, 
        airdrop: 2000000 * multiplier
    });

    event AccountExcludedFromFee(address address_, bool excluded);
    event AccountExcludedFromMaxTx(address address_, bool excluded);
    event AccountUnlocked(address account, uint256 timestamp);
    event AddedLiquidity(uint256 eth, uint256 token);
    event AddressSet(bytes1 index, address previous, address _address);
    event Airdroped(address _address, uint256 amount);
    event AutoBuyBackAndBurnEnabled(bool enabled);
    event AutoDistributeFeesEnabled(bool enabled);
    event AutoSwapEnabled(bool enabled);
    event BoughtBackAndBurned(uint256 amountETH, uint256 toBurn);
    event Burned(address account, uint256 amount);
    event BurnEnded(uint256 timestamp, uint256 number);
    event FeesEnabled(bool enabled);
    event LimitsEnabled(bool enabled);
    event LiquidityLockSet(address address_, uint256 previousTime, uint256 timestamp);
    event LiquidityUnlocked(address account, uint256 timestamp);
    event LockSet(address address_, uint256 previousTime, uint256 timestamp);
    event MaxBuyPercentChanged(uint256 previous, uint256 percent);
    event MaxSellPercentChanged(uint256 previous, uint256 percent);
    event MaxTransactionChanged(uint256 previousPercent, uint256 percent, uint256 previosAmount, uint256 amount);
    event Minted(address address_, uint256 amount_);
    event NewThresholdSet(bytes1 index, uint256 previous, uint256 amount, bool eThreshold);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event RouterUpdated(address previousAddress, address router, address previousPair, address _pair);
    event SentFees(uint256 total);
    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensAddedToLiquidity);
    event TaxSet(bytes1 index, uint256 percent, bool enabled);
    event TradingEnabled(bool enabled, uint256 block, uint256 time);
    event WithdrawnERC20(address token, address ownerAddress, uint256 amount);
    event WithdrawnETH(address address_, uint256 amount);

    modifier lockTheSwap() {
        Bool.inSwap = true;
        _;
        Bool.inSwap = false;
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    constructor (address routerAddress_) payable {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);

        _address[0xA0] = 0x5180A4645567E48ae77B030F1F8916a3923fF5c1; // burn
        _address[0xA1] = 0x65c642Af2F1b5D5f46b26D56ce2FDb819784Cf74; // liquidity
        _address[0xA2] = 0xA6252e62239B66DA24928e12D5E3ad4b6756E32a; // treasur
        proxy = new Proxy(address(this));
        _address[0xA3] = payable(proxy); // proxy
        _address[0xA4] = 0x6f01c47182e5159CDf4feD513406e2AbED4555fa; // dev
        _address[0xA5] = 0xd03ea8624C8C5987235048901fB614fDcA89b117; // advisors
        _address[0xA6] = 0xEB857006589b6C89007c295f1870A1E60FE0188F; // team
        _address[0xA7] = 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1; // marketing
        _address[0xA8] = 0xd1E62E43CAB44030540d57CFf6a715A6e4A9ADB4; // reserve 
        _address[0xA9] = 0x890a02c8cFda7620d51973a83585931809bfA787; // seed investor
        _address[0xAA] = 0x7FdbF69d4507e90CbEdeCCF5aE09348f79c7937f; // airdrops
        _address[0xAB] = 0x254Fc4AA2Adca77f1C769389e152c16c8C4bf24a; // LP provider address
        _locked[_address[0xAB]] = 0;
    
        setRouter(routerAddress_);

        ExcludedFromFee.add(_owner);
        ExcludedFromFee.add(address(this));

        ExcludedFromFee.add(_address[0xA0]);
        ExcludedFromFee.add(_address[0xA2]);
        ExcludedFromFee.add(_address[0xA1]);
        ExcludedFromFee.add(_address[0xA3]);
        ExcludedFromFee.add(_address[0xA8]);
        ExcludedFromFee.add(_address[0xAB]);
        ExcludedFromFee.add(_address[0xAA]);

        ExcludedFromMaxTransaction.add(_owner);
        ExcludedFromMaxTransaction.add(address(this));

        ExcludedFromMaxTransaction.add(_address[0xA0]);
        ExcludedFromMaxTransaction.add(_address[0xA2]);
        ExcludedFromMaxTransaction.add(_address[0xA1]);
        ExcludedFromMaxTransaction.add(_address[0xA3]);
        ExcludedFromMaxTransaction.add(_address[0xAE]);
        ExcludedFromMaxTransaction.add(_address[0xAC]);
        ExcludedFromMaxTransaction.add(_address[0xAB]);

        __mint(_address[0xAB], 350000000 * multiplier);   // Main LP
        __mint(_address[0xA6],  10000000 * multiplier);   // team
        __mint(_address[0xA8],  30000000 * multiplier);   // reserve
        __mint(_address[0xA9],  37500000 * multiplier);   // seed investor
        __mint(_address[0xA7],   5000000 * multiplier);   // marketing
        __mint(_address[0xA5],   3000000 * multiplier);   // advisors
        __mint(_address[0xAA], Max.airdrop);              // airdrop 2.000.000
        __mint(_owner, _initialSupply - Total.supply);
    }

    receive() external payable {}
    fallback() external payable {}

    function setRouter(
        address address_
    ) public onlyOwner {
        validAddress(address_);
        require(address_ != _address[0xAE], "09");

        address previousRouterAddress = _address[0xAE];
        address previousPair = _address[0xAC];
        
        IUniswapV2Router02 router = IUniswapV2Router02(address_);
        _dexRouter = router;

        _address[0xAF] = _dexRouter.WETH();
        address pair = IUniswapV2Factory(router.factory()).getPair(address(this), _address[0xAF]);
        if (pair == address(0)) {
            _dexPair = IUniswapV2Factory(router.factory()).createPair(address(this), _address[0xAF]);
        } else {
            _dexPair = pair;
        }

        _address[0xAD] = address(router.factory());
        _address[0xAE] = address(_dexRouter);
        _address[0xAC] = address(_dexPair);

        _allowances[address(this)][_address[0xAE]] = ~uint256(0);
        if (previousRouterAddress != address(0))
            _allowances[address(this)][previousRouterAddress] = 0;
        
        _address[0xB0] = getLiquidityPoolAddress();
        emit RouterUpdated(previousRouterAddress, _address[0xAE], previousPair, _address[0xAC]);
    }

    function initialize() external onlyOwner {
        if (!Bool.isTradingEnabled) {
            setDefaultVars(0xA0);
            setDefaultVars(0xA1);
            setDefaultVars(0xA2);

            Bool.isMainNet = isRouterUniswap();
            Bool.buyBack = true;
            Bool.autoDistributeFees = true;
            Bool.limitsEnabled = true;
            Bool.feesEnabled = true;
            Bool.autoProcessFees = true;
            Bool.swapEnabled = true;

            Max.sellAmount = _getMaxSellAmount();
            Max.transactionAmount = _getMaxTransactionAmount();
            tradingStartTime = block.timestamp;
            Bool.isTradingEnabled = true;
            setLock(_address[0xA8], tradingStartTime + 60 days);
            setLock(_address[0xA9], tradingStartTime + 90 days);
            setLock(_address[0xA6], tradingStartTime + 90 days);
            emit TradingEnabled(true, block.number, tradingStartTime);
        }
    }

    function setDefaultVars(
        bytes1 index_
    ) private {
        Tax[index_].enabled = true;
        Tax[index_].percent = index_ == 0xA2 ? 800 : 200;
        Tax[index_].tThreshold = 10000 * multiplier;
        Tax[index_].eThreshold = 1e18;
        if (index_ == 0xA2) {
            Total.baseTax = Tax[0xA2].percent;
        }
        Total.buyTax = Total.baseTax + Tax[0xA0].percent;
        Total.sellTax = Total.baseTax + Tax[0xA1].percent;
    }

    function transferOwnership(
        address newOwner
    ) public virtual onlyOwner {
        require(newOwner != address(0), "00");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(
        address address_
    ) internal virtual {
        validAddress(address_);
        require(address_ != _owner, "09");
        ExcludedFromFee.remove(_owner);
        ExcludedFromMaxTransaction.remove(_owner);
        ExcludedFromFee.add(address_);
        ExcludedFromMaxTransaction.add(address_);
        if (_balances[_owner] > 0)
            moveBalance(_owner, address_);
        _owner = address_;
        emit OwnershipTransferred(_owner, address_);
    }

    function name() public pure returns(string memory) {
        return _name;
    }

    function symbol() public pure returns(string memory) {
        return _symbol;
    }

    function decimals() public pure returns(uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns(uint256) {
        return Total.supply;
    }

    function balanceOf(
        address address_
    ) public view override returns(uint256) {
        return _balances[address_];
    }

    function transfer(
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(_msgSender(), recipient_, amount_);
        return true;
    }

    function allowance(
        address owner_,
        address spender_
    ) public view override returns(uint256) {
        return _allowances[owner_][spender_];
    }

    function approve(
        address spender_,
        uint256 amount_
    ) public override returns(bool) {
        _approve(_msgSender(), spender_, amount_);
        return true;
    }

    function transferFrom(
        address sender_,
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(sender_, recipient_, amount_);
        require(_allowances[sender_][_msgSender()] >= amount_, "04");
        _approve(sender_, _msgSender(), _allowances[sender_][_msgSender()] - amount_);
        return true;
    }

    function _approve(
        address owner_,
        address spender_,
        uint256 amount_
    ) private {
        validAddress(owner_);
        validAddress(spender_);
        _allowances[owner_][spender_] = amount_;
        emit Approval(owner_, spender_, amount_);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "08");
    }

    function _transfer(
        address sender_,
        address recipient_,
        uint256 amount_
    ) private {
        validAddress(sender_);
        validAddress(recipient_);
        require(amount_ > 100, "27");
        require(amount_ <= _balances[sender_], "05");
        
        bool SenderIsPair = sender_ == _address[0xAC];
        bool RecipientIsPair = recipient_ == _address[0xAC];
        bool SenderExcludedFromFee = ExcludedFromFee.contains(sender_);
        bool RecipientExcludedFromFee = ExcludedFromFee.contains(recipient_);
        bool SenderExcludedFromMaxTx = ExcludedFromMaxTransaction.contains(sender_);

        Bool.buy = SenderIsPair && recipient_ != _address[0xAE];
        Bool.sell = RecipientIsPair && sender_ != _address[0xAE];
        Bool.transfer = !Bool.buy && !Bool.sell;

        if (!Bool.isTradingEnabled)
            require(SenderExcludedFromFee || RecipientExcludedFromFee, "12");

        if (sender_ == _address[0xAB] || recipient_ == _address[0xAB]) {
            _checkLock(_address[0xAB]);
            require(!isLiqudityLocked(), "10");
        }

        if (Total.lockedAccounts > 0) {
            if (isAccountLocked(sender_))
                _checkLock(sender_);
            require(!isAccountLocked(sender_) && !isAccountLocked(recipient_), "11");
        }

        if (Bool.inSwap || 
            Bool.transfer || 
            SenderExcludedFromFee || 
            RecipientExcludedFromFee || 
            sender_ == _address[0xAE]) {
            return transferBalance(sender_, recipient_, amount_);
        } else {
            if (Bool.limitsEnabled &&
                Bool.buyBack &&
                Bool.isTradingEnabled) {
                if (!SenderExcludedFromMaxTx)
                    require(amount_ <= Max.transactionAmount, "13");
                if (!Bool.sell && !SenderExcludedFromMaxTx)
                    require(amount_ <= Max.sellAmount, "14");
                if (!Bool.buy && !SenderExcludedFromMaxTx)
                    require(amount_ <= Max.buyAmount, "06");
            }

            if (Bool.swapEnabled && !SenderIsPair) {
                Bool.feesProcessed = false;
                if (Bool.buyBack) {
                    if (!Bool.feesProcessed && Tax[0xA0].enabled && 
                        Tax[0xA0].tBalance > Tax[0xA0].tThreshold &&
                        Bool.isMainNet) {
                        _processBurnFees();
                    }  
                    if (!Bool.feesProcessed && Tax[0xA1].enabled && 
                        Tax[0xA1].tBalance > Tax[0xA1].tThreshold) {
                        _processLiquidityFees();
                    } 
                }
                if (!Bool.feesProcessed && Tax[0xA2].enabled && 
                    Tax[0xA2].tBalance > Tax[0xA2].tThreshold) {
                    _processTreasuryFees();
                }
            }

            uint256 transferAmount = amount_;
            if (Bool.feesEnabled) {
                uint256 tFee = 0;
                bytes1 idx = Bool.sell ? idx0 : idx1;
                if (Bool.buyBack && Tax[idx].enabled) 
                    tFee += processFee(idx, amount_);
                if (Tax[0xA2].enabled)
                    tFee += processFee(0xA2, amount_);
                if (tFee > 0) {
                    transferBalance(sender_, address(this), tFee);
                    transferAmount -= tFee;
                }
            }

            transferBalance(sender_, recipient_, transferAmount);
        }
    }

    function processFee(
        bytes1 index_, 
        uint256 amount_
    ) private returns(uint256) {
        uint256 fee = (amount_ * Tax[index_].percent) / 10**4;
        if (!Bool.isMainNet && index_ == 0xA0) index_ = 0xA2;
        Tax[index_].tBalance += fee;
        return fee;
    }

    function processBurnFees() external onlyOwner {
        require(Tax[0xA0].tBalance > Tax[0xA0].tThreshold, "28");
        _processBurnFees();
    }

    function _processBurnFees() private {
        uint256 balance = subDiv(Tax[0xA0].tBalance, 1000);
        uint256 eth = _swapTokensForEth(balance);
        Tax[0xA0].tBalance = 0;
        Tax[0xA0].eBalance += subDiv(eth, 1000);
        if (Tax[0xA0].eBalance > Tax[0xA0].eThreshold) {
            _buyBackAndBurn();
            Tax[0xA0].eBalance = 0;
        }
        Bool.feesProcessed = true;
    }

    function processLiquidityFees() external onlyOwner {
        require(Tax[0xA1].tBalance > Tax[0xA1].tThreshold, "28");
        _processLiquidityFees();
    }

    function _processLiquidityFees() private {
        uint256 half = Tax[0xA1].tBalance / 2;
        uint256 eth = _swapTokensForEth(Tax[0xA1].tBalance - half);
        Tax[0xA1].tBalance = 0;
        Tax[0xA1].rBalance += subDiv(half, 1000);
        Tax[0xA1].eBalance += subDiv(eth, 1000);
        if (Tax[0xA1].eBalance > Tax[0xA1].eThreshold) {
            addLiquidity(Tax[0xA1].eBalance, Tax[0xA1].rBalance);
            Tax[0xA1].eBalance = 0;
            Tax[0xA1].rBalance = 0;
        }
        Bool.feesProcessed = true;
    }

    function processTreasuryFees() external onlyOwner {
        require(Tax[0xA2].tBalance > Tax[0xA2].tThreshold, "28");
        _processTreasuryFees();
    }

    function _processTreasuryFees() private {
        uint256 balance = subDiv(Tax[0xA2].tBalance, 1000);
        uint256 eth = _swapTokensForEth(balance);
        Tax[0xA2].tBalance = 0;
        Tax[0xA2].eBalance += subDiv(eth, 1000);
        if (Tax[0xA2].eBalance > Tax[0xA2].eThreshold && 
            Bool.autoDistributeFees)
            _distributeFees();
        Bool.feesProcessed = true;
    }

    function distributeFees() external onlyOwner {
        require(Tax[0xA2].eBalance > Tax[0xA2].eThreshold, "28");
        _distributeFees();
    }

    function _distributeFees() private {
        uint256 balance = Tax[0xA2].eBalance;
        balance = subDiv(balance, 1000);        
        uint256 diff = (balance * (Total.baseTax / 2)) / 10**4;
        Tax[0xA2].eBalance = 0;
        payable(_address[0xA2]).transfer(balance - diff);
        payable(_address[0xA4]).transfer(diff);
        emit SentFees(balance);
    }

    function setAccountExcludedFromFee(
        address address_
    ) external onlyOwner {
        if (ExcludedFromFee.contains(address_)) {
            ExcludedFromFee.remove(address_);
        } else {
            ExcludedFromFee.add(address_);
        }
        emit AccountExcludedFromFee(address_, false);
    }

    function setAccountExcludedFromMaxTx(
        address address_
    ) external onlyOwner {
        if (ExcludedFromMaxTransaction.contains(address_)) {
            ExcludedFromMaxTransaction.remove(address_);
        } else {
            ExcludedFromMaxTransaction.add(address_);
        }
        emit AccountExcludedFromMaxTx(address_, false);
    }

    function setLock(
        address address_, 
        uint256 timestamp_
    ) public onlyOwner {
        validAddress(address_);
        require(
            address_ == _address[0xA6] || 
            address_ == _address[0xA8] ||
            address_ == _address[0xA9] || 
            address_ == _address[0xAB]
        );
        require(timestamp_ > block.timestamp, "15");
        require(timestamp_ > _locked[address_], "26");
        uint256 previousTime = 0;
        if (_locked[address_] == 0) {
            _locked[address_] = timestamp_;
            if (address_ != _address[0xAB])
                Total.lockedAccounts += 1;
        } else {
            previousTime = _locked[address_];
            _locked[address_] = timestamp_;
        }
        if (address_ != _address[0xAB]) {
            emit LockSet(address_, previousTime, _locked[address_]);
        } else {
            emit LiquidityLockSet(address_, previousTime, _locked[address_]);
        }
    }

    function isAccountLocked(
        address address_
    ) public view returns(bool) {
        return _locked[address_] > 0 ? true : false;
    }

    function accountIsLockedUntil(
        address address_
    ) external view returns(uint256) {
        return _locked[address_];
    }

    function isLiqudityLocked() public view returns(bool) {
        return _locked[_address[0xAB]] > 0 ? true : false;
    }

    function liqudityIsLockedUntil() external view returns(uint256) {
        return _locked[_address[0xAB]];
    }

    function toggleFeesEnabled() external onlyOwner {
        Bool.feesEnabled = !Bool.feesEnabled;
        emit FeesEnabled(Bool.feesEnabled);
    }

    function toggleLimitsEnabled() external onlyOwner {
        Bool.limitsEnabled = !Bool.limitsEnabled;
        emit LimitsEnabled(Bool.limitsEnabled);
    }

    function toggleSwapEnabled() external onlyOwner {
        Bool.swapEnabled = !Bool.swapEnabled;
        emit AutoSwapEnabled(Bool.swapEnabled);
    }

    function toggleAutoDistributeFees() external onlyOwner {
        Bool.autoDistributeFees = !Bool.autoDistributeFees;
        emit AutoDistributeFeesEnabled(Bool.autoDistributeFees);
    }

    function addLiquidity(
        uint256 eAmount_,
        uint256 tAmount_
    ) private lockTheSwap {
        _approve(address(this), _address[0xAE], tAmount_);
        _dexRouter.addLiquidityETH{value : eAmount_} (
            address(this),
            tAmount_,
            0,
            0,
            _owner,
            block.timestamp
        );
        Total.liquidatedEthers += eAmount_;
        Total.liquidatedTokens += tAmount_;
        Max.sellAmount = _getMaxSellAmount();
        Max.buyAmount = _getMaxBuyAmount();
        emit AddedLiquidity(eAmount_, tAmount_);
    }

    function manualAddLiquidity(
        uint256 eAmount_,
        uint256 tAmount_
    ) external onlyOwner {
        require(address(this).balance >= eAmount_, "16");
        require(_balances[address(this)] >= tAmount_, "05");
        addLiquidity(eAmount_, tAmount_);
    }

    function setTaxPercentage(
        bytes1 index_, 
        uint256 percent_
    ) external onlyOwner {
        applies(index_);
        require(Tax[index_].percent != percent_, "09");
        uint256 percent = percent_ > 0 ? percent_ * 100 : 0;
        Tax[index_].previousPercent = Tax[index_].percent;
        Tax[index_].previousState = Tax[index_].enabled;
        Tax[index_].enabled = percent > 0 ? true : false;
        Tax[index_].percent = Tax[index_].enabled ? percent : 0;
        if (index_ == 0xA2) {
            if (percent > 800)
                revert("07");
            Total.baseTax = Tax[0xA2].percent;          
        }
        Total.sellTax = Total.baseTax + Tax[0xA0].percent;
        Total.buyTax = Total.baseTax + Tax[0xA1].percent;
        require(Total.sellTax <= 15 && Total.buyTax <= 15, "17");
        emit TaxSet(index_, percent_, Tax[index_].enabled);
    }

    function setAutoBuyBackAndBurn(
        bool value_
    ) external onlyOwner {
        if (value_) {
            require(Total.burned < Max.burn, "18");
            require(Bool.isMainNet, "19");
            Tax[0xA0].enabled = Tax[0xA0].previousState;
            Tax[0xA0].percent = Tax[0xA0].previousPercent;
            Tax[0xA1].enabled = Tax[0xA1].previousState;
            Tax[0xA1].percent = Tax[0xA1].previousPercent;
            Bool.buyBack = true;
        }
        if (!value_ && Bool.buyBack)
            cleanUpAndEndTheBurn(); 
        emit AutoBuyBackAndBurnEnabled(value_);
    }

    function isBuyBackAndBurnEnabled() external view returns(bool) {
        return Bool.buyBack;
    }

    function setThreshold(
        bytes1 index_, 
        uint256 threshold_, 
        bool eThreshold
    ) external onlyOwner {
        applies(index_);
        require(index_ >= 0xA0 && index_ <= 0xA3, "25");
        uint256 previous;
        if (eThreshold) {
            require(Tax[index_].eThreshold != threshold_, "09");
            previous = Tax[index_].eThreshold;
            Tax[index_].eThreshold = threshold_;
        } else {
            require(Tax[index_].tThreshold != threshold_, "09");
            previous = Tax[index_].tThreshold;
            Tax[index_].tThreshold = threshold_;
        }
        emit NewThresholdSet(index_, previous, threshold_, eThreshold);
    }

    function getBalance(
        bytes1 index_
    ) external view returns(uint256) {
        require(index_ >= 0xA0 && index_ <= 0xB1, "25");
        if (index_ == 0)
            return address(this).balance;
        return _address[index_].balance;
    }

    function isExcludedFromFee(
        address address_
    ) external view returns(bool) {
        return ExcludedFromFee.contains(address_);
    }

    function isExcludedFromMaxTransaction(
        address address_
    ) external view returns(bool) {
        return ExcludedFromMaxTransaction.contains(address_);
    }

    function setAddress(
        bytes1 index_,
        address address_
    ) external onlyOwner {
        validAddress(address_);
        require(index_ >= 0xA0 && index_ <= 0xB1, "25");
        address pAddress = _address[index_];
        require(_locked[pAddress] == 0, "11");
        require(_address[index_] != address_, "09");
        _address[index_] = address_;
        if (_balances[_address[index_]] > 0)
            moveBalance(pAddress, address_);
        if (isAccountLocked(pAddress)) {
            setLock(_address[index_], _locked[pAddress]);
            setLock(pAddress, 0);
        }
        emit AddressSet(index_, pAddress, address_);
    }

    function setMaxSellAmountPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 1 && percent_ <= 10, "20");
        uint256 previous = Max.sellPercent;
        Max.sellPercent = percent_ * 100;
        emit MaxSellPercentChanged(previous, percent_);
    }

    function setMaxBuyPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 1 && percent_ <= 10, "20");
        uint256 previous = Max.buyPercent;
        Max.buyPercent = percent_ * 100;
        emit MaxBuyPercentChanged(previous, percent_);
    }

    function getMaxSellAmount() external view returns(uint256) {
        return _getMaxSellAmount() / multiplier;
    }

    function _getMaxSellAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return (count * Max.sellPercent) / 10**4;
    }

    function getMaxBuyAmount() external view returns(uint256) {
        return _getMaxBuyAmount() / multiplier;
    }

    function _getMaxBuyAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return (count * Max.buyPercent) / 10**4;
    }

    function getMaxTransactionAmount() external view returns(uint256) {
        return _getMaxTransactionAmount() / multiplier;
    }

    function _getMaxTransactionAmount() private view returns(uint256) {
        return (Total.supply * Max.transactionPercent) / 10**4;
    }

    function getTotals() external view returns(Totals memory) {
        return Total;
    }

    function getBooleans() external view returns(Booleans memory) {
        return Bool;
    }

    function getMaxValues() external view returns(MaxVal memory) {
        return Max;
    }

    function setMaxTransactionPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ > 0 && percent_ <= 10, "20");
        uint256 previousPercent = Max.transactionPercent;
        uint256 previousAmount = Max.transactionAmount;
        Max.transactionPercent = percent_ * 100;
        Max.transactionAmount = _getMaxTransactionAmount();
        emit MaxTransactionChanged(previousPercent, Max.transactionPercent, 
            previousAmount, Max.transactionAmount);
    }

    function airdrop(
        address address_,
        uint256 amount_
    ) external onlyOwner {
        validAddress(address_);
        validAmount(amount_);
        require(Total.airdropped + amount_ < Max.airdrop, "22");
        require(!Bool.isMainNet, "19");
        require(!Airdrops.contains(address_), "24");
        Total.airdropped += amount_;
        Airdrops.add(address_);
        transferBalance(_address[0xAA], address_, amount_);
        emit Airdroped(address_, amount_);
    }

    function _buyBackAndBurn() private lockTheSwap {
        uint256 amount_ = Tax[0xA0].eBalance;
        if (Total.burned >= Max.burn) {
            if (Bool.buyBack)
                cleanUpAndEndTheBurn();
        } else {
            _swapEthForTokens(_address[0xA3], amount_);
            uint256 diff;
            uint256 toBurn = _balances[_address[0xA3]];
            if (toBurn > 0) {
                uint256 burned = Total.burned + toBurn;
                if (burned > Max.burn) {
                    diff = burned - Max.burn;
                    toBurn -= diff;
                }
                __burn(_address[0xA3], toBurn);
                if (Total.burned == Max.burn)
                    cleanUpAndEndTheBurn();
                if (diff > 0)
                    transferBalance(_address[0xA0], _address[0xA2], diff);
                emit BoughtBackAndBurned(amount_, toBurn);
            }
        }
    }

    function _swapTokensForEth(
        uint256 amount_
    ) private lockTheSwap returns(uint256) {
        uint256 previousBalance = address(this).balance;
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _address[0xAF];
        _approve(address(this), _address[0xAE], amount_);
        _dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount_,
            0,
            path,
            address(this),
            block.timestamp + 60000
        );
        return address(this).balance - previousBalance;
    }

    function _swapEthForTokens(
        address to_,
        uint256 amount_
    ) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = _address[0xAF];
        path[1] = address(this);
        _dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount_}(
            0,
            path,
            to_,
            block.timestamp + 60000
        );
    }

    function getTaxData(
        bytes1 index_
    ) external view returns(Taxes memory) {
        return Tax[index_];
    }

    function getAddress(
        bytes1 index_
    ) external view returns(address) {
        return index_ <= 0xB0 ? _address[index_] : address(0);
    }

    function cleanUpAndEndTheBurn() private {
        require(Bool.buyBack, "21");
        moveBalance(_address[0xA0], _address[0xA2]);
        moveBalance(_address[0xA1], _address[0xA2]);
        moveBalance(_address[0xA3], _address[0xA2]);
        Tax[0xA0].enabled = false;
        Tax[0xA1].enabled = false;
        Bool.buyBack = false;
        Bool.limitsEnabled = false;
        emit BurnEnded(block.timestamp, block.number);
    }

    function isRouterUniswap() private view returns(bool) {
        return _address[0xAE] == address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    }

    function isTradingEnabled() external view returns(bool) {
        return Bool.isTradingEnabled;
    }

    function _getReserves() public view returns(uint256, uint256) {
        return UniswapV2Library.getReserves(_dexRouter.factory(), address(this), _address[0xAF]);
    }

    function getLiquidityPoolAddress() public view returns(address) {
        return UniswapV2Library.pairFor(_address[0xAD], _address[0xAF], address(this));
    }

    function __mint(
        address address_,
        uint256 amount_
    ) private {
        require(Total.supply + amount_ <= _initialSupply, "22");
        Total.supply += amount_;
        addBalance(address_, amount_);
        emit Minted(address_, amount_);
        emit Transfer(address(0), address_, amount_);
    }

    function burn(
        address from_, 
        uint256 amount_
    ) external onlyOwner {
        require(Total.burned + amount_ <= Max.burn, "22");
        require(amount_ <= _balances[from_], "05");
        __burn(from_, amount_);
    }

    function __burn(
        address address_,
        uint256 amount_
    ) private {
        subBalance(address_, amount_);
        addBalance(DEAD, amount_);
        Total.burned += amount_;
        Total.supply -= amount_;
        IUniswapV2Pair(_dexPair).sync();
        Max.transactionAmount = _getMaxTransactionAmount();
        emit Burned(address_, amount_);
        emit Transfer(address_, DEAD, amount_);
    }

    function addBalance(
        address address_,
        uint256 amount_
    ) private {
        _balances[address_] += amount_;
    }

    function subBalance(
        address address_,
        uint256 amount_
    ) private {
        unchecked {
            _balances[address_] -= amount_;
        }
    }

    function moveBalance(
        address from_, 
        address to_
    ) private { 
        uint256 amount_ = _balances[from_];
        _balances[from_] = 0;
        addBalance(to_, amount_);
        emit Transfer(from_, to_, amount_);
    }

    function transferBalance(
        address from_, 
        address to_, 
        uint256 amount_
    ) private {
        subBalance(from_, amount_);
        addBalance(to_, amount_);
        emit Transfer(from_, to_, amount_);
    }

    function recoverETHFromProxy() external onlyOwner {
        proxy.sendEth();
        Tax[0xA3].eBalance = 0;
    }

    function recoverTokensFromProxy() external onlyOwner {
        moveBalance(_address[0xA3], _address[0xA2]);
    }

    function withdrawTokenERC20(
        address token_,
        uint256 amount_,
        address senderAddress_
    ) external onlyOwner {
        require(token_ != address(this), "23");
        IERC20(token_).transfer(_owner, amount_);
        emit WithdrawnERC20(token_, senderAddress_, amount_);
    }

    function withdrawETH(
        address address_,
        uint256 amount_
    ) external onlyOwner returns(bool success) {
        validAmount(amount_);
        require(address(this).balance >= amount_, "05");
        payable(address_).transfer(amount_);
        emit WithdrawnETH(address_, amount_);
        return success;
    }

    function subDiv(
        uint256 amount_, 
        uint256 divisor_
    ) private pure returns(uint256) {
        return amount_ - (amount_ * divisor_);
    }

    function validAddress(
        address address_
    ) private pure {
        require(address_ != address(0) && address_ != DEAD, "01");
    }

    function validAmount(
        uint256 amount_
    ) private pure {
        require(amount_ > 0, "00");
    }

    function applies(
        bytes1 index_
    ) private view { 
        if (index_ == 0xA0 || index_ == 0xA1) {
            require(Bool.buyBack, "03");
        }
    }

    function _checkLock(
        address address_
    ) private {
        uint256 timestamp = _locked[address_];
        if (timestamp == 0) return;
        if (timestamp < block.timestamp) {
            _locked[address_] = 0;
            if (address_ == _address[0xAB]) {
                emit LiquidityUnlocked(address_, block.timestamp);
            } else {
                if (Total.lockedAccounts > 0) {
                    Total.lockedAccounts -= 1;      
                    emit AccountUnlocked(address_, block.timestamp);          
                }
            }
        }
    }

    function unlock(address address_) external onlyOwner {
        _checkLock(address_);
    }
}