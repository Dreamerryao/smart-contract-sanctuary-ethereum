// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

import "./RoyaltyEngineV1.sol";
import "./token/ERC721/IERC721Ninfa.sol";
// import "./token/ERC721/utils/ERC721Holder.sol"; // TODO is this import needed? i.e. Will creating orders by sending tokens with data bytes as function parameters be cheaper than the old function (including the fact that approving is not needed anymore)
import "./token/ERC1155/IERC1155.sol";
import "./token/ERC1155/utils/ERC1155Holder.sol";
import "./token/common/IERC2981.sol";
// import "./token/common/IRoyaltyRegistry.sol";
import "./factory/IPaymentSplitterFactory.sol";
import "./factory/INinfaERC1155Factory.sol";
import "./finance/IPaymentSplitter.sol";
import "./utils/introspection/IERC165.sol";
import "./utils/introspection/ERC165Checker.sol";
import "./utils/Counters.sol"; // Counters or CountersUpgradable makes no difference being a library
import "./access/AccessControl.sol";

/**
    ███    ██ ██ ███    ██ ███████  █████  
    ████   ██ ██ ████   ██ ██      ██   ██ 
    ██ ██  ██ ██ ██ ██  ██ █████   ███████ 
    ██  ██ ██ ██ ██  ██ ██ ██      ██   ██ 
    ██   ████ ██ ██   ████ ██      ██   ██                                                                               
 */

/// @custom:security-contact [email protected]
/// @title Ninfa Marketplace v2
contract NinfaMarketplace is
    AccessControl, // {AccessControl} doesn’t allow enumerating role members, whereas {AccessControlEnumerable} allows it. The additional "enumerable" functions are getRoleMember(role, index) and getRoleMemberCount(role). The role member can be enumerated by frontend using events, therefore the enumerable extension is not needed to be read on-chain.
    ERC1155Holder,
    /*ERC721Holder,*/
    RoyaltyEngineV1
{
    /*************
     * VARIABLES *
     ************/

    IERC721Ninfa private NinfaERC721;
    IPaymentSplitterFactory private PaymentSplitterFactory;
    INinfaERC1155Factory private NinfaERC1155Factory;

    using Counters for Counters.Counter; // counters for marketplace offers and orders
    using ERC165Checker for address;
    Counters.Counter private _orderCount; // orders counter
    Counters.Counter private _offerCount; // offers counter

    bytes32 private constant CURATOR_ROLE =
        0x850d585eb7f024ccee5e68e55f2c26cc72e1e6ee456acf62135757a5eb9d4a10; // hardcoded hash equivalent to keccak256("CURATOR_ROLE"); CURATOR_ROLE is the "role admin" of ARTIST_ROLE, i.e. it is the only account that can grant and revoke roles to artists. This was added to avoid having a DEFAULT_ADMIN_ROLE approve artists, which would introduce security risks if different from a multisig, and usability issues if each time a multisig was needed to approve artists.
    bytes32 private constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; // keccak256("MINTER_ROLE"); one or more smart contracts allowed to call the mint function, eg. the Marketplace contract
    bytes4 private constant INTERFACE_ID_ERC2981 = 0x2a55205a; // https://eips.ethereum.org/EIPS/eip-2981

    uint24 private ninfaPrimaryFee; // Ninfa Marketplace fee percentage for primary sales, expressed in basis points. It is not constant because primary sale fees are at 0% for 2022 and will need to be set afterwards to 10%.
    uint24 private constant NINFA_SECONDARY_FEE = 500; // 5% fee on all secondary sales paid to Ninfa (seller receives the remainder after paying 10% royalties to artist/gallery and 5% Ninfa, i.e. 85%)

    address private constant ZERO_ADDRESS = address(0); // placeholder for address(0) todo hardcode 0x00......
    address payable private feeAccount; // EOA or contract where to send trading fees generated by the marketplace

    mapping(address => uint256) private marketplaceFees; // in order to be traded on the Ninfa marketplace, collections need to be manually approved by a multisig contract.
    mapping(uint256 => bool) private secondarySale; // map token Id to bool indicating wether it has been sold before, only applies to the Ninfa collection NFTs, all other collections are considered as secondary sales.
    mapping(uint256 => _Order) public orders; // mapping order id to invoice struct. todo remove the need for public orders getter from database and make this mapping private
    mapping(uint256 => _Offer) private offers; // mapping offer id to invoice struct

    /***********
     * STRUCTS *
     **********/

    /**
     * @param from if invoice is for an order, `from` will correspond to the seller, if it represents an offer, `from` will correspond to the buyer
     * @param to if invoice is for an order, `to` will correspond to the buyer, which is useless as it is not possible to know the buyer upfront.
     * It may be useful for direct sales, for this we need a special `fillOrder` function which requires that `msg.sender == to`.
     * If invoice is for an offer, `to` will correspond to the seller, used for access control of erc1155 because a tokenId can have multiple owners.
     * @param price seller ask or buyer bid
     * @param amount 0 if erc721, other if erc1155
     */
    struct _Order {
        address collection;
        uint256 tokenId;
        address from;
        uint256 price;
        uint256 amount;
        address commissionReceiver; // receiver of commission on sales (primary AND secondary)
        uint256 commissionShares; // commission amount, expressed in basis points 0 - 10000
    }

    struct _Offer {
        address collection;
        uint256 tokenId;
        address from;
        uint256 price;
        uint256 amount;
    }

    struct _Trade {
        uint256 orderId;
        address buyer;
        address payable seller;
        uint256 price;
        uint256 tokenId;
        address collection;
        uint256 amount;
        address commissionReceiver;
        uint256 commissionShares;
    }

    /**********
     * EVENTS *
     *********/

    event Order(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 orderId,
        uint256 price,
        uint256 amount
    );

    event Offer(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 offerId,
        uint256 price,
        uint256 amount
    );

    event OrderCancelled(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 orderId,
        uint256 amount
    );

    event OfferCancelled(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 offerId,
        uint256 amount
    );

    event Trade(_Trade trade);

    /*************
     * MODIFIERS *
     ************/

    /**
     * @notice checks that msg.sender created the order and that the order exists (if it didn't, _order.from would be the 0x0 address)
     */
    modifier isOrderOwner(uint256 _orderId) {
        if (msg.sender != orders[_orderId].from) revert Unauthorized();
        _;
    }

    modifier isOfferOwner(uint256 _offerId) {
        if (msg.sender != offers[_offerId].from) revert Unauthorized(); // this implicitly also checks that the offer exists, since msg.sender cannot be == 0x0
        _;
    }

    modifier isWhitelisted(address _collection) {
        // ERC721 and ERC1155 must be whitelisted.
        // using logical && because they both must be false or else it means it is whitelisted (opposite of require statement that would use a logical ||)
        if (
            marketplaceFees[_collection] == 0 &&
            NinfaERC1155Factory.exists(_collection) == false
        ) revert Unauthorized();
        _;
    }

    modifier isNotNull(uint256 _amount) {
        // protecting the user from mistakenly submitting an order for free
        if (_amount == 0) revert InvalidAmount(_amount);
        _;
    }

    /***********
     * TRADING *
     ***********/

    /**
     * @notice create a new order on the marketplace by transfering an NFT to it.
     * @param _collection address of the ERC721 contract
     * @param _tokenId the NFT id, for now we only allow trading NINFA NFT's so no erc721 address is needed
     * @param _price the NFT's price. for now we support only ETH payments.
     * Require:
     *
     * - collection must be whitelisted
     * - price must be more than 0
     *
     */
    function createOrder(
        address _collection,
        uint256 _tokenId,
        uint256 _price,
        uint256 _amount,
        address _commissionReceiver,
        uint256 _commissionShares,
        address _msgSender // todo any require statements needed ?!
    ) external isWhitelisted(_collection) isNotNull(_price) {
        if (_amount == 0) {
            IERC721Ninfa(_collection).transferFrom(
                _msgSender, // todo review tx.origin for vulns
                address(this),
                _tokenId
            ); // transfer NFT directly to this contract, reverts on failure. Only NFT owner can transfer the token, i.e. call this function. // According to the EIP, the transfer and transferFrom function will revert if the msg.sender is not the owner of the NFT.
        } else {
            IERC1155(_collection).safeTransferFrom(
                msg.sender,
                address(this),
                _tokenId,
                _amount,
                new bytes(0)
            );
        }

        _orderCount.increment(); // start _orderCount at 1
        orders[_orderCount.current()] = _Order(
            _collection,
            _tokenId,
            msg.sender,
            _price,
            _amount,
            _commissionReceiver,
            _commissionShares
        ); // add order to orders mapping

        emit Order(
            _collection,
            _tokenId,
            msg.sender,
            _orderCount.current(),
            _price,
            _amount
        );
    }

    /**
     * @dev offers can be made independently of whether the token is on sale or not, the msg.value is used to determine the offer amount, so no function parameter is needed for that
     * @dev there is no require to check that an offer or offer doesn't already exist and if so, that the offer amount is not greater than the order itself, this was omitted in order to save gas; the frontend should check this in order to prevent mistakes from the user
     * @param _collection address of the erc721 implementation contract or proxy contract
     * @param _tokenId the token Id to make an offer to
     * @param _amount the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     */
    function createOffer(
        address _collection,
        uint256 _tokenId,
        uint256 _amount
    ) external payable isWhitelisted(_collection) isNotNull(msg.value) {
        _offerCount.increment(); // start count at 1

        offers[_offerCount.current()] = _Offer(
            _collection,
            _tokenId,
            msg.sender,
            msg.value,
            _amount
        ); // add offer Struct to offers mapping

        emit Offer(
            _collection,
            _tokenId,
            msg.sender,
            _offerCount.current(),
            msg.value,
            _amount
        );
    }

    /**
     * @dev cancels order and transfers NFT back to owner
     * @param _orderId the Id of the order
     */
    function cancelOrder(uint256 _orderId) external isOrderOwner(_orderId) {
        _Order memory _order = orders[_orderId];

        if (_order.amount == 0) {
            IERC721Ninfa(_order.collection).transferFrom(
                address(this),
                msg.sender,
                _order.tokenId
            ); // transfer NFT back to the owner
        } else {
            IERC1155(_order.collection).safeTransferFrom(
                address(this),
                msg.sender,
                _order.tokenId,
                _order.amount,
                new bytes(0)
            );
        }

        delete orders[_orderId]; // mark order as cancelled forever after event is emitted or else all values emitted will be 0

        emit OrderCancelled(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.amount
        );
    }

    /**
     * @dev cancels offer and refunds ETH back to bidder. When an order gets filled, the offer isn't marked as cancelled, in order to allow users to claim back their money.
     * @param _offerId the Id of the offer.
     */
    function cancelOffer(uint256 _offerId) external isOfferOwner(_offerId) {
        _Offer memory _offer = offers[_offerId]; // in memory copy needed so that it is possible to delete the struct inside the storage offers mapping, while keeping check effects interact pattern intact

        delete offers[_offerId]; // mark offer as cancelled forever, updating offer price before external call, Checks Effects Interactions pattern
        (bool success, ) = payable(_offer.from).call{value: _offer.price}(""); // transfer the offer amount back to bidder
        if (success == false) revert InvalidAmount(_offer.price);

        emit OfferCancelled(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.amount
        );
    }

    function changeOrderPrice(uint256 _orderId, uint256 _newPrice)
        external
        isOrderOwner(_orderId)
        isNotNull(_newPrice)
    {
        _Order storage _order = orders[_orderId];

        _order.price = _newPrice;

        emit Order(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.price,
            _order.amount
        );
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `increaseOffer()` and `decreaseOffer()`, because they expect different parameters depending on whether the offer is being increased or decreased.
     *      A `msg.value` is required, this function will add the amount sent to the old offer amount. The frontend needs to calculate the difference between the old and new offer.
     *      E.g. A buyer calls createOffer() and pays 0.1 ETH. The same buyer later wants to increase the offer to 0.3 ETH, therefore they now need to send 0.2 ETH, because 0.1 was was sent before.
     * @param _offerId the id of the offer
     */
    function increaseOffer(uint256 _offerId)
        external
        payable
        isOfferOwner(_offerId)
        isNotNull(msg.value)
    {
        _Offer storage _offer = offers[_offerId];

        _offer.price += msg.value; // transfer extra amount needed on top of older offer

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            0
        );
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `increaseOffer()` and `decreaseOffer()`, because they expect different parameters depending on whether the offer is being increased or decreased.
     *      In contrast with `increaseOffer()`, instead of `msg.value` this function expects a uint parameter representing the new (lower) offer; the buyer will get refunded the difference.
     *      E.g. A buyer calls createOffer() and pays 0.3 ETH. The same buyer later wants to decrease the offer to 0.1 ETH, therefore they will get refunded 0.2 ETH. I.e. The amount expected by the `_newAmount` paramer is 0.1 ETH (1^17).
     * @param _offerId the id of the offer
     * @param _newPrice the new offer amount in Ether, NOT the difference with the previous offer, just the new (lower) offer amount. E.g. 1 ETH = 1^18.
     */
    function decreaseOffer(uint256 _offerId, uint256 _newPrice)
        external
        isOfferOwner(_offerId)
        isNotNull(_newPrice)
    {
        _Offer storage _offer = offers[_offerId];
        if (_newPrice > _offer.price) revert InvalidAmount(_newPrice);

        uint256 _refund = _offer.price - _newPrice; // needed to store result before offer price is updated
        _offer.price = _newPrice; // updating offer price before external call, Checks Effects Interactions pattern

        (bool success, ) = payable(msg.sender).call{value: _refund}(""); // transfer the difference between old and new lower offer to the user
        if (success == false) revert InvalidAmount(_refund);

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            0
        );
    }

    function changeOrderAmount(uint256 _orderId, uint256 _newAmount)
        external
        payable
        isOrderOwner(_orderId)
        isNotNull(_newAmount)
    {
        _Order storage _order = orders[_orderId];

        _order.amount = _newAmount;

        emit Order(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.price,
            _newAmount
        );
    }

    /**
     * @dev to be called only for ERC1155 tokens, having a separate function costs less gas than having a generic function for both ERCs in this case
     * @param _newAmount can be any uint except for 0 or the same amount as the previous offer; since the amount is unchanged it will not require any extra logic, therefore `increaseOffer()` must be called for erc1155 instead
     *  it is not enforced that _newAmount == _offer.amount because it isn't a security issue, however the frontend should disallow this in order to avoid wasting eth
     */
    function changeOfferAmount(uint256 _offerId, uint256 _newAmount)
        external
        payable
        isOfferOwner(_offerId)
        isNotNull(_newAmount)
    {
        _Offer storage _offer = offers[_offerId];

        _offer.amount = _newAmount;

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            _newAmount
        );
    }

    /**
     * @notice the collector calls this function to buy an NFT at the ask price, only if an order exists
     * @notice if someone has an open offer but calls fillOrder, the offer will remain open, meaning they will need to call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in order to pay for part of the order.
     * @param _orderId avoids having to store a mapping to order id like the deprecated `mapping(address => mapping(uint256 => uint256)) private _tokenToOrderId` which would have not worked for erc1155 as each token has a supply.
     *        _orderId does not constitute a vulnerability as it is user provided, since A) a regular user will go through the frontend which gets orderId from events
     * @param _msgSender needed in order to integrate Wert payment solution, although using msg.sender would cost less gas.
     *        using _msgSender does not represent a security risk, on the other hand, it is possible for the buyer to use this parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external contract buying NFTs.
     */
    function fillOrder(uint256 _orderId, address _msgSender) external payable {
        _Order memory _order = orders[_orderId];
        // checking that the order wasn't deleted or filled and that the order exists
        // In the EVM, there is an opcode for < and one for >, but not for <= or >=.
        // That is why `msg.value == orders[_orderId].price` is better than `msg.value >= orders[_orderId].price`.

        // it is not required to check that _order.price is more than 0, because that's already being checked when creating an order
        if (msg.value != _order.price) revert InvalidAmount(msg.value);

        _Trade memory trade = _Trade(
            _orderId,
            _msgSender,
            payable(_order.from),
            _order.price,
            _order.tokenId,
            _order.collection,
            _order.amount,
            _order.commissionReceiver,
            _order.commissionShares
        );

        _trade(trade);
    }

    /**
     * @dev this function can only be called by the owner of the NFT for sale, i.e. the address that created the order.
     * Eg. the order creator may be happy with an offer amount, so they call acceptOffer() passing in the offer Id as the only parameter;
     * the internal _trade() function will get called, where this smart contract will send the offer amount to the seller (minus fees) and send the NFT to the buyer.
     * @param _orderId If there is no order, the Id will be set to 0, else the order will be marked as filled by the _trade() function, orderFilled[_orderId] = true;
     * this is needed to delete the order from storage when calling _trade() if there is any, and to check that msg.sender is the owner of the nft
     *
     * Required:
     *
     * - caller must be token owner, or else transferFrom will revert, this also means that _offerId must exist or else it will revert.
     *   the _seller paramteter passed to trade() will be msg.sender, the marketplace will therefore try to transfer the tokenId (amount) to the offer maker/buyer on behalf of msg.sender.
     *   i.e. although the transferFrom checks `require(_isApprovedOrOwner(_msgSender(), tokenId))` and the marketplace is indeed approved, it can only transfer on behalf of msg.sender.
     *   Note Consider what would happen if the erc implementation does not revert upon failed transfers though! given that Ninfa has no control over all of the accepted collections' implementations, there is no guarantee that the collection will follow the standard.
     *
     */
    function acceptOffer(
        uint256 _offerId,
        uint256 _orderId,
        address _commissionReceiver,
        uint256 _commissionShares,
        address _msgSender // todo any access control needed??
    ) external {
        _Offer memory _offer = offers[_offerId]; // creating an additional variable in this particular case is cheaper than calling `offers[_offerId].something` each time. See https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/#avoid-additional-variables

        delete offers[_offerId]; // mark offer as cancelled forever, so that user's can't claim a refund after their offer gets accepted

        _Trade memory trade = _Trade(
            _orderId, // uint256 orderId
            _offer.from, // address buyer
            payable(_msgSender), // address seller
            _offer.price, // uint256 price
            _offer.tokenId, // uint256 tokenId
            _offer.collection, // address collection
            _offer.amount, // uint256 amount
            _commissionReceiver, // address commissionReceiver
            _commissionShares // uint256 commissionShares
        );

        _trade(trade); // we are passing offer amount instead of order price as function parameter
    }

    function _transferNFT(
        address _collection,
        address _seller,
        address _buyer,
        uint256 _tokenId,
        uint256 _amount
    ) private {
        if (_amount == 0)
            IERC721Ninfa(_collection).transferFrom(_seller, _buyer, _tokenId);
        else
            IERC1155(_collection).safeTransferFrom(
                _seller,
                _buyer,
                _tokenId,
                _amount,
                ""
            );
    }

    /**
     * param _orderId order Id
     * param _buyer order or offer creator, depending on who `msg.sender` is
     * param _price NFT's price
     * param _tokenId NFT's Id
     */
    function _trade(
        _Trade memory trade // uint256 trade.orderId, // address trade.buyer, // address trade.seller, // uint256 trade.price, // uint256 trade.tokenId, // address trade.collection, // uint256 trade.amount, // address commissionReceiver, // uint256 trade.commissionShares
    ) private {
        uint256 sellerAmount = trade.price;
        uint256 marketplaceAmount;
        address royaltyReceiver;
        uint256 royaltyAmount;
        uint256 commissionAmount = (trade.price * trade.commissionShares) /
            10000;

        /*******************
         * Local Variables *
         ******************/
        bool success;

        /*************************
         * Transfer NFT to buyer *
         ************************/

        if (trade.orderId != 0) {
            // since there is an order, the marketplace is the owner of the nft, then it will transfer the nft to the buyer without complaining.
            // therefore the msg.sender must be equal to the order creator in order to prove they are the legitimate owner.
            // require(
            //     msg.sender == orders[trade.orderId].from,
            //     "NM: sender is not order creator"
            // ); // TODO what if fillOrder is called and the sender is NOT the order creator!!!!
            // if trade.orderId is different from 0, then automatically the order exists because otherwise the mapping would be deleted, i.e. no need to check the order is valid
            // Orders may exist simultaneously as offers, therefore if the `delete` directive was placed only inside the `fillOrder()`, the order would not be deleted when fulfilling an order via `acceptOffer()`.
            delete orders[trade.orderId];

            // emit OrderCancelled(
            //     _order.collection,
            //     _order.tokenId,
            //     msg.sender,
            //     _orderId,
            //     _order.amount
            // );

            // if `trade.orderId` is different from 0, there is an order, i.e. the marketplace is the owner of the NFT, therefore the `from` parameter must be the marketplace's address
            // if `trade.orderId` is 0, there is no order, i.e. the marketplace is NOT the owner of the nft, therefore the `from` parameter must be the seller's address, i.e. whoever called acceptOffer()
            // `trade.orderId` will be 0 when `_trade()` is called by `acceptOffer()` AND no order exists corresponding to the token for which the offer was made
            _transferNFT(
                trade.collection,
                address(this),
                trade.buyer,
                trade.tokenId,
                trade.amount
            );
        } else {
            _transferNFT(
                trade.collection,
                trade.seller,
                trade.buyer,
                trade.tokenId,
                trade.amount
            );
        }

        // 1155 cannot be a primary sale because it is impossible to track each fungible tokenId supply
        // todo consider if we need to trade the erc721 v1 of the contract's address. It can't be whitelised so it might need a new variable to store its address, or to add a nested mapping in secondarySale containging collection => tokenId
        // however then how would I know if the tokenId for erc721 v1 is a primary sale or not. todo I should upgrade v1 to make secondarySale public (right now is private). This could be a good solution going forward, for when there will be a v3.
        if (
            trade.collection == address(NinfaERC721) &&
            !secondarySale[trade.tokenId]
        ) {
            /****************************************************
             * If Primary Sale ( i.e. a Ninfa ERC721 Contract ) *
             ***************************************************/

            // primary sales exist only for Ninfa Collection
            // overrides the `marketplaceAmount` that is by default calculated using NINFA_SECONDARY_FEE. There is a separate if case should fees be set to 0, in order to avoid dividing 0 by 10000 which would revert the transaction.
            // if the primary fee is 0, it won't revert, but rather the final result will be 0. Since fees are 0% unly until 2023, an if statement might save a little gas now but waste it after primary fees are set.
            marketplaceAmount = (trade.price * ninfaPrimaryFee) / 10000;

            secondarySale[trade.tokenId] = true; // Set secondarySale bool to true after first sale on NinfaMarketplace.
        } else {
            /***************************************************
             * If Secondary Sale ( includes erc1155 contracts ) *
             ***************************************************/

            /*******************
             * Royalty Engine V1 *
             *******************/

            // if (trade.collection.supportsERC165Interface(INTERFACE_ID_ERC2981)) {
            //     (royaltyReceiver, royaltyAmount) = IERC2981(
            //         trade.collection
            //     ).royaltyInfo(trade.tokenId, trade.price); // If the collection supports the ERC-2981 royalties interface, store the receiver address and amount in memory.
            // }

            (royaltyReceiver, royaltyAmount) = getRoyalty(
                trade.collection,
                trade.tokenId,
                trade.price
            );

            // todo check that the royalty amount returned is below a certain threshold? getRoyalty already checks that royaltyAmount < price

            sellerAmount -= royaltyAmount; // Only subtract `royaltyAmount` if secondary sale. This assignment indirectly checks that: `royaltyAmount < (trade.price - marketplaceAmount)`, otherwise it would revert. This guarantees that external NFTs' royalties do not overflow!

            // collection fees are not being added for erc1155 when the new collection is deployed, this would result in 0% fees for collections
            // for this reason address(NinfaERC721) is used as a placeholder for both NinfaERC721 and for all Ninfa self sovereign erc1155 collections
            // i.e. the following conditional evaluates if the collection being traded has been whitelisted (NinfaERC721 or external collection),
            // then it reads the fee amount corresponding to the collection's address from the marketplaceFees mapping, else it reads the fee amount corresponding to the NinfaERC721 address in the marketplaceFees mapping (5% or 500bps). It has not been hardcoded in case Ninfa wants to change this at any point.
            marketplaceAmount =
                (trade.price *
                    (
                        marketplaceFees[trade.collection] > 0
                            ? marketplaceFees[trade.collection]
                            : marketplaceFees[address(NinfaERC721)]
                    )) /
                10000;

            /*****************
             * Pay Royalties *
             ****************/

            // if `royaltyAmount == (trade.price - marketplaceAmount)` then `sellerAmount == 0` which is default. This means that 0 value payments may happen, which is ok. That is why we aren't requiring that `royaltyAmount > 0` either.
            // Neither it is required that `royaltyReceiver != ZERO_ADDRESS`, this would be an error on the part of whoever programmed the NFT, but it doesn't represent any security issues for the Marketplace.
            // For NinfaERC721 all  tokens will have a receiver and fixed 10% royalties. I.e. if the token exists, its royalties also exist.

            (success, ) = royaltyReceiver.call{value: royaltyAmount}("");
            if (success == false) revert InvalidAmount(royaltyAmount);

            // emit RoyaltyPayment(
            //     trade.collection,
            //     trade.tokenId,
            //     royaltyReceiver,
            //     royaltyAmount
            // );
        }

        sellerAmount -= marketplaceAmount; // subtracting primary or secondary fee amount (may be 0 for primaries).

        /***************************
         * Pay seller commissions *
         **************************/

        if (commissionAmount > 0) {
            // if (trade.seller == commissionReceiver) {
            //     // this condition MUST only be triggered if the trade is a primary sale, i.e. it is a Ninfa NFT, i.e. there will always be a `royaltyReceiver` for every artist so that they can get paid.
            //     // there seller MAY also be the commissionReceiver during a secondary sale, e.g. a gallery selling an external collection for the first time on ninfa.
            //     // commissionReceiver = trade.seller;
            //     trade.seller = royaltyReceiver;
            //     // delete _saleCommissions[trade.collection][trade.tokenId];
            // }

            sellerAmount -= commissionAmount;

            // commission details emitted in Trade event
            (success, ) = trade.commissionReceiver.call{
                value: commissionAmount
            }("");
            if (success == false) revert InvalidAmount(commissionAmount);
        }

        /**********************************************
         * Pay marketplace fee (primary or secondary) *
         *********************************************/

        (success, ) = feeAccount.call{value: marketplaceAmount}("");
        if (success == false) revert InvalidAmount(marketplaceAmount);

        /**************
         * Pay seller *
         *************/
        (success, ) = trade.seller.call{value: sellerAmount}(""); /*(trade.price - marketplaceAmount - royaltyAmount)*/
        if (success == false) revert InvalidAmount(sellerAmount);

        emit Trade(trade);
    }

    /*******************
     * ADMIN FUNCTIONS *
     ******************/

    /**
     * @notice setter function only callable by contract admin used to change any or all addresses used by the Marketplace,
     * @dev if only one address needs to be set, make sure you are passing all other past addresses as parameters
     * @dev the reason there is only one setter function rather many is to save bytecode, because the Marketplace is very close to contract size limit
     * @param _feeAccount is the address owned by NINFA that will collect sales fees
     */
    function initAddresses(
        address _ninfaErc721,
        address _feeAccount,
        address _ninfaErc1155Factory,
        address _paymentSplitterFactory
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // set address for receiving marketplace fees
        feeAccount = payable(_feeAccount);
        // set address of ERC1155 factory
        NinfaERC1155Factory = INinfaERC1155Factory(_ninfaErc1155Factory);
        // set address of PaymentSplitter factory
        PaymentSplitterFactory = IPaymentSplitterFactory(
            _paymentSplitterFactory
        );
        // set address of NINFA ERC721 communal collection
        NinfaERC721 = IERC721Ninfa(_ninfaErc721);
        // adds NinfaERC721 to whitelist for access control in `isWhitelisted` modifier, also sets secondary fees for NinfaERC721 and all NinfaERC1155 to 5%. In order to reset secondary fees call whitelistCollection() from an ADMIN_ROLE address
        marketplaceFees[_ninfaErc721] = NINFA_SECONDARY_FEE;
        // todo set address of NinfaERC721v1 or add it to whitelist for trading?
        // todo emit event to store this info
    }

    /**
     * @notice whitelist collection to be traded on marketplace
     * @dev this function needs to be called immediately after deployment in order to set marketplace fees for NinfaERC721 to 500bps or 5%. Required for access control by `isWhitelisted` modifier, also required in order to set secondary sales fees for NinfaERC721 and all NinfaERC1155 to 5%.
     * @param _collection address of collection ERC721 or ERC1155
     * @param _collectionFees adds a uint to a mapping, if uint is positive the isWhitelisted modifier will return true, the uint corresponds to the secondary fee basis points, the maximum should be < 8501.
     */
    function whitelistCollection(address _collection, uint256 _collectionFees)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        marketplaceFees[_collection] = _collectionFees;
    }

    /**
     * @notice sets primary sale fees for NinfaERC721 communal collection.
     * @dev primary fees may be 0%, this is the default when not set.
     */
    function setPrimaryFee(uint24 _feeBps)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        ninfaPrimaryFee = _feeBps;
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, to the deployer and grants CURATOR_ROLE admin role of ARTIST_ROLE
     * @dev after deployment need to manually call setErc1155Factory and setPaymentSplitterFactory.
     * @param _royaltyRegistry see https://royaltyregistry.xyz/lookup for public addresses
     */
    constructor(address _royaltyRegistry) RoyaltyEngineV1(_royaltyRegistry) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MINTER_ROLE, CURATOR_ROLE);
    }

    /***************************
     * EXTERNAL VIEW FUNCTIONS *
     **************************/

    /**
     * @dev See {IERC165-supportsInterface}.
     * @dev supportsInterface is only needed to signal support for onERC1155Received, not onERC721Received. The interface is probably needed because a contract may implement onERC1155Received, onERC1155BatchReceived, or both. See https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828
     */
    function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return
            interfaceId == 0x01ffc9a7 || // Interface ID for IERC165
            interfaceId == 0xf23a6e61; // NOTE bytes4 for `this.onERC1155Received.selector`, normally it would be `type(IERC1155Receiver).interfaceId` which includes the selector for `onERC1155BatchReceived`, but the marketplace doesn't support that function (yet?)
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)

pragma solidity 0.8.16;

import "./IERC165.sol";

/**
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165Checker {
    /**
     * @notice Query if a contract implements an interface, does not check ERC165 support
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return true if the contract at account indicates support of the interface with
     * identifier interfaceId, false otherwise
     * @dev Assumes that account contains a contract that supports ERC165, otherwise
     * the behavior of this method is undefined. This precondition can be checked
     * with {supportsERC165}.
     * Interface identification is specified in ERC-165.
     */
    function supportsERC165Interface(address account, bytes4 interfaceId)
        internal
        view
        returns (bool)
    {
        bytes memory encodedParams = abi.encodeWithSelector(
            IERC165.supportsInterface.selector,
            interfaceId
        );
        (bool success, bytes memory result) = account.staticcall{gas: 30000}(
            encodedParams
        );
        if (result.length < 32) return false;
        return success && abi.decode(result, (bool));
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library SuperRareContracts {
    address internal constant SUPERRARE_REGISTRY =
        0x17B0C8564E53f22364A6C8de6F7ca5CE9BEa4e5D;
    address internal constant SUPERRARE_V1 =
        0x41A322b28D0fF354040e2CbC676F0320d8c8850d;
    address internal constant SUPERRARE_V2 =
        0xb932a70A57673d89f4acfFBE830E8ed7f75Fb9e0;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)

pragma solidity 0.8.16;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length)
        internal
        pure
        returns (string memory)
    {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

/**
 * @title Counters
 * @dev Stripped down version of OpenZeppelin Contracts v4.4.1 (utils/Counters.sol), identical to CountersUpgradeable.sol being a library. Provides counters that can only be incremented. Used to track the total supply of ERC721 ids.
 * @dev Include with `using Counters for Counters.Counter;`
 */
library Counters {
    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    /// @dev if implementing ERC721A there could be an overflow risk by removing overflow protection with `unchecked`, unless we limit the amount of tokens that can be minted, or require that totalsupply be less than 2^256 - 1
    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

/// @dev Interface for the NFT Royalty Standard
interface IERC2981 {
    /// @notice Called with the sale price to determine how much royalty
    //          is owed and to whom.
    /// @param _tokenId - the NFT asset queried for royalty information
    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId
    /// @return receiver - address of who should be sent the royalty payment
    /// @return royaltyAmount - the royalty payment amount for _salePrice
    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
        external
        view
        returns (address receiver, uint256 royaltyAmount);

    function setRoyaltyReceiver(address _royaltyReceiver) external;
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

interface IERC721Ninfa {
    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev {ERC721Ninfa-mint}
     */
    function mint(bytes32 _tokenURI, address _msgSender) external;

    // function mintAndSetRoyaltyReceiver(
    //     bytes32 _tokenURI,
    //     address _msgSender,
    //     address _royaltyReceiver
    // ) external;

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    function exists(uint256 _id) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

/**
 * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens, but the onERC1155BatchReceived was removed.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 *
 */
contract ERC1155Holder {
    /**
     *
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * param operator The address which initiated the transfer (i.e. msg.sender)
     * param from The address which previously owned the token
     * param id The ID of the token being transferred
     * param value The amount of tokens being transferred
     * param data Additional data with no specified format
     * return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return 0xf23a6e61; // this.onERC1155Received.selector
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(
        address indexed account,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        external
        view
        returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;

    function totalSupply() external view returns (uint256);

    function mint(
        address _to,
        bytes32 _tokenURI,
        uint256 _amount,
        bytes memory _data
    ) external;
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * Paired down version of the Zora Market interface
 */
interface IZoraMarket {
    struct ZoraDecimal {
        uint256 value;
    }

    struct ZoraBidShares {
        // % of sale value that goes to the _previous_ owner of the nft
        ZoraDecimal prevOwner;
        // % of sale value that goes to the original creator of the nft
        ZoraDecimal creator;
        // % of sale value that goes to the seller (current owner) of the nft
        ZoraDecimal owner;
    }

    function bidSharesForToken(uint256 tokenId) external view returns (ZoraBidShares memory);
}

/**
 * Paired down version of the Zora Media interface
 */
interface IZoraMedia {

    /**
     * Auto-generated accessors of public variables
     */
    function marketContract() external view returns(address);
    function previousTokenOwners(uint256 tokenId) external view returns(address);
    function tokenCreators(uint256 tokenId) external view returns(address);

    /**
     * ERC721 function
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);
}

/**
 * Interface for a Zora media override
 */
interface IZoraOverride {

    /**
     * @dev Convert bid share configuration of a Zora Media token into an array of receivers and bps values
     *      Does not support prevOwner and sell-on amounts as that is specific to Zora marketplace implementation
     *      and requires updates on the Zora Media and Marketplace to update the sell-on amounts/previous owner values.
     *      An off-Zora marketplace sale will break the sell-on functionality.
     */
    function convertBidShares(address media, uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface ISuperRareRegistry {
    /**
     * @dev Get the royalty fee percentage for a specific ERC721 contract.
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     * @return uint8 wei royalty fee.
     */
    function getERC721TokenRoyaltyPercentage(
        address _contractAddress,
        uint256 _tokenId
    ) external view returns (uint8);

    /**
     * @dev Utililty function to calculate the royalty fee for a token.
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     * @param _amount uint256 wei amount.
     * @return uint256 wei fee.
     */
    function calculateRoyaltyFee(
        address _contractAddress,
        uint256 _tokenId,
        uint256 _amount
    ) external view returns (uint256);

    /**
     * @dev Get the token creator which will receive royalties of the given token
     * @param _contractAddress address ERC721Contract address.
     * @param _tokenId uint256 token ID.
     */
    function tokenCreator(address _contractAddress, uint256 _tokenId)
        external
        view
        returns (address payable);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IRaribleV1 {
    /*
     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f
     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb
     *
     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584
     */
    function getFeeBps(uint256 id) external view returns (uint[] memory);
    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);
}


interface IRaribleV2 {
    /*
     *  bytes4(keccak256('getRaribleV2Royalties(uint256)')) == 0xcad96cca
     */
    struct Part {
        address payable account;
        uint96 value;
    }
    function getRaribleV2Royalties(uint256 id) external view returns (Part[] memory);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @author: manifold.xyz

/**
 * @dev Royalty interface for creator core classes
 */
interface IManifold {

    /**
     * @dev Get royalites of a token.  Returns list of receivers and basisPoints
     *
     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6
     *
     *  => 0xbb3bafd6 = 0xbb3bafd6
     */
    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);
}

// SPDX-License-Identifier: MIT

/// @author: knownorigin.io

pragma solidity ^0.8.0;

interface IKODAV2 {
    function editionOfTokenId(uint256 _tokenId) external view returns (uint256 _editionNumber);

    function artistCommission(uint256 _editionNumber) external view returns (address _artistAccount, uint256 _artistCommission);

    function editionOptionalCommission(uint256 _editionNumber) external view returns (uint256 _rate, address _recipient);
}

interface IKODAV2Override {

    /// @notice Emitted when the royalties fee changes
    event CreatorRoyaltiesFeeUpdated(uint256 _oldCreatorRoyaltiesFee, uint256 _newCreatorRoyaltiesFee);

    /// @notice For the given KO NFT and token ID, return the addresses and the amounts to pay
    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)
    external
    view
    returns (address payable[] memory, uint256[] memory);

    /// @notice Allows the owner() to update the creator royalties
    function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external;
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IFoundation {
    /*
     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c
     *
     *  => 0xd5a06d4c = 0xd5a06d4c
     */
    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);
}

interface IFoundationTreasuryNode {
    function getFoundationTreasury() external view returns (address payable);
}

interface IFoundationTreasury {
    function isAdmin(address account) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * EIP-2981
 */
interface IEIP2981 {
    /**
     * bytes4(keccak256("royaltyInfo(uint256,uint256)")) == 0x2a55205a
     *
     * => 0x2a55205a = 0x2a55205a
     */
    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 *  Interface for an Art Blocks override
 */
interface IArtBlocksOverride {
    /**
     * @dev Get royalites of a token at a given tokenAddress.
     *      Returns array of receivers and basisPoints.
     *
     *  bytes4(keccak256('getRoyalties(address,uint256)')) == 0x9ca7dc7a
     *
     *  => 0x9ca7dc7a = 0x9ca7dc7a
     */
    function getRoyalties(address tokenAddress, uint256 tokenId)
        external
        view
        returns (address payable[] memory, uint256[] memory);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

interface IPaymentSplitter {
    function totalShares() external view returns (uint256);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

interface IPaymentSplitterFactory {
    function deployClone(
        address[] calldata payees,
        uint256[] calldata shares,
        address msgSender
    ) external returns (address clone);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

interface INinfaERC1155Factory {
    function exists(address _instance) external view returns (bool);

    function deployClone(
        string calldata _name,
        string calldata _symbol,
        address _msgSender,
        uint256 _salt
    ) external returns (address clone);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)

pragma solidity 0.8.16;

import "../utils/Strings.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(uint160(account), 20),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account)
        external
        onlyRole(getRoleAdmin(role))
    {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account)
        external
        onlyRole(getRoleAdmin(role))
    {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external {
        require(
            account == msg.sender,
            "AccessControl: can only renounce roles for self"
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     */
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     */
    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

import "./utils/SuperRareContracts.sol";

import "./specs/IManifold.sol";
import "./specs/IRarible.sol";
import "./specs/IFoundation.sol";
import "./specs/ISuperRare.sol";
import "./specs/IEIP2981.sol";
import "./specs/IZoraOverride.sol";
import "./specs/IArtBlocksOverride.sol";
import "./specs/IKODAV2Override.sol";
import "./IRoyaltyRegistry.sol";

/**
 * @dev Trimmed down implementation RoyaltyEngineV1 by manifold.xyz - https://github.com/manifoldxyz/royalty-registry-solidity
 * @dev Marketplaces may choose to directly inherit the Royalty Engine to save a bit of gas (from our testing, a possible savings of 6400 gas per lookup).
 * @dev ERC165 was removed because we removed all functions and modified return parameters of `getRoyalty`, thus no function interface is the same as before (0xcb23f816).
 */
contract RoyaltyEngineV1 {

    /**
     * @dev The Royalty Registry is an on chain contract that is responsible for storing Royalty configuration overrides.
     * A reference EIP2981 override implementation can be found here: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/overrides/RoyaltyOverride.sol.
     * An upgradeable version of both the Royalty Registry and Royalty Engine (v1) has been deployed for public consumption. There should only be one instance of the Royalty Registry (in order to ensure that people who wish to override do not have to do so in multiple places), while many instances of the Royalty Engine can exist.
     * @dev the original contract was modified in order to remove the need for a constructor, as the royalty registry address is public and immutable (it's an upgradable proxy)
     */
    address internal immutable ROYALTY_REGISTRY;
    

    error Unauthorized();
    error InvalidAmount(uint256 amount);
    error LengthMismatch(uint256 recipients, uint256 bps); // only used in RoyaltyEngineV1
    
    /**
     * Get the royalties for a given token and sale amount. 
     *
     * @param tokenAddress - address of token
     * @param tokenId - id of token
     * @param value - sale value of token
     * Returns two arrays, first is the list of royalty recipients, second is the amounts for each recipient.
     */
    function getRoyalty(
        address tokenAddress,
        uint256 tokenId,
        uint256 value
    )
        internal
        view
        returns (address payable/*[] memory*/ recipient, uint256/*[] memory*/ amount)
    {
        // External call to limit gas
        try
            /// @dev The way in which RoyaltyEngineV1.getRoyalty is constructed is too trusting by default given that it calls out to a registry of contracts that are user-settable without any restriction on their functionality, and therefore allows for different kinds of attacks for any marketplace that does not explicitly guard itself from gas griefing, control flow hijack or out of gas attacks.
            ///     To mitigate the griefing vector and other potential vulnerabilities, I suggest to limit the gas by default that _getRoyalty is given to an amount that no reasonable use of the RoyaltyRegistry should exceed - in my opinion at most 50,000 gas, but certainly no more than 100,000 gas.
            ///     I would suggest also to use .staticcall by default when calling out to the untrusted royalty-info supplying addresses, as no one should be modifying state within a Royalty*Lookup* context, and that would also by default prevent reentrancy.
            ///     to limit gas effectively it's necessary to limit it when calling into your own trusted function, then calling from that trusted function to an untrusted function
            ///     source: https://githubrecord.com/issue/manifoldxyz/royalty-registry-solidity/17/1067105243
            this._getRoyalty{gas: 100000}(tokenAddress, tokenId, value)
        returns (
            address payable[] memory _recipients,
            uint256[] memory _amounts
        ) {
            recipient = _recipients[0];
            amount = _amounts[0];
        } catch {
            revert InvalidAmount(amount);
        }
    }

    /**
     * @dev Get the royalty for a given token
     * @dev the original RoyaltyEngineV1 has been modified by removing the _specCache and the associated code,
     * using try catch statements is very cheap, no need to store `_specCache` mapping, see {RoyaltyEngineV1-_specCache}. Reference: https://www.reddit.com/r/ethdev/comments/szot8r/comment/hy5vsxb/?utm_source=share&utm_medium=web2x&context=3
     * returns recipients array, amounts array, royalty address
     */
    function _getRoyalty(
        address tokenAddress,
        uint256 tokenId,
        uint256 value
    )
        external
        view
        returns (
            address payable[] memory recipients,
            uint256[] memory amounts
        )
    {
        if (msg.sender != address(this) ) revert Unauthorized();

        address royaltyAddress = IRoyaltyRegistry(ROYALTY_REGISTRY)
            .getRoyaltyLookupAddress(tokenAddress);

        try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (
            address recipient,
            uint256 amount
        ) {
            // Supports EIP2981.  Return amounts
            if (amount > value ) revert InvalidAmount(amount); // note doesn't revert if amount == value
            recipients = new address payable[](1);
            amounts = new uint256[](1);
            recipients[0] = payable(recipient);
            amounts[0] = amount;
            return (
                recipients,
                amounts
            );
        } catch { }

        // SuperRare handling
        if (
            tokenAddress == SuperRareContracts.SUPERRARE_V1 ||
            tokenAddress == SuperRareContracts.SUPERRARE_V2
        ) {
            try
                ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY)
                    .tokenCreator(tokenAddress, tokenId)
            returns (address payable creator) {
                try
                    ISuperRareRegistry(
                        SuperRareContracts.SUPERRARE_REGISTRY
                    ).calculateRoyaltyFee(tokenAddress, tokenId, value)
                returns (uint256 amount) {
                    recipients = new address payable[](1);
                    amounts = new uint256[](1);
                    recipients[0] = creator;
                    amounts[0] = amount;
                    return (
                        recipients,
                        amounts
                    );
                } catch {}
            } catch {}
        }

        try IManifold(royaltyAddress).getRoyalties(tokenId) returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Supports manifold interface.  Compute amounts
            if(recipients_.length != bps.length) revert LengthMismatch(recipients_.length, bps.length);
            return (
                recipients_,
                _computeAmounts(value, bps)
            );
        } catch {}

        try
            IRaribleV2(royaltyAddress).getRaribleV2Royalties(tokenId)
        returns (IRaribleV2.Part[] memory royalties) {
            // Supports rarible v2 interface. Compute amounts
            recipients = new address payable[](royalties.length);
            amounts = new uint256[](royalties.length);
            uint256 totalAmount;
            for (uint256 i = 0; i < royalties.length; i++) {
                recipients[i] = royalties[i].account;
                amounts[i] = (value * royalties[i].value) / 10000;
                totalAmount += amounts[i];
            }
            if (totalAmount > value ) revert InvalidAmount(totalAmount);
            return (
                recipients,
                amounts
            );
        } catch {}
        try IRaribleV1(royaltyAddress).getFeeRecipients(tokenId) returns (
            address payable[] memory recipients_
        ) {
            // Supports rarible v1 interface. Compute amounts
            recipients_ = IRaribleV1(royaltyAddress).getFeeRecipients(
                tokenId
            );
            try IRaribleV1(royaltyAddress).getFeeBps(tokenId) returns (
                uint256[] memory bps
            ) {
                if(recipients_.length != bps.length) revert LengthMismatch(recipients_.length, bps.length);
                return (
                    recipients_,
                    _computeAmounts(value, bps)
                );
            } catch {}
        } catch {}
        try IFoundation(royaltyAddress).getFees(tokenId) returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Supports foundation interface.  Compute amounts
            if(recipients_.length != bps.length) revert LengthMismatch(recipients_.length, bps.length);
            return (
                recipients_,
                _computeAmounts(value, bps)
            );
        } catch {}
        try
            IZoraOverride(royaltyAddress).convertBidShares(
                tokenAddress,
                tokenId
            )
        returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Support Zora override
            if(recipients_.length != bps.length) revert LengthMismatch(recipients_.length, bps.length);
            return (
                recipients_,
                _computeAmounts(value, bps)
            );
        } catch {}
        try
            IArtBlocksOverride(royaltyAddress).getRoyalties(
                tokenAddress,
                tokenId
            )
        returns (
            address payable[] memory recipients_,
            uint256[] memory bps
        ) {
            // Support Art Blocks override
            if(recipients_.length != bps.length) revert LengthMismatch(recipients_.length, bps.length);
            return (
                recipients_,
                _computeAmounts(value, bps)
            );
        } catch {}
        try
            IKODAV2Override(royaltyAddress).getKODAV2RoyaltyInfo(
                tokenAddress,
                tokenId,
                value
            )
        returns (
            address payable[] memory _recipients,
            uint256[] memory _amounts
        ) {
            // Support KODA V2 override
            if(_recipients.length != _amounts.length) revert LengthMismatch(_recipients.length, _amounts.length);
            return (
                _recipients,
                _amounts
            );
        } catch {}

        // No supported royalties configured
        return (recipients, amounts);

    }

    /**
     * Compute royalty amounts
     */
    function _computeAmounts(uint256 value, uint256[] memory bps)
        private
        pure
        returns (uint256[] memory amounts)
    {
        amounts = new uint256[](bps.length);
        uint256 totalAmount;
        for (uint256 i = 0; i < bps.length; i++) {
            amounts[i] = (value * bps[i]) / 10000;
            totalAmount += amounts[i];
        }
        if (totalAmount > value ) revert InvalidAmount(totalAmount);
        return amounts;
    }

    constructor(address _royaltyRegistry) {
        ROYALTY_REGISTRY = _royaltyRegistry;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

/// @author: manifold.xyz

/**
 * @dev Royalty registry interface. Modified to include only used functions, in this case only used by marketplace in order to getRoyaltyLookupAddress.
 */
interface IRoyaltyRegistry {
    /**
     * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists
     *
     * @param tokenAddress    - The token address you are looking up the royalty for
     */
    function getRoyaltyLookupAddress(address tokenAddress)
        external
        view
        returns (address);
}