// SPDX-License-Identifier: MIT


pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";

error Lottery__NotEnoughETHEntered();
error Interval__inexistent();

contract LotteryVar3 is KeeperCompatibleInterface {

uint[] intervals = [30,60,100];

// key=id game val=numar de adrese in joc
mapping(uint => uint) public countPlayers;
mapping(uint => mapping(uint => address)) public playersInGames;
mapping(uint => uint) gamesIntervals;

uint public s_lastTimestamp;
// uint public immutable i_interval;
uint s_gameId;
uint s_winnerId = 2;
uint[] gamesIds;
uint public interval1;
uint public interval2;
uint public interval3;





constructor () {
    // i_interval = interval;
    s_lastTimestamp = block.timestamp;
}

 //KEEPERS FUNC
    function checkUpkeep(bytes calldata  checkData ) external view override returns (bool upkeepNeeded, bytes memory performData ) {
        bool interval = false;
        for(uint i = 0; i<intervals.length; i++){
          if(intervals[i] == block.timestamp - s_lastTimestamp){
            interval = true;
          }else{
            interval = false;
          }
        }

        upkeepNeeded = interval;

        //The checkData is defined when the Upkeep was registered.
        performData = checkData;
    }

    function performUpkeep(bytes calldata performData ) external override {
        //revalidating the upkeep in the performUpkeep function
         for(uint i = 0; i<intervals.length; i++){
          if(intervals[i] == block.timestamp - s_lastTimestamp){
             getWinner(intervals[i]);
          }else{
             
          }
        }

      
        performData;
        //The performData is generated by the Keeper's call to your checkUpkeep function
    }



//LOTTERY FUNC

function addPlayer (uint _gameId) public {
    //  if (msg.value < _valTicket) {
    //         revert Lottery__NotEnoughETHEntered();
    //   }
      countPlayers[_gameId] +=1;
      address playerAddress = msg.sender;
      playersInGames[_gameId][countPlayers[_gameId]] = playerAddress;
}

function setGameInterval(uint _gameId,uint interval) public {
      gamesIntervals[_gameId] = interval;
      gamesIds.push(_gameId);
}


function getWinner (uint interval) public {
     if(interval == 30){
       interval1 = interval;
     }
      if(interval == 60){
       interval2 = interval;
     }
       if(interval == 100){
       interval3 = interval;
     }else{
       revert Interval__inexistent();
     }
}



// function geWinner(uint _gameId) public returns(address){
//      s_gameId = _gameId;
    
//      return playersInGames[_gameId][s_winnerId];
// }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface KeeperCompatibleInterface {
  /**
   * @notice method that is simulated by the keepers to see if any work actually
   * needs to be performed. This method does does not actually need to be
   * executable, and since it is only ever simulated it can consume lots of gas.
   * @dev To ensure that it is never called, you may want to add the
   * cannotExecute modifier from KeeperBase to your implementation of this
   * method.
   * @param checkData specified in the upkeep registration so it is always the
   * same for a registered upkeep. This can easily be broken down into specific
   * arguments using `abi.decode`, so multiple upkeeps can be registered on the
   * same contract and easily differentiated by the contract.
   * @return upkeepNeeded boolean to indicate whether the keeper should call
   * performUpkeep or not.
   * @return performData bytes that the keeper should call performUpkeep with, if
   * upkeep is needed. If you would like to encode data to decode later, try
   * `abi.encode`.
   */
  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);

  /**
   * @notice method that is actually executed by the keepers, via the registry.
   * The data returned by the checkUpkeep simulation will be passed into
   * this method to actually be executed.
   * @dev The input to this method should not be trusted, and the caller of the
   * method should not even be restricted to any single registry. Anyone should
   * be able call it, and the input should be validated, there is no guarantee
   * that the data passed in is the performData returned from checkUpkeep. This
   * could happen due to malicious keepers, racing keepers, or simply a state
   * change while the performUpkeep transaction is waiting for confirmation.
   * Always validate the data passed in.
   * @param performData is the data which was passed back from the checkData
   * simulation. If it is encoded, it can easily be decoded into other types by
   * calling `abi.decode`. This data should not be trusted, and should be
   * validated against the contract's current state.
   */
  function performUpkeep(bytes calldata performData) external;
}