// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)

pragma solidity ^0.8.0;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {
    /**
     * @dev Returns the downcasted uint224 from uint256, reverting on
     * overflow (when the input is greater than largest uint224).
     *
     * Counterpart to Solidity's `uint224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     */
    function toUint224(uint256 value) internal pure returns (uint224) {
        require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
        return uint224(value);
    }

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint96 from uint256, reverting on
     * overflow (when the input is greater than largest uint96).
     *
     * Counterpart to Solidity's `uint96` operator.
     *
     * Requirements:
     *
     * - input must fit into 96 bits
     */
    function toUint96(uint256 value) internal pure returns (uint96) {
        require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
        return uint96(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, "SafeCast: value must be positive");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= type(int128).min && value <= type(int128).max, "SafeCast: value doesn't fit in 128 bits");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= type(int64).min && value <= type(int64).max, "SafeCast: value doesn't fit in 64 bits");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= type(int32).min && value <= type(int32).max, "SafeCast: value doesn't fit in 32 bits");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= type(int16).min && value <= type(int16).max, "SafeCast: value doesn't fit in 16 bits");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= type(int8).min && value <= type(int8).max, "SafeCast: value doesn't fit in 8 bits");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
        require(value <= uint256(type(int256).max), "SafeCast: value doesn't fit in an int256");
        return int256(value);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 *
 * [WARNING]
 * ====
 *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.
 *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
 *
 *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.
 * ====
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastValue;
                // Update the index for the moved value
                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        return _values(set._inner);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/ContextUpgradeable.sol";
import "../proxy/utils/Initializable.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function __Ownable_init() internal onlyInitializing {
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal onlyInitializing {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[49] private __gap;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)

pragma solidity ^0.8.2;

import "../../utils/AddressUpgradeable.sol";

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
 * case an upgrade adds a module that needs to be initialized.
 *
 * For example:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 *
 * [CAUTION]
 * ====
 * Avoid leaving a contract uninitialized.
 *
 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 * ====
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     * @custom:oz-retyped-from bool
     */
    uint8 private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint8 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts.
     *
     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
     * constructor.
     *
     * Emits an {Initialized} event.
     */
    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
            "Initializable: contract is already initialized"
        );
        _initialized = 1;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * A reinitializer may be used after the original initialization step. This is essential to configure modules that
     * are added through upgrades and that require initialization.
     *
     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
     * cannot be nested. If one is invoked in the context of another, execution will revert.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     *
     * WARNING: setting the version to 255 will prevent any future reinitialization.
     *
     * Emits an {Initialized} event.
     */
    modifier reinitializer(uint8 version) {
        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
        _initialized = version;
        _initializing = true;
        _;
        _initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     *
     * Emits an {Initialized} event the first time it is successfully executed.
     */
    function _disableInitializers() internal virtual {
        require(!_initializing, "Initializable: contract is initializing");
        if (_initialized < type(uint8).max) {
            _initialized = type(uint8).max;
            emit Initialized(type(uint8).max);
        }
    }

    /**
     * @dev Internal function that returns the initialized version. Returns `_initialized`
     */
    function _getInitializedVersion() internal view returns (uint8) {
        return _initialized;
    }

    /**
     * @dev Internal function that returns the initialized version. Returns `_initializing`
     */
    function _isInitializing() internal view returns (bool) {
        return _initializing;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library AddressUpgradeable {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;
import "../proxy/utils/Initializable.sol";

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal onlyInitializing {
    }

    function __Context_init_unchained() internal onlyInitializing {
    }
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[50] private __gap;
}

// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity 0.8.17;

// Created By: Art Blocks Inc.

import "./interfaces/0.8.x/IAdminACLV0.sol";
import "./interfaces/0.8.x/IDependencyRegistryCompatibleV0.sol";
import "./interfaces/0.8.x/IDependencyRegistryV0.sol";

import "@openzeppelin-4.7/contracts/utils/Strings.sol";
import "@openzeppelin-4.7/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin-4.8/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin-4.8/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin-4.5/contracts/utils/math/SafeCast.sol";

import {IContractScript} from "scripty.sol/contracts/scripty/IContractScript.sol";
import {AddressChunks} from "scripty.sol/contracts/scripty/utils/AddressChunks.sol";
import {IScriptyBuilder, WrappedScriptRequest} from "scripty.sol/contracts/scripty/IScriptyBuilder.sol";

import "./libs/0.8.x/BytecodeStorage.sol";
import "./libs/0.8.x/Bytes32Strings.sol";

/**
 * @title Art Blocks Dependency Registry, V0.
 * @author Art Blocks Inc.
 * @notice Privileged Roles and Ownership:
 * Permissions managed by ACL contract. If/when we ever call
 * renounceOwnership() this will becom a frozen, immutable registry
 * as no upgrades will be possible.
 * This contract This contract is intended to be an auxiliary reference registry
 * to our non-upgradeable and immutable ERC-721 conforming core contracts,
 * and has been made upgradeable as we expect its required functionality in
 * relation to the Art Blocks ecosystem to evolve over time.
 */
contract DependencyRegistryV1 is
    Initializable,
    OwnableUpgradeable,
    IDependencyRegistryV0,
    IContractScript
{
    using BytecodeStorage for string;
    using BytecodeStorage for address;
    using Bytes32Strings for bytes32;
    using Strings for uint256;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableSet for EnumerableSet.AddressSet;
    using SafeCast for uint24;

    uint8 constant AT_CHARACTER_CODE = uint8(bytes1("@")); // 0x40

    /// admin ACL contract
    IAdminACLV0 public adminACLContract;

    struct Dependency {
        string preferredCDN;
        mapping(uint256 => string) additionalCDNs;
        string preferredRepository;
        mapping(uint256 => string) additionalRepositories;
        string referenceWebsite;
        // mapping from script index to address storing script in bytecode
        mapping(uint256 => address) scriptBytecodeAddresses;
        uint24 additionalCDNCount;
        uint24 additionalRepositoryCount;
        uint24 scriptCount;
    }

    EnumerableSet.Bytes32Set private _dependencyTypes;
    mapping(bytes32 => Dependency) dependencyDetails;

    EnumerableSet.AddressSet private _supportedCoreContracts;
    mapping(address => mapping(uint256 => bytes32)) projectDependencyTypeOverrides;

    IScriptyBuilder public scriptyBuilder;

    modifier onlyNonZeroAddress(address _address) {
        require(_address != address(0), "Must input non-zero address");
        _;
    }

    modifier onlyNonEmptyString(string memory _string) {
        require(bytes(_string).length != 0, "Must input non-empty string");
        _;
    }

    modifier onlyAdminACL(bytes4 _selector) {
        require(
            adminACLAllowed(msg.sender, address(this), _selector),
            "Only Admin ACL allowed"
        );
        _;
    }

    modifier onlySupportedCoreContract(address _coreContractAddress) {
        require(
            _supportedCoreContracts.contains(_coreContractAddress),
            "Core contract not supported"
        );
        _;
    }

    modifier onlyExistingDependencyType(bytes32 _dependencyType) {
        require(
            _dependencyTypes.contains(_dependencyType),
            "Dependency type does not exist"
        );
        _;
    }

    /**
     * @notice Initializes contract.
     * @param _adminACLContract Address of admin access control contract, to be
     * set as contract owner.
     */
    function initialize(address _adminACLContract) public initializer {
        __Ownable_init();
        // set AdminACL management contract as owner
        _transferOwnership(_adminACLContract);
    }

    /**
     * @notice Adds a new dependency.
     * @param _dependencyType Name of dependency type (i.e. "[email protected]") used to identify dependency.
     * @param _preferredCDN Preferred CDN for dependency.
     * @param _preferredRepository Preferred repository for dependency.
     */
    function addDependency(
        bytes32 _dependencyType,
        string memory _preferredCDN,
        string memory _preferredRepository,
        string memory _referenceWebsite
    ) external onlyAdminACL(this.addDependency.selector) {
        require(
            !_dependencyTypes.contains(_dependencyType),
            "Dependency type already exists"
        );
        require(
            _dependencyType.containsExactCharacterQty(
                AT_CHARACTER_CODE,
                uint8(1)
            ),
            "must contain exactly one @"
        );

        _dependencyTypes.add(_dependencyType);
        Dependency storage dependencyType = dependencyDetails[_dependencyType];
        dependencyType.preferredCDN = _preferredCDN;
        dependencyType.preferredRepository = _preferredRepository;
        dependencyType.referenceWebsite = _referenceWebsite;

        emit DependencyAdded(
            _dependencyType,
            _preferredCDN,
            _preferredRepository,
            _referenceWebsite
        );
    }

    /**
     * @notice Removes a dependency.
     * @param _dependencyType Name of dependency type (i.e. "[email protected]")
     */
    function removeDependency(
        bytes32 _dependencyType
    )
        external
        onlyAdminACL(this.removeDependency.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        require(
            dependency.additionalCDNCount == 0 &&
                dependency.additionalRepositoryCount == 0 &&
                dependency.scriptCount == 0,
            "Cannot remove dependency with additional CDNs, repositories, or scripts"
        );

        _dependencyTypes.remove(_dependencyType);
        delete dependencyDetails[_dependencyType];

        emit DependencyRemoved(_dependencyType);
    }

    /**
     * @notice Adds a script to dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _script Script to be added. Required to be a non-empty string,
     * but no further validation is performed.
     */
    function addDependencyScript(
        bytes32 _dependencyType,
        string memory _script
    )
        external
        onlyAdminACL(this.addDependencyScript.selector)
        onlyNonEmptyString(_script)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        // store script in contract bytecode
        dependency.scriptBytecodeAddresses[dependency.scriptCount] = _script
            .writeToBytecode();
        dependency.scriptCount = dependency.scriptCount + 1;

        emit DependencyScriptUpdated(_dependencyType);
    }

    /**
     * @notice Updates script for dependencyType `_dependencyType` at script ID `_scriptId`.
     * @param _dependencyType dependency to be updated.
     * @param _scriptId Script ID to be updated.
     * @param _script The updated script value. Required to be a non-empty
     * string, but no further validation is performed.
     */
    function updateDependencyScript(
        bytes32 _dependencyType,
        uint256 _scriptId,
        string memory _script
    )
        external
        onlyAdminACL(this.updateDependencyScript.selector)
        onlyNonEmptyString(_script)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependencyType = dependencyDetails[_dependencyType];
        require(
            _scriptId < dependencyType.scriptCount,
            "scriptId out of range"
        );
        // purge old contract bytecode contract from the blockchain state
        // note: Although this does reduce usage of Ethereum state, it does not
        // reduce the gas costs of removal transactions. We believe this is the
        // best behavior at the time of writing, and do not expect this to
        // result in any breaking changes in the future. All current proposals
        // to change the self-destruct opcode are backwards compatible, but may
        // result in not removing the bytecode from the blockchain state. This
        // implementation is compatible with that architecture, as it does not
        // rely on the bytecode being removed from the blockchain state.
        dependencyType.scriptBytecodeAddresses[_scriptId].purgeBytecode();
        // store script in contract bytecode, replacing reference address from
        // the contract that no longer exists with the newly created one
        dependencyType.scriptBytecodeAddresses[_scriptId] = _script
            .writeToBytecode();

        emit DependencyScriptUpdated(_dependencyType);
    }

    /**
     * @notice Removes last script from dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     */
    function removeDependencyLastScript(
        bytes32 _dependencyType
    )
        external
        onlyAdminACL(this.removeDependencyLastScript.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        require(dependency.scriptCount > 0, "there are no scripts to remove");
        // purge old contract bytecode contract from the blockchain state
        // note: Although this does reduce usage of Ethereum state, it does not
        // reduce the gas costs of removal transactions. We believe this is the
        // best behavior at the time of writing, and do not expect this to
        // result in any breaking changes in the future. All current proposals
        // to change the self-destruct opcode are backwards compatible, but may
        // result in not removing the bytecode from the blockchain state. This
        // implementation is compatible with that architecture, as it does not
        // rely on the bytecode being removed from the blockchain state.
        dependency
            .scriptBytecodeAddresses[dependency.scriptCount - 1]
            .purgeBytecode();
        // delete reference to contract address that no longer exists
        delete dependency.scriptBytecodeAddresses[dependency.scriptCount - 1];
        unchecked {
            dependency.scriptCount = dependency.scriptCount - 1;
        }

        emit DependencyScriptUpdated(_dependencyType);
    }

    /**
     * @notice Updates preferred CDN for dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _preferredCDN URL for preferred CDN.
     */
    function updateDependencyPreferredCDN(
        bytes32 _dependencyType,
        string memory _preferredCDN
    )
        external
        onlyAdminACL(this.updateDependencyPreferredCDN.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        dependencyDetails[_dependencyType].preferredCDN = _preferredCDN;

        emit DependencyPreferredCDNUpdated(_dependencyType, _preferredCDN);
    }

    /**
     * @notice Updates preferred repository for dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _preferredRepository URL for preferred repository.
     */
    function updateDependencyPreferredRepository(
        bytes32 _dependencyType,
        string memory _preferredRepository
    )
        external
        onlyAdminACL(this.updateDependencyPreferredRepository.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        dependencyDetails[_dependencyType]
            .preferredRepository = _preferredRepository;

        emit DependencyPreferredRepositoryUpdated(
            _dependencyType,
            _preferredRepository
        );
    }

    /**
     * @notice Updates project website for dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _referenceWebsite URL for project website.
     */
    function updateDependencyReferenceWebsite(
        bytes32 _dependencyType,
        string memory _referenceWebsite
    )
        external
        onlyAdminACL(this.updateDependencyReferenceWebsite.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        dependencyDetails[_dependencyType].referenceWebsite = _referenceWebsite;

        emit DependencyReferenceWebsiteUpdated(
            _dependencyType,
            _referenceWebsite
        );
    }

    /**
     * @notice Adds a new CDN url to `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _additionalCDN CDN URL to be added. Required to be a non-empty string,
     * but no further validation is performed.
     */
    function addDependencyAdditionalCDN(
        bytes32 _dependencyType,
        string memory _additionalCDN
    )
        external
        onlyAdminACL(this.addDependencyAdditionalCDN.selector)
        onlyNonEmptyString(_additionalCDN)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];

        uint256 additionalCDNCount = uint256(dependency.additionalCDNCount);
        dependency.additionalCDNs[additionalCDNCount] = _additionalCDN;
        dependency.additionalCDNCount = uint24(additionalCDNCount + 1);

        emit DependencyAdditionalCDNUpdated(
            _dependencyType,
            _additionalCDN,
            additionalCDNCount
        );
    }

    /**
     * @notice Removes additional CDN for dependency `_dependencyId` at index `_index`.
     * Removal is done by swapping the element to be removed with the last element in the array, then deleting this last element.
     * Assets with indices higher than `_index` can have their indices adjusted as a result of this operation.
     * @param _dependencyType dependency to be updated.
     * @param _index Additional CDN index
     */
    function removeDependencyAdditionalCDNAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    )
        external
        onlyAdminACL(this.removeDependencyAdditionalCDNAtIndex.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];

        uint256 additionalCDNCount = dependency.additionalCDNCount;
        require(_index < additionalCDNCount, "Asset index out of range");

        uint256 lastElementIndex = additionalCDNCount - 1;

        dependency.additionalCDNs[_index] = dependency.additionalCDNs[
            lastElementIndex
        ];
        delete dependency.additionalCDNs[lastElementIndex];

        dependency.additionalCDNCount = uint24(lastElementIndex);

        emit DependencyAdditionalCDNRemoved(_dependencyType, _index);
    }

    /**
     * @notice Updates additional CDN for dependency `_dependencyType` at `_index`.
     * @param _dependencyType dependency to be updated.
     * @param _index Additional CDN index.
     * @param _additionalCDN New CDN URL.
     */
    function updateDependencyAdditionalCDNAtIndex(
        bytes32 _dependencyType,
        uint256 _index,
        string memory _additionalCDN
    )
        external
        onlyAdminACL(this.updateDependencyAdditionalCDNAtIndex.selector)
        onlyNonEmptyString(_additionalCDN)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        uint24 additionalCDNCount = dependency.additionalCDNCount;
        require(_index < additionalCDNCount, "Asset index out of range");

        dependency.additionalCDNs[_index] = _additionalCDN;

        emit DependencyAdditionalCDNUpdated(
            _dependencyType,
            _additionalCDN,
            _index
        );
    }

    /**
     * @notice Adds a new repository URL to dependency `_dependencyType`.
     * @param _dependencyType dependency to be updated.
     * @param _additionalRepository Repository URL to be added. Required to be a non-empty string,
     * but no further validation is performed.
     */
    function addDependencyAdditionalRepository(
        bytes32 _dependencyType,
        string memory _additionalRepository
    )
        external
        onlyAdminACL(this.addDependencyAdditionalRepository.selector)
        onlyNonEmptyString(_additionalRepository)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        uint256 additionalRepositoryCount = uint256(
            dependency.additionalRepositoryCount
        );
        dependency.additionalRepositories[
            additionalRepositoryCount
        ] = _additionalRepository;
        dependency.additionalRepositoryCount = uint24(
            additionalRepositoryCount + 1
        );

        emit DependencyAdditionalRepositoryUpdated(
            _dependencyType,
            _additionalRepository,
            additionalRepositoryCount
        );
    }

    /**
     * @notice Removes additional repository for depenency `_dependencyId` at index `_index`.
     * Removal is done by swapping the element to be removed with the last element in the array, then deleting this last element.
     * Assets with indices higher than `_index` can have their indices adjusted as a result of this operation.
     * @param _dependencyType dependency to be updated.
     * @param _index Additional repository index.
     */
    function removeDependencyAdditionalRepositoryAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    )
        external
        onlyAdminACL(this.removeDependencyAdditionalRepositoryAtIndex.selector)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        uint256 additionalRepositoryCount = uint256(
            dependency.additionalRepositoryCount
        );
        require(_index < additionalRepositoryCount, "Asset index out of range");

        uint256 lastElementIndex = additionalRepositoryCount - 1;

        dependency.additionalRepositories[_index] = dependencyDetails[
            _dependencyType
        ].additionalRepositories[lastElementIndex];
        delete dependency.additionalRepositories[lastElementIndex];

        dependency.additionalRepositoryCount = uint24(lastElementIndex);

        emit DependencyAdditionalRepositoryRemoved(_dependencyType, _index);
    }

    /**
     * @notice Updates additional repository for dependency `_dependencyType` at `_index`.
     * @param _dependencyType dependency to be updated.
     * @param _index Additional repository index.
     * @param _additionalRepository New Repository URL.
     */
    function updateDependencyAdditionalRepositoryAtIndex(
        bytes32 _dependencyType,
        uint256 _index,
        string memory _additionalRepository
    )
        external
        onlyAdminACL(this.updateDependencyAdditionalRepositoryAtIndex.selector)
        onlyNonEmptyString(_additionalRepository)
        onlyExistingDependencyType(_dependencyType)
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        uint24 additionalRepositoryCount = dependency.additionalRepositoryCount;
        require(_index < additionalRepositoryCount, "Asset index out of range");

        dependency.additionalRepositories[_index] = _additionalRepository;

        emit DependencyAdditionalRepositoryUpdated(
            _dependencyType,
            _additionalRepository,
            _index
        );
    }

    /**
     * @notice Adds a new core contract to the list of supported core contracts.
     * @param _contractAddress Address of the core contract to be added.
     */
    function addSupportedCoreContract(
        address _contractAddress
    )
        external
        onlyAdminACL(this.addSupportedCoreContract.selector)
        onlyNonZeroAddress(_contractAddress)
    {
        require(
            !_supportedCoreContracts.contains(_contractAddress),
            "Contract already supported"
        );

        _supportedCoreContracts.add(_contractAddress);

        emit SupportedCoreContractAdded(_contractAddress);
    }

    /**
     * @notice Removes a core contract from the list of supported core contracts.
     * @param _contractAddress Address of the core contract to be removed.
     */
    function removeSupportedCoreContract(
        address _contractAddress
    )
        external
        onlyAdminACL(this.removeSupportedCoreContract.selector)
        onlySupportedCoreContract(_contractAddress)
    {
        _supportedCoreContracts.remove(_contractAddress);

        emit SupportedCoreContractRemoved(_contractAddress);
    }

    /**
     * @notice Overrides the script type and version that
     * would be returned by the core contract (`_contractAddress`)
     * for a given project  (`projectId`) with the given dependency
     * type (`_dependencyType`).
     * @param _contractAddress Core contract address.
     * @param _projectId Project to override script type and version for.
     * @param _dependencyType Dependency type to return for project.
     */
    function addProjectDependencyTypeOverride(
        address _contractAddress,
        uint256 _projectId,
        bytes32 _dependencyType
    )
        external
        onlyAdminACL(this.addProjectDependencyTypeOverride.selector)
        onlyExistingDependencyType(_dependencyType)
        onlySupportedCoreContract(_contractAddress)
    {
        projectDependencyTypeOverrides[_contractAddress][
            _projectId
        ] = _dependencyType;

        emit ProjectDependencyTypeOverrideAdded(
            _contractAddress,
            _projectId,
            _dependencyType
        );
    }

    /**
     * @notice Removes the script type and version override for a given
     * project (`projectId`) on a given core contract (`_contractAddress`).
     * @param _contractAddress Core contract address.
     * @param _projectId Project to remove override for.
     */
    function removeProjectDependencyTypeOverride(
        address _contractAddress,
        uint256 _projectId
    ) external onlyAdminACL(this.removeProjectDependencyTypeOverride.selector) {
        require(
            projectDependencyTypeOverrides[_contractAddress][_projectId] !=
                bytes32(""),
            "No override set for project"
        );

        delete projectDependencyTypeOverrides[_contractAddress][_projectId];

        emit ProjectDependencyTypeOverrideRemoved(_contractAddress, _projectId);
    }

    /**
     * @notice Returns a list of registered depenency types.
     * @return List of registered depenency types.
     * @dev This is only intended to be called outside of block
     * execution where there is no gas limit.
     */
    function getDependencyTypes() external view returns (string[] memory) {
        string[] memory dependencyTypes = new string[](
            _dependencyTypes.length()
        );
        uint256 numDependencyTypes = _dependencyTypes.length();

        for (uint256 i = 0; i < numDependencyTypes; i++) {
            dependencyTypes[i] = _dependencyTypes.at(i).toString();
        }
        return dependencyTypes;
    }

    /**
     * @notice Returns number of registered dependency types
     * @return Number of registered dependencies.
     */
    function getDependencyTypeCount() external view returns (uint256) {
        return _dependencyTypes.length();
    }

    /**
     * @notice Returns registered depenedency type at index `_index`.
     * @return Registered dependency at `_index`.
     */
    function getDependencyTypeAtIndex(
        uint256 _index
    ) external view returns (string memory) {
        require(_dependencyTypes.length() > _index, "Index out of range");
        return _dependencyTypes.at(_index).toString();
    }

    /**
     * @notice Returns details for depedency type `_dependencyType`.
     * @param _dependencyType Dependency type to be queried.
     * @return typeAndVersion String representation of `_dependencyType`.
     * (e.g. "p5js(atSymbol)1.0.0")
     * @return preferredCDN Preferred CDN URL for dependency
     * @return additionalCDNCount Count of additional CDN URLs for dependency
     * @return preferredRepository Preferred repository URL for dependency
     * @return additionalRepositoryCount Count of additional repository URLs for dependency
     * @return referenceWebsite Project website URL for dependency
     * @return availableOnChain Whether dependency is available on chain
     * @return scriptCount Count of on-chain scripts for dependency
     */
    function getDependencyDetails(
        bytes32 _dependencyType
    )
        external
        view
        returns (
            string memory typeAndVersion,
            string memory preferredCDN,
            uint24 additionalCDNCount,
            string memory preferredRepository,
            uint24 additionalRepositoryCount,
            string memory referenceWebsite,
            bool availableOnChain,
            uint24 scriptCount
        )
    {
        Dependency storage dependency = dependencyDetails[_dependencyType];

        return (
            _dependencyType.toString(),
            dependency.preferredCDN,
            dependency.additionalCDNCount,
            dependency.preferredRepository,
            dependency.additionalRepositoryCount,
            dependency.referenceWebsite,
            dependency.scriptCount > 0,
            dependency.scriptCount
        );
    }

    /**
     * @notice Returns the count of supported core contracts
     * @return Number of supported core contracts.
     */
    function getSupportedCoreContractCount() external view returns (uint256) {
        return _supportedCoreContracts.length();
    }

    /**
     * @notice Returns the address of the supported core contract at index `_index`.
     * @param _index Index of the core contract to be returned.
     * @return address of the core contract.
     */
    function getSupportedCoreContractAtIndex(
        uint256 _index
    ) external view returns (address) {
        require(
            _supportedCoreContracts.length() > _index,
            "Index out of bounds"
        );
        return _supportedCoreContracts.at(_index);
    }

    /**
     * @notice Returns a list of supported core contracts.
     * @return List of supported core contracts.
     * @dev This is only intended to be called outside of block
     * execution where there is no gas limit.
     */
    function getSupportedCoreContracts()
        external
        view
        returns (address[] memory)
    {
        uint256 supportedCoreContractCount = _supportedCoreContracts.length();
        address[] memory supportedCoreContracts = new address[](
            supportedCoreContractCount
        );

        for (uint256 i = 0; i < supportedCoreContractCount; i++) {
            supportedCoreContracts[i] = _supportedCoreContracts.at(i);
        }

        return supportedCoreContracts;
    }

    /**
     * @notice Returns the additional CDN URL at index `_index` for dependency `_dependencyType`.
     * @param _dependencyType Dependency type to be queried.
     * @param _index Index of the additional CDN URL to be returned.
     */
    function getDependencyAdditionalCDNAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (string memory) {
        return dependencyDetails[_dependencyType].additionalCDNs[_index];
    }

    /**
     * @notice Returns the additional repository URL at index `_index` for dependency `_dependencyType`.
     * @param _dependencyType Dependency type to be queried.
     * @param _index Index of the additional repository URL to be returned.
     */
    function getDependencyAdditionalRepositoryAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (string memory) {
        return
            dependencyDetails[_dependencyType].additionalRepositories[_index];
    }

    /**
     * @notice Returns the count of scripts for dependency `_dependencyType`.
     * @param _dependencyType Dependency type to be queried.
     */
    function getDependencyScriptCount(
        bytes32 _dependencyType
    ) external view returns (uint256) {
        return dependencyDetails[_dependencyType].scriptCount;
    }

    /**
     * @notice Returns address with bytecode containing script for
     * dependency `_dependencyTypes` at script index `_index`.
     */
    function getDependencyScriptBytecodeAddressAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (address) {
        return
            dependencyDetails[_dependencyType].scriptBytecodeAddresses[_index];
    }

    /**
     * @notice Returns script for dependency `_dependencyType` at script index `_index`.
     * @param _dependencyType dependency to be queried.
     * @param _index Index of script to be queried.
     */
    function getDependencyScriptAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (string memory) {
        Dependency storage dependency = dependencyDetails[_dependencyType];
        // If trying to access an out-of-index script, return the empty string.
        if (_index >= dependency.scriptCount) {
            return "";
        }

        return dependency.scriptBytecodeAddresses[_index].readFromBytecode();
    }

    /**
     * @notice Returns the dependency type for a given project (`projectId`)
     * on a given core contract (`_contractAddress`). If no override is set,
     * the core contract is called to retrieve the script type and version as
     * dependency type. For any contract earlier than v3, that does not have
     * an override set, this will revert.
     * @param _contractAddress Core contract address.
     * @param _projectId Project to return dependency type for.
     * @return dependencyType Dependency type used by project.
     */
    function getDependencyTypeForProject(
        address _contractAddress,
        uint256 _projectId
    )
        external
        view
        onlySupportedCoreContract(_contractAddress)
        returns (string memory)
    {
        bytes32 dependencyType = projectDependencyTypeOverrides[
            _contractAddress
        ][_projectId];
        if (dependencyType != bytes32(0)) {
            return dependencyType.toString();
        }

        try
            IDependencyRegistryCompatibleV0(_contractAddress)
                .projectScriptDetails(_projectId)
        returns (string memory scriptTypeAndVersion, string memory, uint256) {
            return scriptTypeAndVersion;
        } catch {
            revert(
                "Contract does not implement projectScriptDetails and has no override set."
            );
        }
    }

    /**
     * @notice Convenience function that returns whether `_sender` is allowed
     * to call function with selector `_selector` on contract `_contract`, as
     * determined by this contract's current Admin ACL contract. Expected use
     * cases include minter contracts checking if caller is allowed to call
     * admin-gated functions on minter contracts.
     * @param _sender Address of the sender calling function with selector
     * `_selector` on contract `_contract`.
     * @param _contract Address of the contract being called by `_sender`.
     * @param _selector Function selector of the function being called by
     * `_sender`.
     * @return bool Whether `_sender` is allowed to call function with selector
     * `_selector` on contract `_contract`.
     * @dev assumes the Admin ACL contract is the owner of this contract, which
     * is expected to always be true.
     * @dev adminACLContract is expected to either be null address (if owner
     * has renounced ownership), or conform to IAdminACLV0 interface. Check for
     * null address first to avoid revert when admin has renounced ownership.
     */
    function adminACLAllowed(
        address _sender,
        address _contract,
        bytes4 _selector
    ) public returns (bool) {
        return
            owner() != address(0) &&
            adminACLContract.allowed(_sender, _contract, _selector);
    }

    /**
     * @notice Returns contract owner. Set to deployer's address by default on
     * contract deployment.
     * @return address Address of contract owner.
     * @dev ref: https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable
     * @dev owner role was called `admin` prior to V3 core contract
     */
    function owner()
        public
        view
        override(OwnableUpgradeable)
        returns (address)
    {
        return OwnableUpgradeable.owner();
    }

    /**
     * @notice Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     * @param newOwner New owner.
     * @dev owner role was called `admin` prior to V3 core contract.
     * @dev Overrides and wraps OpenZeppelin's _transferOwnership function to
     * also update adminACLContract for improved introspection.
     */
    function _transferOwnership(address newOwner) internal override {
        OwnableUpgradeable._transferOwnership(newOwner);
        adminACLContract = IAdminACLV0(newOwner);
    }

    function stringToBytes32(
        string memory source
    ) public pure returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }

    function getTokenHtml(
        address _contractAddress,
        uint256 _tokenId
    ) external view returns (string memory) {
        uint256 ONE_MILLION = 1_000_000;

        uint256 projectId = _tokenId / ONE_MILLION;
        bytes32 dependencyType = stringToBytes32(
            this.getDependencyTypeForProject(_contractAddress, projectId)
        );
        bytes32 tokenHash = IDependencyRegistryCompatibleV0(_contractAddress)
            .tokenIdToHash(_tokenId);

        WrappedScriptRequest[] memory requests = new WrappedScriptRequest[](3);

        requests[0].scriptContent = abi.encodePacked(
            'let tokenData = {"tokenId":"',
            Strings.toString(_tokenId),
            '"',
            ',"hash":"',
            tokenHash,
            '"}'
        );

        requests[1].name = "dependency";
        requests[1].contractData = abi.encode(dependencyType);
        requests[1].contractAddress = address(this);
        requests[1].wrapType = 0; // <script>[script]</script>

        requests[2].name = "project";
        requests[2].contractData = abi.encode(_contractAddress, projectId);
        requests[2].contractAddress = _contractAddress;
        requests[2].wrapType = 0; // <script>[script]</script>

        uint256 bufferSize = scriptyBuilder.getBufferSizeForEncodedHTMLWrapped(
            requests
        );

        bytes memory base64EncodedHTMLDataURI = scriptyBuilder
            .getEncodedHTMLWrapped(requests, bufferSize);

        return string(abi.encodePacked(base64EncodedHTMLDataURI));
    }

    function getScript(
        string memory _name,
        bytes memory _data
    ) external view returns (bytes memory) {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        bytes32 projectHash = keccak256(abi.encodePacked("project"));
        bytes32 dependencyHash = keccak256(abi.encodePacked("dependency"));
        require(
            nameHash == projectHash || nameHash == dependencyHash,
            "invalid name"
        );
        address[] memory scriptBytecodeAddresses;
        if (nameHash == projectHash) {
            (address contractAddress, uint256 projectId) = abi.decode(
                _data,
                (address, uint256)
            );

            IDependencyRegistryCompatibleV0 depRegCompat = IDependencyRegistryCompatibleV0(
                    contractAddress
                );
            (
                string memory scriptTypeAndVersion,
                string memory aspectRatio,
                uint256 scriptCount
            ) = depRegCompat.projectScriptDetails(projectId);

            if (scriptCount == 0) {
                return "";
            }

            for (uint256 i = 0; i < scriptCount; i++) {
                scriptBytecodeAddresses[i] = depRegCompat
                    .projectScriptBytecodeAddressByIndex(projectId, i);
            }
        } else {
            bytes32 dependencyType = abi.decode(_data, (bytes32));
            Dependency storage dependency = dependencyDetails[dependencyType];
            uint256 scriptCount = dependency.scriptCount;

            return "";

            if (scriptCount == 0) {
                return "";
            }

            for (uint256 i = 0; i < scriptCount; i++) {
                scriptBytecodeAddresses[i] = dependency.scriptBytecodeAddresses[
                    i
                ];
            }
        }

        return AddressChunks.mergeChunks(scriptBytecodeAddresses);
    }

    function setScriptyBuilder(
        address _scriptyBuilderAddress
    ) external onlyAdminACL(this.setScriptyBuilder.selector) {
        scriptyBuilder = IScriptyBuilder(_scriptyBuilderAddress);
    }
}

// SPDX-License-Identifier: LGPL-3.0-only
// Created By: Art Blocks Inc.

pragma solidity ^0.8.0;

interface IAdminACLV0 {
    /**
     * @notice Token ID `_tokenId` minted to `_to`.
     * @param previousSuperAdmin The previous superAdmin address.
     * @param newSuperAdmin The new superAdmin address.
     * @param genArt721CoreAddressesToUpdate Array of genArt721Core
     * addresses to update to the new superAdmin, for indexing purposes only.
     */
    event SuperAdminTransferred(
        address indexed previousSuperAdmin,
        address indexed newSuperAdmin,
        address[] genArt721CoreAddressesToUpdate
    );

    /// Type of the Admin ACL contract, e.g. "AdminACLV0"
    function AdminACLType() external view returns (string memory);

    /// super admin address
    function superAdmin() external view returns (address);

    /**
     * @notice Calls transferOwnership on other contract from this contract.
     * This is useful for updating to a new AdminACL contract.
     * @dev this function should be gated to only superAdmin-like addresses.
     */
    function transferOwnershipOn(
        address _contract,
        address _newAdminACL
    ) external;

    /**
     * @notice Calls renounceOwnership on other contract from this contract.
     * @dev this function should be gated to only superAdmin-like addresses.
     */
    function renounceOwnershipOn(address _contract) external;

    /**
     * @notice Checks if sender `_sender` is allowed to call function with selector
     * `_selector` on contract `_contract`.
     */
    function allowed(
        address _sender,
        address _contract,
        bytes4 _selector
    ) external returns (bool);
}

// SPDX-License-Identifier: LGPL-3.0-only
// Created By: Art Blocks Inc.
pragma solidity ^0.8.17;

interface IDependencyRegistryCompatibleV0 {
    /// Dependency registry managed by Art Blocks
    function artblocksDependencyRegistryAddress()
        external
        view
        returns (address);

    /**
     * @notice Returns script information for project `_projectId`.
     * @param _projectId Project to be queried.
     * @return scriptTypeAndVersion Project's script type and version
     * (e.g. "p5js(atSymbol)1.0.0")
     * @return aspectRatio Aspect ratio of project (e.g. "1" for square,
     * "1.77777778" for 16:9, etc.)
     * @return scriptCount Count of scripts for project
     */
    function projectScriptDetails(
        uint256 _projectId
    )
        external
        view
        returns (
            string memory scriptTypeAndVersion,
            string memory aspectRatio,
            uint256 scriptCount
        );

    function projectScriptBytecodeAddressByIndex(
        uint256 _projectId,
        uint256 _index
    ) external view returns (address);

    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);
}

// SPDX-License-Identifier: LGPL-3.0-only
// Created By: Art Blocks Inc.
pragma solidity ^0.8.17;

interface IDependencyRegistryV0 {
    event SupportedCoreContractAdded(address indexed _coreContractAddress);

    event SupportedCoreContractRemoved(address indexed _coreContractAddress);

    event ProjectDependencyTypeOverrideAdded(
        address indexed _coreContractAddress,
        uint256 indexed _projectId,
        bytes32 _dependencyType
    );

    event ProjectDependencyTypeOverrideRemoved(
        address indexed _coreContractAddress,
        uint256 indexed _projectId
    );

    event DependencyAdded(
        bytes32 indexed _dependencyType,
        string _preferredCDN,
        string _preferredRepository,
        string _referenceWebsite
    );

    event DependencyRemoved(bytes32 indexed _dependencyType);

    event DependencyReferenceWebsiteUpdated(
        bytes32 indexed _dependencyType,
        string _referenceWebsite
    );

    event DependencyPreferredCDNUpdated(
        bytes32 indexed _dependencyType,
        string _preferredCDN
    );

    event DependencyPreferredRepositoryUpdated(
        bytes32 indexed _dependencyType,
        string _preferredRepository
    );

    event DependencyAdditionalCDNUpdated(
        bytes32 indexed _dependencyType,
        string _additionalCDN,
        uint256 _additionalCDNIndex
    );

    event DependencyAdditionalCDNRemoved(
        bytes32 indexed _dependencyType,
        uint256 indexed _additionalCDNIndex
    );

    event DependencyAdditionalRepositoryUpdated(
        bytes32 indexed _dependencyType,
        string _additionalRepository,
        uint256 _additionalRepositoryIndex
    );

    event DependencyAdditionalRepositoryRemoved(
        bytes32 indexed _dependencyType,
        uint256 indexed _additionalRepositoryIndex
    );

    event DependencyScriptUpdated(bytes32 indexed _dependencyType);

    /**
     * @notice Returns the count of scripts for dependency `_dependencyType`.
     * @param _dependencyType Dependency type to be queried.
     */
    function getDependencyScriptCount(
        bytes32 _dependencyType
    ) external view returns (uint256);

    /**
     * @notice Returns address with bytecode containing script for
     * dependency type `_dependencyTypes` at script index `_index`.
     */
    function getDependencyScriptBytecodeAddressAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (address);

    /**
     * @notice Returns script for dependency type `_dependencyType` at script index `_index`.
     * @param _dependencyType Dependency type to be queried.
     * @param _index Index of script to be queried.
     */
    function getDependencyScriptAtIndex(
        bytes32 _dependencyType,
        uint256 _index
    ) external view returns (string memory);
}

// SPDX-License-Identifier: LGPL-3.0-only
// Created By: Art Blocks Inc.

pragma solidity ^0.8.0;

/**
 * @title Art Blocks Script Storage Library
 * @notice Utilize contract bytecode as persistant storage for large chunks of script string data.
 *
 * @author Art Blocks Inc.
 * @author Modified from 0xSequence (https://github.com/0xsequence/sstore2/blob/master/contracts/SSTORE2.sol)
 * @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)
 *
 * @dev Compared to the above two rerferenced libraries, this contracts-as-storage implementation makes a few
 *      notably different design decisions:
 *      - uses the `string` data type for input/output on reads, rather than speaking in bytes directly
 *      - exposes "delete" functionality, allowing no-longer-used storage to be purged from chain state
 *      - stores the "writer" address (library user) in the deployed contract bytes, which is useful for both:
 *         a) providing necessary information for safe deletion; and
 *         b) allowing this to be introspected on-chain
 *      Also, given that much of this library is written in assembly, this library makes use of a slightly
 *      different convention (when compared to the rest of the Art Blocks smart contract repo) around
 *      pre-defining return values in some cases in order to simplify need to directly memory manage these
 *      return values.
 */
library BytecodeStorage {
    //---------------------------------------------------------------------------------------------------------------//
    // Starting Index | Size | Ending Index | Description                                                            //
    //---------------------------------------------------------------------------------------------------------------//
    // 0              | N/A  | 0            |                                                                        //
    // 0              | 72   | 72           | the bytes of the gated-cleanup-logic allowing for `selfdestruct`ion    //
    // 72             | 32   | 104          | the 32 bytes for storing the deploying contract's (0-padded) address   //
    //---------------------------------------------------------------------------------------------------------------//
    // Define the offset for where the "logic bytes" end, and the "data bytes" begin. Note that this is a manually
    // calculated value, and must be updated if the above table is changed. It is expected that tests will fail
    // loudly if these values are not updated in-step with eachother.
    uint256 internal constant DATA_OFFSET = 104;
    uint256 internal constant ADDRESS_OFFSET = 72;

    /*//////////////////////////////////////////////////////////////
                           WRITE LOGIC
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Write a string to contract bytecode
     * @param _data string to be written to contract. No input validation is performed on this parameter.
     * @return address_ address of deployed contract with bytecode containing concat(gated-cleanup-logic, address, data)
     */
    function writeToBytecode(
        string memory _data
    ) internal returns (address address_) {
        // prefix bytecode with
        bytes memory creationCode = abi.encodePacked(
            //---------------------------------------------------------------------------------------------------------------//
            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //
            //---------------------------------------------------------------------------------------------------------------//
            // (0) creation code returns all code in the contract except for the first 11 (0B in hex) bytes, as these 11
            //     bytes are the creation code itself which we do not want to store in the deployed storage contract result
            //---------------------------------------------------------------------------------------------------------------//
            // 0x60    |  0x60_0B            | PUSH1 11     | codeOffset                                                     //
            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //
            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //
            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //
            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //
            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //
            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //
            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //
            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //
            // 0xf3    |  0xf3               | RETURN       |                                                                //
            //---------------------------------------------------------------------------------------------------------------//
            // (11 bytes)
            hex"60_0B_59_81_38_03_80_92_59_39_F3",
            //---------------------------------------------------------------------------------------------------------------//
            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //
            //---------------------------------------------------------------------------------------------------------------//
            // (1a) conditional logic for determing purge-gate (only the bytecode contract deployer can `selfdestruct`)
            //---------------------------------------------------------------------------------------------------------------//
            // 0x60    |  0x60_20            | PUSH1 32           | 32                                                       //
            // 0x60    |  0x60_48            | PUSH1 72 (*)       | contractOffset 32                                        //
            // 0x60    |  0x60_00            | PUSH1 0            | 0 contractOffset 32                                      //
            // 0x39    |  0x39               | CODECOPY           |                                                          //
            // 0x60    |  0x60_00            | PUSH1 0            | 0                                                        //
            // 0x51    |  0x51               | MLOAD              | byteDeployerAddress                                      //
            // 0x33    |  0x33               | CALLER             | msg.sender byteDeployerAddress                           //
            // 0x14    |  0x14               | EQ                 | (msg.sender == byteDeployerAddress)                      //
            //---------------------------------------------------------------------------------------------------------------//
            // (12 bytes: 0-11 in deployed contract)
            hex"60_20_60_48_60_00_39_60_00_51_33_14",
            //---------------------------------------------------------------------------------------------------------------//
            // (1b) load up the destination jump address for `(2a) calldata length check` logic, jump or raise `invalid` op-code
            //---------------------------------------------------------------------------------------------------------------//
            // 0x60    |  0x60_10            | PUSH1 16 (^)       | jumpDestination (msg.sender == byteDeployerAddress)      //
            // 0x57    |  0x57               | JUMPI              |                                                          //
            // 0xFE    |  0xFE               | INVALID            |                                                          //
            //---------------------------------------------------------------------------------------------------------------//
            // (4 bytes: 12-15 in deployed contract)
            hex"60_10_57_FE",
            //---------------------------------------------------------------------------------------------------------------//
            // (2a) conditional logic for determing purge-gate (only if calldata length is 1 byte)
            //---------------------------------------------------------------------------------------------------------------//
            // 0x5B    |  0x5B               | JUMPDEST (16)      |                                                          //
            // 0x60    |  0x60_01            | PUSH1 1            | 1                                                        //
            // 0x36    |  0x36               | CALLDATASIZE       | calldataSize 1                                           //
            // 0x14    |  0x14               | EQ                 | (calldataSize == 1)                                      //
            //---------------------------------------------------------------------------------------------------------------//
            // (5 bytes: 16-20 in deployed contract)
            hex"5B_60_01_36_14",
            //---------------------------------------------------------------------------------------------------------------//
            // (2b) load up the destination jump address for `(3a) calldata value check` logic, jump or raise `invalid` op-code
            //---------------------------------------------------------------------------------------------------------------//
            // 0x60    |  0x60_19            | PUSH1 25 (^)       | jumpDestination (calldataSize == 1)                      //
            // 0x57    |  0x57               | JUMPI              |                                                          //
            // 0xFE    |  0xFE               | INVALID            |                                                          //
            //---------------------------------------------------------------------------------------------------------------//
            // (4 bytes: 21-24 in deployed contract)
            hex"60_19_57_FE",
            //---------------------------------------------------------------------------------------------------------------//
            // (3a) conditional logic for determing purge-gate (only if calldata is `0xFF`)
            //---------------------------------------------------------------------------------------------------------------//
            // 0x5B    |  0x5B               | JUMPDEST (25)      |                                                          //
            // 0x60    |  0x60_00            | PUSH1 0            | 0                                                        //
            // 0x35    |  0x35               | CALLDATALOAD       | calldata                                                 //
            // 0x7F    |  0x7F_FF_00_..._00  | PUSH32 0xFF00...00 | 0xFF0...00 calldata                                      //
            // 0x14    |  0x14               | EQ                 | (0xFF00...00 == calldata)                                //
            //---------------------------------------------------------------------------------------------------------------//
            // (4 bytes: 25-28 in deployed contract)
            hex"5B_60_00_35",
            // (33 bytes: 29-61 in deployed contract)
            hex"7F_FF_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00",
            // (1 byte: 62 in deployed contract)
            hex"14",
            //---------------------------------------------------------------------------------------------------------------//
            // (3b) load up the destination jump address for actual purging (4), jump or raise `invalid` op-code
            //---------------------------------------------------------------------------------------------------------------//
            // 0x60    |  0x60_43            | PUSH1 67 (^)       | jumpDestination (0xFF00...00 == calldata)                //
            // 0x57    |  0x57               | JUMPI              |                                                          //
            // 0xFE    |  0xFE               | INVALID            |                                                          //
            //---------------------------------------------------------------------------------------------------------------//
            // (4 bytes: 63-66 in deployed contract)
            hex"60_43_57_FE",
            //---------------------------------------------------------------------------------------------------------------//
            // (4) perform actual purging
            //---------------------------------------------------------------------------------------------------------------//
            // 0x5B    |  0x5B               | JUMPDEST (67)      |                                                          //
            // 0x60    |  0x60_00            | PUSH1 0            | 0                                                        //
            // 0x51    |  0x51               | MLOAD              | byteDeployerAddress                                      //
            // 0xFF    |  0xFF               | SELFDESTRUCT       |                                                          //
            //---------------------------------------------------------------------------------------------------------------//
            // (5 bytes: 67-71 in deployed contract)
            hex"5B_60_00_51_FF",
            //---------------------------------------------------------------------------------------------------------------//
            // (*) Note: this value must be adjusted if selfdestruct purge logic is adjusted, to refer to the correct start  //
            //           offset for where the `msg.sender` address was stored in deployed bytecode.                          //
            //                                                                                                               //
            // (^) Note: this value must be adjusted if portions of the selfdestruct purge logic are adjusted.               //
            //---------------------------------------------------------------------------------------------------------------//
            //
            // store the deploying-contract's address (to be used to gate and call `selfdestruct`),
            // with expected 0-padding to fit a 20-byte address into a 30-byte slot.
            //
            // note: it is important that this address is the executing contract's address
            //      (the address that represents the client-application smart contract of this library)
            //      which means that it is the responsibility of the client-application smart contract
            //      to determine how deletes are gated (or if they are exposed at all) as it is only
            //      this contract that will be able to call `purgeBytecode` as the `CALLER` that is
            //      checked above (op-code 0x33).
            hex"00_00_00_00_00_00_00_00_00_00_00_00", // left-pad 20-byte address with 12 0x00 bytes
            address(this),
            // uploaded data (stored as bytecode) comes last
            _data
        );

        assembly {
            // deploy a new contract with the generated creation code.
            // start 32 bytes into creationCode to avoid copying the byte length.
            address_ := create(0, add(creationCode, 0x20), mload(creationCode))
        }

        // address must be non-zero if contract was deployed successfully
        require(address_ != address(0), "ContractAsStorage: Write Error");
    }

    /*//////////////////////////////////////////////////////////////
                               READ LOGIC
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Read a string from contract bytecode
     * @param _address address of deployed contract with bytecode containing concat(gated-cleanup-logic, address, data)
     * @return data string read from contract bytecode
     */
    function readFromBytecode(
        address _address
    ) internal view returns (string memory data) {
        // get the size of the bytecode
        uint256 bytecodeSize = _bytecodeSizeAt(_address);
        // handle case where address contains code < DATA_OFFSET
        // note: the first check here also captures the case where
        //       (bytecodeSize == 0) implicitly, but we add the second check of
        //       (bytecodeSize == 0) as a fall-through that will never execute
        //       unless `DATA_OFFSET` is set to 0 at some point.
        if ((bytecodeSize < DATA_OFFSET) || (bytecodeSize == 0)) {
            revert("ContractAsStorage: Read Error");
        }
        // handle case where address contains code >= DATA_OFFSET
        // decrement by DATA_OFFSET to account for purge logic
        uint256 size;
        unchecked {
            size = bytecodeSize - DATA_OFFSET;
        }

        assembly {
            // allocate free memory
            data := mload(0x40)
            // update free memory pointer
            // use and(x, not(0x1f) as cheaper equivalent to sub(x, mod(x, 0x20)).
            // adding 0x1f to size + logic above ensures the free memory pointer
            // remains word-aligned, following the Solidity convention.
            mstore(0x40, add(data, and(add(add(size, 0x20), 0x1f), not(0x1f))))
            // store length of data in first 32 bytes
            mstore(data, size)
            // copy code to memory, excluding the gated-cleanup-logic and address
            extcodecopy(_address, add(data, 0x20), DATA_OFFSET, size)
        }
    }

    /**
     * @notice Get address for deployer for given contract bytecode
     * @param _address address of deployed contract with bytecode containing concat(gated-cleanup-logic, address, data)
     * @return writerAddress address read from contract bytecode
     */
    function getWriterAddressForBytecode(
        address _address
    ) internal view returns (address) {
        // get the size of the data
        uint256 bytecodeSize = _bytecodeSizeAt(_address);
        // handle case where address contains code < DATA_OFFSET
        // note: the first check here also captures the case where
        //       (bytecodeSize == 0) implicitly, but we add the second check of
        //       (bytecodeSize == 0) as a fall-through that will never execute
        //       unless `DATA_OFFSET` is set to 0 at some point.
        if ((bytecodeSize < DATA_OFFSET) || (bytecodeSize == 0)) {
            revert("ContractAsStorage: Read Error");
        }

        assembly {
            // allocate free memory
            let writerAddress := mload(0x40)
            // shift free memory pointer by one slot
            mstore(0x40, add(mload(0x40), 0x20))
            // copy the 32-byte address of the data contract writer to memory
            // note: this relies on the assumption noted at the top-level of
            //       this file that the storage layout for the deployed
            //       contracts-as-storage contract looks like:
            //       | gated-cleanup-logic | deployer-address (padded) | data |
            extcodecopy(
                _address,
                writerAddress,
                ADDRESS_OFFSET,
                0x20 // full 32-bytes, as address is expected to be zero-padded
            )
            return(
                writerAddress,
                0x20 // return size is entire slot, as it is zero-padded
            )
        }
    }

    /*//////////////////////////////////////////////////////////////
                              DELETE LOGIC
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Purge contract bytecode for cleanup purposes
     * note: Although this does reduce usage of Ethereum state, it does not reduce the gas costs of removal
     * transactions. We believe this is the best behavior at the time of writing, and do not expect this to
     * result in any breaking changes in the future. All current proposals to change the self-destruct opcode
     * are backwards compatible, but may result in not removing the bytecode from the blockchain state. This
     * implementation is compatible with that architecture, as it does not rely on the bytecode being removed
     * from the blockchain state (as opposed to using a CREATE2 style opcode when creating bytecode contracts,
     * which could be used in a way that may rely on the bytecode being removed from the blockchain state,
     * e.g. replacing a contract at a given deployed address).
     * @param _address address of deployed contract with bytecode containing concat(gated-cleanup-logic, address, data)
     * @dev This contract is only callable by the address of the contract that originally deployed the bytecode
     *      being purged. If this method is called by any other address, it will revert with the `INVALID` op-code.
     *      Additionally, for security purposes, the contract must be called with calldata `0xFF` to ensure that
     *      the `selfdestruct` op-code is intentionally being invoked, otherwise the `INVALID` op-code will be raised.
     */
    function purgeBytecode(address _address) internal {
        // deployed bytecode (above) handles all logic for purging state, so no
        // call data is expected to be passed along to perform data purge
        (bool success /* `data` not needed */, ) = _address.call(hex"FF");
        if (!success) {
            revert("ContractAsStorage: Delete Error");
        }
    }

    /*//////////////////////////////////////////////////////////////
                          INTERNAL HELPER LOGIC
    //////////////////////////////////////////////////////////////*/

    /**
        @notice Returns the size of the bytecode at address `_address`
        @param _address address that may or may not contain bytecode
        @return size size of the bytecode code at `_address`
    */
    function _bytecodeSizeAt(
        address _address
    ) private view returns (uint256 size) {
        assembly {
            size := extcodesize(_address)
        }
    }
}

// SPDX-License-Identifier: LGPL-3.0-only
// Created By: Art Blocks Inc.
// Inspired by: https://ethereum.stackexchange.com/a/123950/103422

pragma solidity ^0.8.0;

/**
 * @dev Operations on bytes32 data type, dealing with conversion to string.
 */
library Bytes32Strings {
    /**
     * @dev Intended to convert a `bytes32`-encoded string literal to `string`.
     * Trims zero padding to arrive at original string literal.
     */
    function toString(
        bytes32 source
    ) internal pure returns (string memory result) {
        uint8 length = 0;
        while (source[length] != 0 && length < 32) {
            length++;
        }
        assembly {
            // free memory pointer
            result := mload(0x40)
            // update free memory pointer to new "memory end"
            // (offset is 64-bytes: 32 for length, 32 for data)
            mstore(0x40, add(result, 0x40))
            // store length in first 32-byte memory slot
            mstore(result, length)
            // write actual data in second 32-byte memory slot
            mstore(add(result, 0x20), source)
        }
    }

    /**
     * @dev Intended to check if a `bytes32`-encoded string contains a given
     * character with UTF-8 character code `utf8CharCode exactly `targetQty`
     * times. Does not support searching for multi-byte characters, only
     * characters with UTF-8 character codes < 0x80.
     */
    function containsExactCharacterQty(
        bytes32 source,
        uint8 utf8CharCode,
        uint8 targetQty
    ) internal pure returns (bool) {
        uint8 _occurrences = 0;
        uint8 i;
        for (i = 0; i < 32; ) {
            uint8 _charCode = uint8(source[i]);
            // if not a null byte, or a multi-byte UTF-8 character, check match
            if (_charCode != 0 && _charCode < 0x80) {
                if (_charCode == utf8CharCode) {
                    unchecked {
                        // no risk of overflow since max 32 iterations < max uin8=255
                        ++_occurrences;
                    }
                }
            }
            unchecked {
                // no risk of overflow since max 32 iterations < max uin8=255
                ++i;
            }
        }
        return _occurrences == targetQty;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

///////////////////////////////////////////////////////////
// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //
// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //
// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //
// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //
// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //
// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //
///////////////////////////////////////////////////////////

interface IContractScript {
    // =============================================================
    //                            GETTERS
    // =============================================================

    /**
     * @notice Get the full script
     * @param name - Name given to the script. Eg: threejs.min.js_r148
     * @param data - Arbitrary data to be passed to storage
     * @return script - Full script from merged chunks
     */
    function getScript(string calldata name, bytes memory data)
        external
        view
        returns (bytes memory script);
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

///////////////////////////////////////////////////////////
// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //
// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //
// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //
// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //
// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //
// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //
///////////////////////////////////////////////////////////

// =============================================================
//                            STRUCTS
// =============================================================

struct WrappedScriptRequest {
    string name;
    address contractAddress;
    bytes contractData;
    uint8 wrapType;
    bytes wrapPrefix;
    bytes wrapSuffix;
    bytes scriptContent;
}

struct InlineScriptRequest {
    string name;
    address contractAddress;
    bytes contractData;
    bytes scriptContent;
}

interface IScriptyBuilder {

    // =============================================================
    //                            ERRORS
    // =============================================================

    /**
     * @notice Error for, Invalid length of requests
     */
    error InvalidRequestsLength();

    // =============================================================
    //                      RAW HTML GETTERS
    // =============================================================

    /**
     * @notice Get requested scripts housed in <body> with custom wrappers
     * @dev Your requested scripts are returned in the following format:
     *      <html>
     *          <head></head>
     *          <body style='margin:0;'>
     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]
     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]
     *              ...
     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]
     *          </body>
     *      </html>
     * @param requests - Array of WrappedScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return Full html wrapped scripts
     */
    function getHTMLWrapped(
        WrappedScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (bytes memory);

    /**
     * @notice Get requested scripts housed in URL Safe wrappers
     * @dev Any wrapper type 0 scripts are converted to base64 and wrapped
     *      with <script src="data:text/javascript;base64,[SCRIPT]"></script>
     *
     *      [WARNING]: Large non-base64 libraries that need base64 encoding
     *      carry a high risk of causing a gas out. Highly advised to use
     *      base64 encoded scripts where possible
     *
     *      Your requested scripts are returned in the following format:
     *      <html>
     *          <head></head>
     *          <body style='margin:0;'>
     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]
     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]
     *              ...
     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]
     *          </body>
     *      </html>
     * @param requests - Array of WrappedScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return Full URL Safe wrapped scripts
     */
    function getHTMLWrappedURLSafe(
        WrappedScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (bytes memory);

    /**
     * @notice Get requested scripts housed in <body> all wrapped in <script></script>
     * @dev Your requested scripts are returned in the following format:
     *      <html>
     *          <head></head>
     *          <body style='margin:0;'>
     *              <script>
     *                  {request[0]}
     *                  {request[1]}
     *                  ...
     *                  {request[n]}
     *              </script>
     *          </body>
     *      </html>
     * @param requests - Array of InlineScriptRequest
     * @param bufferSize - Total buffer size of all requested scripts
     * @return Full html wrapped scripts
     */
    function getHTMLInline(
        InlineScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (bytes memory);

    // =============================================================
    //                      ENCODED HTML GETTERS
    // =============================================================

    /**
     * @notice Get {getHTMLWrapped} and base64 encode it
     * @param requests - Array of WrappedScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return Full html wrapped scripts, base64 encoded
     */
    function getEncodedHTMLWrapped(
        WrappedScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (bytes memory);

    /**
     * @notice Get {getHTMLInline} and base64 encode it
     * @param requests - Array of InlineScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return Full html wrapped scripts, base64 encoded
     */
    function getEncodedHTMLInline(
        InlineScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (bytes memory);

    // =============================================================
    //                      STRING UTILITIES
    // =============================================================

    /**
     * @notice Convert {getHTMLWrapped} output to a string
     * @param requests - Array of WrappedScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return {getHTMLWrapped} as a string
     */
    function getHTMLWrappedString(
        WrappedScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (string memory);

    /**
     * @notice Convert {getHTMLInline} output to a string
     * @param requests - Array of InlineScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     * @return {getHTMLInline} as a string
     */
    function getHTMLInlineString(
        InlineScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (string memory);

    /**
     * @notice Convert {getEncodedHTMLWrapped} output to a string
     * @param requests - Array of WrappedScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     *                     before encoding.
     * @return {getEncodedHTMLWrapped} as a string
     */
    function getEncodedHTMLWrappedString(
        WrappedScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (string memory);

    /**
     * @notice Convert {getEncodedHTMLInline} output to a string
     * @param requests - Array of InlineScriptRequests
     * @param bufferSize - Total buffer size of all requested scripts
     *                     before encoding.
     * @return {getEncodedHTMLInline} as a string
     */
    function getEncodedHTMLInlineString(
        InlineScriptRequest[] calldata requests,
        uint256 bufferSize
    ) external view returns (string memory);

    // =============================================================
    //                      OFF-CHAIN UTILITIES
    // =============================================================

    /**
     * @notice Get the buffer size of a single inline requested code
     * @param request - InlineScriptRequest data for code
     * @return Buffer size as an unit256
     */
    function getInlineScriptSize(InlineScriptRequest memory request)
        external
        view
        returns (uint256);

    /**
     * @notice Get the buffer size of a single wrapped requested code
     * @param request - WrappedScriptRequest data for code
     * @return Buffer size as an unit256
     */
    function getWrappedScriptSize(WrappedScriptRequest memory request)
        external
        view
        returns (uint256);

    /**
     * @notice Get the buffer size of a single wrapped requested code
     * @dev If the script is of wrapper type 0, we get buffer size for
     *      base64 encoded version.
     * @param request - WrappedScriptRequest data for code
     * @return Buffer size as an unit256
     */
    function getURLSafeWrappedScriptSize(WrappedScriptRequest memory request)
    external
    view
    returns (uint256);

    /**
     * @notice Get the buffer size of an array of html wrapped inline scripts
     * @param requests - InlineScriptRequests data for code
     * @return Buffer size as an unit256
     */
    function getBufferSizeForHTMLInline(InlineScriptRequest[] calldata requests)
        external
        view
        returns (uint256);

    /**
     * @notice Get the buffer size of an array of html wrapped, wrapped scripts
     * @param requests - WrappedScriptRequests data for code
     * @return Buffer size as an unit256
     */
    function getBufferSizeForHTMLWrapped(
        WrappedScriptRequest[] calldata requests
    ) external view returns (uint256);

    /**
     * @notice Get the buffer size of an array of URL safe html wrapped scripts
     * @param requests - WrappedScriptRequests data for code
     * @return Buffer size as an unit256
     */
    function getBufferSizeForURLSafeHTMLWrapped(
        WrappedScriptRequest[] calldata requests
    ) external view returns (uint256);
    
    /**
     * @notice Get the buffer size for encoded HTML inline scripts
     * @param requests - InlineScriptRequests data for code
     * @return Buffer size as an unit256
     */
    function getBufferSizeForEncodedHTMLInline(
        InlineScriptRequest[] calldata requests
    ) external view returns (uint256);

    /**
     * @notice Get the buffer size for encoded HTML inline scripts
     * @param requests - InlineScriptRequests data for code
     * @return Buffer size as an unit256
     */
    function getBufferSizeForEncodedHTMLWrapped(
        WrappedScriptRequest[] calldata requests
    ) external view returns (uint256);
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title AddressChunks
 * @author @xtremetom
 * @notice Reads chunk pointers and merges their values
 */
library AddressChunks {
    function mergeChunks(address[] memory chunks)
        internal
        view
        returns (bytes memory o_code)
    {
        unchecked {
            assembly {
                let len := mload(chunks)
                let totalSize := 0x20
                let size := 0
                o_code := mload(0x40)

                // loop through all chunk addresses
                // - get address
                // - get data size
                // - get code and add to o_code
                // - update total size
                let targetChunk := 0
                for {
                    let i := 0
                } lt(i, len) {
                    i := add(i, 1)
                } {
                    targetChunk := mload(add(chunks, add(0x20, mul(i, 0x20))))
                    size := sub(extcodesize(targetChunk), 1)
                    extcodecopy(targetChunk, add(o_code, totalSize), 1, size)
                    totalSize := add(totalSize, size)
                }

                // update o_code size
                mstore(o_code, sub(totalSize, 0x20))
                // store o_code
                mstore(0x40, add(o_code, and(add(totalSize, 0x1f), not(0x1f))))
            }
        }
    }
}