// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// import "./interfaces/IMember1155.sol";
// import "./interfaces/IoDAO.sol";
// import "./interfaces/iInstanceDAO.sol";
// import "./interfaces/IMembrane.sol";
// import "./interfaces/IExternalCall.sol";
// import "./utils/Address.sol";
// import "./DAO20.sol";
// import "./errors.sol";

import "./interfaces/IERC20.sol";
import "./interfaces/ICantoTurnstile.sol";

/// @notice CSRVault accumulates CANTO from CSR and makes it redeamable in exchange for the burning of one known and FRIENDLY (@security) token.

contract CSRvault {
    uint256 public CSRtokenID;
    address public turnSaddr;
    address public sharesTokenAddr;

    IERC20 WrapperToken;
    ITurnstile CSR;

    error CSRvault__NotSelfRegistered();
    error CSRvault__NotContract();
    error CSRvault__NonReentrant();

    /// @param sharesToken_ token that acts as fungible redeamable shares for available Canto CSR revenue
    /// @param turnstileAddress_ canto CSR turnstile address
    constructor(address sharesToken_, address turnstileAddress_) {
        WrapperToken = IERC20(sharesToken_);
        CSR = ITurnstile(turnstileAddress_);
        CSRtokenID = CSR.register(address(this));
        turnSaddr = turnstileAddress_;
        sharesTokenAddr = sharesToken_;
    }

    function withdrawBurn(uint256 amountToBurn) public returns (bool s) {
        s = WrapperToken.transferFrom(msg.sender, address(this), amountToBurn);
        CSR.distributeFees(CSRtokenID);
        CSR.withdraw(CSRtokenID, payable(address(this)), CSR.balances(CSRtokenID));

        amountToBurn = (amountToBurn * 1_000_000_000 * address(this).balance)
            / (WrapperToken.totalSupply() - WrapperToken.balanceOf(address(this))) / 1_000_000_000;
        s = s && payable(msg.sender).send(amountToBurn);
        require(s, "transfer or qty issue");
    }
}

// SPDX-License-Identifier: GPLv3
pragma solidity 0.8.13;

/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md
/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.
///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.
///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.
interface ITurnstile {
    struct NftData {
        uint256 tokenId;
        bool registered;
    }

    /// @notice Returns current value of counter used to tokenId of new minted NFTs
    /// @return current counter value
    function currentCounterId() external view returns (uint256);
    /// @notice Returns tokenId that collects fees generated by the smart contract
    /// @param _smartContract address of the smart contract
    /// @return tokenId that collects fees generated by the smart contract
    function getTokenId(address _smartContract) external view returns (uint256);

    /// @notice Returns true if smart contract is registered to collect fees
    /// @param _smartContract address of the smart contract
    /// @return true if smart contract is registered to collect fees, false otherwise
    function isRegistered(address _smartContract) external view returns (bool);

    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.
    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself
    ///         can register a fee receipient.
    /// @param _recipient recipient of the ownership NFT
    /// @return tokenId of the ownership NFT that collects fees
    function register(address _recipient) external returns (uint256 tokenId);

    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.
    ///         Callable only by smart contract itself.
    /// @param _tokenId tokenId which will collect fees
    /// @return tokenId of the ownership NFT that collects fees
    function assign(uint256 _tokenId) external returns (uint256);

    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.
    /// @param _tokenId token Id
    /// @param _recipient recipient of fees
    /// @param _amount amount of fees to withdraw
    /// @return amount of fees withdrawn
    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount) external returns (uint256);

    /// @notice Distributes collected fees to the smart contract. Only callable by owner.
    /// @param _tokenId NFT that earned fees
    function distributeFees(uint256 _tokenId) external;

    function balances(uint256 _tokenId) external view returns (uint256);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}