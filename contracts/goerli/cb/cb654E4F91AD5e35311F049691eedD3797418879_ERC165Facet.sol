// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {LibERC165, ERC165Storage} from "../libraries/LibERC165.sol";
import {IERC165} from "../interfaces/IERC165.sol";

contract ERC165Facet is IERC165 {
  // This implements ERC-165.
  function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
    ERC165Storage storage ds = LibERC165.DS();
    return ds.supportedInterfaces[_interfaceId];
  }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC165 {
  /// @notice Query if a contract implements an interface
  /// @param interfaceId The interface identifier, as specified in ERC-165
  /// @dev Interface identification is specified in ERC-165. This function
  ///  uses less than 30,000 gas.
  /// @return `true` if the contract implements `interfaceID` and
  ///  `interfaceID` is not 0xffffffff, `false` otherwise
  function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {ERC165Storage} from "../types/erc165/ERC165Storage.sol";

library LibERC165 {
  bytes32 internal constant ERC165_STORAGE_POSITION = keccak256("diamond.standard.erc165.storage");

  function DS() internal pure returns (ERC165Storage storage ds) {
    bytes32 position = ERC165_STORAGE_POSITION;
    assembly {
      ds.slot := position
    }
  }

  function addSupportedInterfaces(bytes4[] memory _interfaces) internal {
    ERC165Storage storage ds = DS();
    for (uint256 i; i < _interfaces.length; i++) {
      ds.supportedInterfaces[_interfaces[i]] = true;
    }
  }

  function addSupportedInterface(bytes4 _interface) internal {
    ERC165Storage storage ds = DS();
    ds.supportedInterfaces[_interface] = true;
  }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

struct ERC165Storage {
  // Used to query if a contract implements an interface.
  // Used to implement ERC-165.
  mapping(bytes4 => bool) supportedInterfaces;
}