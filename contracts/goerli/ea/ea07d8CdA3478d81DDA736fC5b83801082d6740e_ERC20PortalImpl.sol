// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// Copyright 2021 Cartesi Pte. Ltd.

// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use
// this file except in compliance with the License. You may obtain a copy of the
// License at http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// @title Generic ERC20 Portal
pragma solidity >=0.7.0;

interface ERC20Portal {
    /// @notice deposit an amount of a generic ERC20 in the portal contract and create tokens in L2
    /// @param _ERC20 address of the ERC20 token contract
    /// @param _amount amount of the ERC20 token to be deposited
    /// @param _data information to be interpreted by L2
    /// @return hash of input generated by deposit
    function erc20Deposit(
        address _ERC20,
        uint256 _amount,
        bytes calldata _data
    ) external returns (bytes32);

    /// @notice execute a rollups voucher
    /// @param _data data with information necessary to execute voucher
    /// @dev can only be called by the Output contract
    function executeRollupsVoucher(bytes calldata _data)
        external
        returns (bool);

    // @notice emitted on ERC20 deposited
    event ERC20Deposited(
        address _ERC20,
        address _sender,
        uint256 _amount,
        bytes _data
    );

    // @notice emitted on ERC20 withdrawal
    event ERC20Withdrawn(
        address _ERC20,
        address payable _receiver,
        uint256 _amount
    );
}

// Copyright 2021 Cartesi Pte. Ltd.

// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use
// this file except in compliance with the License. You may obtain a copy of the
// License at http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// @title Generic ERC20 Portal Implementation
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./ERC20Portal.sol";
import "./Input.sol";

contract ERC20PortalImpl is ERC20Portal {
    address immutable outputContract;
    Input immutable inputContract;

    modifier onlyOutputContract {
        require(msg.sender == outputContract, "only outputContract");
        _;
    }

    constructor(address _inputContract, address _outputContract) {
        inputContract = Input(_inputContract);
        outputContract = _outputContract;
    }

    /// @notice deposit an amount of a generic ERC20 in the portal contract and create tokens in L2
    /// @param _ERC20 address of the ERC20 token contract
    /// @param _amount amount of the ERC20 token to be deposited
    /// @param _data information to be interpreted by L2
    /// @return hash of input generated by deposit
    function erc20Deposit(
        address _ERC20,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes32) {
        IERC20 token = IERC20(_ERC20);

        require(
            token.transferFrom(msg.sender, address(this), _amount),
            "ERC20 transferFrom failed"
        );

        bytes memory input =
            abi.encode(
                msg.sender,
                _ERC20,
                _amount,
                _data
            );

        emit ERC20Deposited(_ERC20, msg.sender, _amount, _data);
        return inputContract.addInput(input);
    }

    /// @notice execute a rollups voucher
    /// @param _data data with information necessary to execute voucher
    /// @dev can only be called by the Output contract
    function executeRollupsVoucher(bytes calldata _data)
        public
        override
        onlyOutputContract
        returns (bool)
    {
        (
            address tokenAddr,
            address payable receiver,
            uint256 value
        ) = abi.decode(_data, (address, address, uint256));

        IERC20 token = IERC20(tokenAddr);

        // transfer reverts on failure
        token.transfer(receiver, value);

        emit ERC20Withdrawn(tokenAddr, receiver, value);

        return true;
    }
}

// Copyright 2021 Cartesi Pte. Ltd.

// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use
// this file except in compliance with the License. You may obtain a copy of the
// License at http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// @title Input
pragma solidity >=0.7.0;

interface Input {
    /// @notice adds input to correct inbox
    /// @param _input bytes array of input
    /// @return merkle root hash of input
    /// @dev  msg.sender and timestamp are preppended log2 size
    ///       has to be calculated offchain taking that into account
    function addInput(bytes calldata _input) external returns (bytes32);

    /// @notice returns input from correct input inbox
    /// @param _index position of the input on inbox
    /// @return root hash of input
    function getInput(uint256 _index) external view returns (bytes32);

    /// @notice returns number of inputs on correct inbox
    /// @return number of inputs of non active inbox
    function getNumberOfInputs() external view returns (uint256);

    /// @notice returns active current inbox index
    /// @return index of current active inbox
    function getCurrentInbox() external view returns (uint256);

    /// @notice called whenever there is a new input accumulation epoch
    /// @dev has to be  called even if new input accumulation happens
    ///      implicitly due to a new epoch
    function onNewInputAccumulation() external;

    /// @notice called when a new epoch begins, clears correct input box
    function onNewEpoch() external;

    /// @notice input added
    /// @param _epochNumber which epoch this input belongs to
    /// @param _sender msg.sender
    /// @param _timestamp block.timestamp
    /// @param _input input data
    event InputAdded(
        uint256 indexed _epochNumber,
        address _sender,
        uint256 _timestamp,
        bytes _input
    );
}