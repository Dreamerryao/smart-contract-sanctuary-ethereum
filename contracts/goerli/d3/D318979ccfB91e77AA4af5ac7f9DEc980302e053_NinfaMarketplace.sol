// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

import "./token/ERC721/IERC721Ninfa.sol";
import "./token/ERC1155/IERC1155.sol";
import "./token/common/IERC2981.sol";
import "./token/ERC1155/utils/ERC1155Holder.sol";
import "./token/ERC721/utils/ERC721Holder.sol"; // TODO is this import needed? i.e. Will creating orders by sending tokens with data bytes as function parameters be cheaper than the old function (including the fact that approving is not needed anymore)
import "./factory/IPaymentSplitterFactory.sol";
import "./factory/INinfaERC1155Factory.sol";
import "./finance/IPaymentSplitter.sol";
import "./utils/introspection/IERC165.sol";
import "./utils/introspection/ERC165Checker.sol";
import "./utils/Counters.sol"; // Counters or CountersUpgradable makes no difference being a library
import "./access/AccessControl.sol";

/**
    ███    ██ ██ ███    ██ ███████  █████  
    ████   ██ ██ ████   ██ ██      ██   ██ 
    ██ ██  ██ ██ ██ ██  ██ █████   ███████ 
    ██  ██ ██ ██ ██  ██ ██ ██      ██   ██ 
    ██   ████ ██ ██   ████ ██      ██   ██                                                                               
 */

/// @custom:security-contact [email protected]
contract NinfaMarketplace is
    AccessControl, // {AccessControl} doesn’t allow enumerating role members, whereas {AccessControlEnumerable} allows it. The additional "enumerable" functions are getRoleMember(role, index) and getRoleMemberCount(role). The role member can be enumerated by frontend using events, therefore the enumerable extension is not needed to be read on-chain.
    ERC1155Holder,
    ERC721Holder
{
    /*************
     * VARIABLES *
     ************/

    IERC721Ninfa public NinfaERC721;
    IPaymentSplitterFactory public PaymentSplitterFactory;
    INinfaERC1155Factory public NinfaERC1155Factory;

    using Counters for Counters.Counter; // counters for marketplace offers and orders
    using ERC165Checker for address;
    Counters.Counter private _orderCount; // orders counter
    Counters.Counter private _offerCount; // offers counter

    bytes32 private constant CURATOR_ROLE =
        0x850d585eb7f024ccee5e68e55f2c26cc72e1e6ee456acf62135757a5eb9d4a10; // hardcoded hash equivalent to keccak256("CURATOR_ROLE"); CURATOR_ROLE is the "role admin" of ARTIST_ROLE, i.e. it is the only account that can grant and revoke roles to artists. This was added to avoid having a DEFAULT_ADMIN_ROLE approve artists, which would introduce security risks if different from a multisig, and usability issues if each time a multisig was needed to approve artists.
    bytes32 private constant ARTIST_ROLE =
        0x877a78dc988c0ec5f58453b44888a55eb39755c3d5ed8d8ea990912aa3ef29c6; // hardcoded hash equivalent to keccak256("ARTIST_ROLE"); Since there isn't a getter function, it can be copied from the source code. The ARTIST_ROLE allows an address to mint tokens
    bytes4 private constant INTERFACE_ID_ERC2981 = 0x2a55205a; // https://eips.ethereum.org/EIPS/eip-2981

    uint24 private ninfaPrimaryFee; // Ninfa Marketplace fee percentage for primary sales, expressed in basis points. It is not constant because primary sale fees are at 0% for 2022 and will need to be set afterwards to 10%.
    uint24 private constant NINFA_SECONDARY_FEE = 500; // 5% fee on all secondary sales paid to Ninfa (seller receives the remainder after paying 10% royalties to artist/gallery and 5% Ninfa, i.e. 85%)

    address private constant ZERO_ADDRESS = address(0); // placeholder for address(0)
    address payable private feeAccount; // EOA or contract where to send trading fees generated by the marketplace

    // mapping(address => mapping(uint256 => _Commission)) private _saleCommissions; // The % amount on all primary sales income that an artist received from sales on the marketplacce, destined to a gallery chosen by the artist.
    mapping(address => bool) private NFTWhitelist; // in order to be traded on the Ninfa marketplace, collections need to be manually approved by a multisig contract.
    mapping(uint256 => bool) private secondarySale; // map token Id to bool indicating wether it has been sold before, only applies to the Ninfa collection NFTs, all other collections are considered as secondary sales.
    mapping(uint256 => _Order) public orders; // mapping order id to invoice struct
    mapping(uint256 => _Offer) public offers; // mapping offer id to invoice struct

    /***********
     * STRUCTS *
     **********/

    /**
     * @param from if invoice is for an order, `from` will correspond to the seller, if it represents an offer, `from` will correspond to the buyer
     * @param to if invoice is for an order, `to` will correspond to the buyer, which is useless as it is not possible to know the buyer upfront.
     * It may be useful for direct sales, for this we need a special `fillOrder` function which requires that `msg.sender == to`.
     * If invoice is for an offer, `to` will correspond to the seller, used for access control of erc1155 because a tokenId can have multiple owners.
     * @param price seller ask or buyer bid
     * @param amount 0 if erc721, other if erc1155
     */
    struct _Order {
        address collection;
        uint256 tokenId;
        address from;
        uint256 price;
        uint256 amount;
        address commissionReceiver; // receiver of commission on sales (primary AND secondary)
        uint256 commissionShares; // commission amount, expressed in basis points 0 - 10000
    }

    struct _Offer {
        address collection;
        uint256 tokenId;
        address from;
        uint256 price;
        uint256 amount;
    }

    // created in order to avoid "stack too deep" CompileError in `_trade()` function
    struct _Trade {
        uint256 sellerAmount; // we can't subtract `marketplaceAmount` from `_price` at this point or else it will subtract the `NINFA_SECONDARY_FEE` amount, which means we'd need to calcultate it again for primary sales
        uint256 marketplaceAmount;
        uint256 royaltyAmount;
        uint256 commissionAmount;
        address royaltyReceiver;
        address commissionReceiver;
    }

    /**********
     * EVENTS *
     *********/

    event Order(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 orderId,
        uint256 price,
        uint256 amount
    );

    event Offer(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 offerId,
        uint256 price,
        uint256 amount
    );

    event OrderCancelled(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 orderId,
        uint256 amount
    );

    event OfferCancelled(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 offerId,
        uint256 amount
    );

    event Trade(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from,
        uint256 price,
        address to,
        uint256 amount
        /*, uint256 orderId */ // Only needed for backwards compatibility with Ninfa's DB, todo remove this eventually
    );

    event RoyaltyPayment(
        // This event is also emitted when paying sales commissions
        address indexed collection,
        uint256 indexed tokenId,
        address indexed to,
        uint256 amount
    );

    event Commission(
        // using Commission event as cheap storage for commission info.
        address indexed collection,
        uint256 indexed tokenId,
        address indexed to,
        uint256 saleBps
    );

    /*************
     * MODIFIERS *
     ************/

    /**
     * @notice checks that msg.sender created the order and that the order exists (if it didn't, _order.from would be the 0x0 address)
     */
    modifier isOrderOwner(uint256 _orderId) {
        require(orders[_orderId].from == msg.sender);
        _;
    }

    modifier isOfferOwner(uint256 _offerId) {
        require(offers[_offerId].from == msg.sender); // this implicitly also checks that the offer exists, since msg.sender cannot be == 0x0
        _;
    }

    modifier isArtist(address _collection) {
        require(
            AccessControl(_collection).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)
        );

        _;
    }

    modifier isWhitelisted(address _collection) {
        // ERC721 and ERC1155 must be whitelisted. Comparing the collection to address(ninfa) first is cheaper than whitelisting the ninfa erc721 and then checking the whitelist,
        // however if the collection is not ninfa then it might be slightly more expensive than if we just checked the whitelist
        require(
            _collection == address(NinfaERC721) ||
                NFTWhitelist[_collection] == true
        );

        _;
    }

    /******************
     * ERC721 MINTING *
     *****************/

    /**
     * @notice mint can only be called by approved add
     * @dev placed at the top of the contract to save a little gas as it will be called often.
     * @param _tokenURI the ipfs hash of the token, it needs to be base58 and hex encoded, removing the first two bytes "Qm", in order to fit exactly in 32 bytes.
     * const getBytes32FromIpfsHash = hash => {
     *      let bytes = bs58.decode(hash);
     *      bytes = bytes.slice(2, bytes.length);
     *      return web3.utils.bytesToHex(bytes)
     *  };
     */
    function mint(bytes32 _tokenURI) external onlyRole(ARTIST_ROLE) {
        NinfaERC721.mint(_tokenURI, msg.sender);
    }

    function mintAndTransfer(bytes32 _tokenURI, address _to)
        external
        onlyRole(ARTIST_ROLE)
    {
        uint256 _tokenId = NinfaERC721.totalSupply();

        NinfaERC721.mint(_tokenURI, msg.sender);

        NinfaERC721.transferFrom(msg.sender, _to, _tokenId);
    }

    /**
     * @notice In order to avoid confusion and additional function parameters in the mintAndTransfer function, this function was created for the nieche case where an artist wants to set create a payment splitter contract where to send royalty payments.
     * if the caller wants to set the royalties receiver to an address other than its own, call `mintAndTransfer` instead
     * @param _tokenURI the ipfs hash of the token, it needs to be base58 and hex encoded, removing the first two bytes "Qm", in order to fit exactly in 32 bytes.
     * @param _to after transfering the token to the artist (i.e. minting), the marketplace (needs to be approved) transfers the token from the artist to the `_to` address, normally a gallery.
     * @param _royaltyReceivers can contain just 1 address in order to simply set the address of the royalty receiver to someone
     *
     * Require:
     *
     * - `_commissionShares` must be less than 8501. In the EVM, there is an opcode for `<` and `>`, but not for `<=` or `>=`. That is why `_commissionShares < 8501` is preferable to `_commissionShares <= 8500`.
     * - the artist must set approve the Marketplace for token transfers.
     *
     * Should:
     *
     * - if any of the arrays is empty, the function will revert in all cases.
     *
     */
    function mintSplitAndTransfer(
        bytes32 _tokenURI,
        address _to,
        // address[] calldata _commissionReceivers,
        // uint256[] calldata _commissionShares,
        address[] calldata _royaltyReceivers,
        uint256[] calldata _royaltyShares
    ) external onlyRole(ARTIST_ROLE) {
        uint256 _tokenId = NinfaERC721.totalSupply();
        // uint256 commissionShares;
        // address commissionReceiver;

        /**
         * (Deploy PaymentSplitter contract,) mint and set royalty receiver to an address other than the minter's own.
         */

        if (_royaltyReceivers.length > 1) {
            NinfaERC721.mintAndSetRoyaltyReceiver(
                _tokenURI,
                msg.sender,
                payable(
                    PaymentSplitterFactory.deployClone(
                        _royaltyReceivers,
                        _royaltyShares
                    )
                )
            );
        } else {
            // if _royaltyShares.length == 1 set the royalty receiver as the only address provided in the list. Note that in this case `_royaltyShares` is ignored as the share will be automatically 100%.
            // if _royaltyShares.length == 0 the following function call will fail with an index out of bounds error because the following lines would try to access an emty array at index 0 `_royaltyReceivers[0]`
            NinfaERC721.mintAndSetRoyaltyReceiver(
                _tokenURI,
                msg.sender,
                _royaltyReceivers[0]
            );
        }

        // todo what if the seller wants to send commissions to a single address rather than a payment splitter

        // if (_commissionReceivers.length > 1) {
        //     commissionReceiver = _deployPaymentSplitter(
        //         _commissionReceivers,
        //         _commissionShares
        //     );
        //     for (uint256 i = 0; i < _commissionShares.length; i++) {
        //         commissionShares += _commissionShares[i];
        //     }
        // } else {
        //     // if _commissionShares.length == 1 set the receiver and shares to the only value contained in the two arrays at index 0
        //     // if _commissionShares.length == 0 then there should be an index out of bounds error because the following lines would try to access an emty array
        //     commissionReceiver = _commissionReceivers[0];
        //     commissionShares = _commissionShares[0];
        // }

        /**
         * Transfer NFT to `_commissionReceiver`, i.e. the gallery
         */

        NinfaERC721.transferFrom(msg.sender, _to, _tokenId);
    }

    /*******************
     * ERC1155 MINTING *
     ******************/

    /**
     * @dev this function should only be called if minting and ERC1155 AND transfering it to a gallery, while deploying the needed erc1155 contract first.
     *
     * Require:
     *
     * - `_commissionShares` must be less than 8501. In the EVM, there is an opcode for `<` and `>`, but not for `<=` or `>=`. That is why `_commissionShares < 8501` is preferable to `_commissionShares <= 8500`.
     * - the artist must set approve the Marketplace for token transfers.
     * - only ARTIST_ROLE address can call this function , see modifier in `mintAndTransferERC1155`
     *
     */
    function deployMintAndTransferERC1155(
        bytes32 _tokenURI,
        uint256 _amount,
        address _to,
        string calldata _name,
        string calldata _symbol,
        uint256 _salt
    ) external onlyRole(ARTIST_ROLE) {
        address collection = NinfaERC1155Factory.deployClone(
            _name,
            _symbol,
            msg.sender,
            _salt
        ); // deploy erc1155 from factory contract

        IERC1155(collection).setApprovalForAll(address(this), true);

        mintAndTransferERC1155(_tokenURI, _amount, collection, _to);
    }

    /**
     * @dev this function should only be called if minting and ERC1155 AND transfering it to a gallery.
     *
     * Require:
     *
     * - `_commissionShares` must be less than 8501. In the EVM, there is an opcode for `<` and `>`, but not for `<=` or `>=`. That is why `_commissionShares < 8501` is preferable to `_commissionShares <= 8500`.
     * - the artist must set approve the Marketplace for token transfers.
     * - only the owner of the _collection can mint tokens, not just any artist
     * - require collection is whitelisted. Although prob not strictly necessary as other functions will reject non-whitelisted collections, however they may get added to the frontend as receives the clone deployed event up events
     *
     */
    function mintAndTransferERC1155(
        bytes32 _tokenURI,
        uint256 _amount,
        address _collection,
        address _to
    ) public isArtist(_collection) isWhitelisted(_collection) {
        uint256 _tokenId = IERC1155(_collection).totalSupply();

        IERC1155(_collection).mint(msg.sender, _tokenURI, _amount, "");

        IERC1155(_collection).safeTransferFrom(
            msg.sender,
            _to,
            _tokenId,
            _amount,
            ""
        );
    }

    /********************
     * PAYMENT SPLITTER *
     *******************/

    /**
     * @dev this function should only be called if minting an ERC1155 AND transfering it to a gallery, while also setting the royalty recipient to an address different from the artist's own.
     *
     * Require:
     *
     * - `_royaltyReceivers[]` must contain at least 2 addresses, if more than 1 address is specified a payment splitter contract is deployed and used in order to receive royalty payments.
     * - caller must be collection owner/artist
     *
     */
    function setRoyaltySplitterERC1155(
        address _collection,
        address[] calldata _royaltyReceivers,
        uint256[] calldata _royaltyShares
    ) external isArtist(_collection) {
        require(_royaltyReceivers.length > 1);

        IERC2981(_collection).setRoyaltyReceiver(
            payable(
                PaymentSplitterFactory.deployClone(
                    _royaltyReceivers,
                    _royaltyShares
                )
            )
        );
    }

    /***********
     * TRADING *
     ***********/

    /**
     * @notice create a new order on the marketplace by transfering an NFT to it.
     * @param _collection address of the ERC721 contract
     * @param _tokenId the NFT id, for now we only allow trading NINFA NFT's so no erc721 address is needed
     * @param _price the NFT's price. for now we support only ETH payments.
     * Require:
     *
     * - collection must be whitelisted
     * - price must be more than 0
     *
     */
    function submitOrder(
        address _collection,
        uint256 _tokenId,
        uint256 _price,
        uint256 _amount,
        address _commissionReceiver,
        uint256 _commissionShares
    ) external isWhitelisted(_collection) {
        require(_price > 0); // protecting the user from mistakenly submitting an order for free

        if (_amount == 0) {
            IERC721Ninfa(_collection).transferFrom(
                msg.sender,
                address(this),
                _tokenId
            ); // transfer NFT directly to this contract, reverts on failure. Only NFT owner can transfer the token, i.e. call this function. // According to the EIP, the transfer and transferFrom function will revert if the msg.sender is not the owner of the NFT.
        } else {
            IERC1155(_collection).safeTransferFrom(
                msg.sender,
                address(this),
                _tokenId,
                _amount,
                new bytes(0)
            );
        }

        _orderCount.increment(); // start _orderCount at 1
        orders[_orderCount.current()] = _Order(
            _collection,
            _tokenId,
            msg.sender,
            _price,
            _amount,
            _commissionReceiver,
            _commissionShares
        ); // add order to orders mapping

        emit Order(
            _collection,
            _tokenId,
            msg.sender,
            _orderCount.current(),
            _price,
            _amount
        );
    }

    function submitOrderDeploySplitter(
        address _collection,
        uint256 _tokenId,
        uint256 _price,
        uint256 _amount,
        address[] calldata _commissionReceivers,
        uint256[] calldata _commissionShares
    ) external isWhitelisted(_collection) {
        require(_price > 0); // protecting the user from mistakenly submitting an order for free

        (
            address commissionReceiver,
            uint256 commissionShares
        ) = _deployCommissionSplitter(_commissionReceivers, _commissionShares);

        if (_amount == 0) {
            IERC721Ninfa(_collection).transferFrom(
                msg.sender,
                address(this),
                _tokenId
            ); // transfer NFT directly to this contract, reverts on failure. Only NFT owner can transfer the token, i.e. call this function. // According to the EIP, the transfer and transferFrom function will revert if the msg.sender is not the owner of the NFT.
        } else {
            IERC1155(_collection).safeTransferFrom(
                msg.sender,
                address(this),
                _tokenId,
                _amount,
                new bytes(0)
            );
        }

        _orderCount.increment(); // start _orderCount at 1
        orders[_orderCount.current()] = _Order(
            _collection,
            _tokenId,
            msg.sender,
            _price,
            _amount,
            commissionReceiver,
            commissionShares
        ); // add order to orders mapping

        emit Order(
            _collection,
            _tokenId,
            msg.sender,
            _orderCount.current(),
            _price,
            _amount
        );
    }

    /**
     * @dev `_deployCommissionSplitter` should only be called when deploying a splitter for commissions, not for royalties,
     * since we can't enforce an upper limit of total shares for royalties, because external collections will have different royalties than Ninfa (fixed 10%),
     * royaltyAmount must be checked inside the _trade function rather than while minting
     */
    function _deployCommissionSplitter(
        address[] calldata _commissionReceivers,
        uint256[] calldata _commissionShares
    ) private returns (address commissionReceiver, uint256 commissionShares) {
        commissionReceiver = PaymentSplitterFactory.deployClone(
            _commissionReceivers,
            _commissionShares
        ); // may be payment splitter contract or just an EoA

        commissionShares = IPaymentSplitter(commissionReceiver).totalShares();
        // make sure that require is triggered (failing test)
        // commissions in the order are paid to a single receiver, i.e. the payment splitter, the entire sum which must be within range
        // NOTE for now payment splitter does not have any setter functions for changing payees/shares, if this changes, the below check will not be sufficient anymore
        require(commissionShares < 8501);
    }

    /**
     * Require:
     *
     * - All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, there must be at least 2 payees in the array, and there must be no
     * duplicates in `payees`. See {PaymentSplitter-_initialize} and {PaymentSplitter-_addPayee}.
     */
    function acceptOfferDeploySplitter(
        uint256 _offerId,
        uint256 _orderId,
        address[] calldata _commissionReceivers,
        uint256[] calldata _commissionShares
    ) external {
        (
            address commissionReceiver,
            uint256 commissionShares
        ) = _deployCommissionSplitter(_commissionReceivers, _commissionShares);

        _Offer memory _offer = offers[_offerId]; // creating an additional variable in this particular case is cheaper than calling `offers[_offerId].something` each time. See https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/#avoid-additional-variables

        delete offers[_offerId]; // mark offer as cancelled forever, so that user's can't claim a refund after their offer gets accepted

        _trade(
            _orderId,
            _offer.from,
            msg.sender,
            _offer.price,
            _offer.tokenId,
            _offer.collection,
            _offer.amount,
            commissionReceiver,
            commissionShares
        ); // we are passing offer amount instead of order price as function parameter
    }

    /**
     * @dev offers can be made independently of whether the token is on sale or not, the msg.value is used to determine the offer amount, so no function parameter is needed for that
     * @dev there is no require to check that an offer or offer doesn't already exist and if so, that the offer amount is not greater than the order itself, this was omitted in order to save gas; the frontend should check this in order to prevent mistakes from the user
     * @param _collection address of the erc721 implementation contract or proxy contract
     * @param _tokenId the token Id to make an offer to
     * @param _amount the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     */
    function submitOffer(
        address _collection,
        uint256 _tokenId,
        uint256 _amount
    ) external payable isWhitelisted(_collection) {
        require(msg.value > 0);

        _offerCount.increment(); // start count at 1

        offers[_offerCount.current()] = _Offer(
            _collection,
            _tokenId,
            msg.sender,
            msg.value,
            _amount
        ); // add offer Struct to offers mapping

        emit Offer(
            _collection,
            _tokenId,
            msg.sender,
            _offerCount.current(),
            msg.value,
            _amount
        );
    }

    /**
     * @dev cancels order and transfers NFT back to owner
     * @param _orderId the Id of the order
     */
    function cancelOrder(uint256 _orderId) external isOrderOwner(_orderId) {
        _Order memory _order = orders[_orderId];

        if (_order.amount == 0) {
            IERC721Ninfa(_order.collection).transferFrom(
                address(this),
                msg.sender,
                _order.tokenId
            ); // transfer NFT back to the owner
        } else {
            IERC1155(_order.collection).safeTransferFrom(
                address(this),
                msg.sender,
                _order.tokenId,
                _order.amount,
                new bytes(0)
            );
        }

        emit OrderCancelled(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.amount
        );

        delete orders[_orderId]; // mark order as cancelled forever after event is emitted or else all values emitted will be 0
    }

    /**
     * @dev cancels offer and refunds ETH back to bidder. When an order gets filled, the offer isn't marked as cancelled, in order to allow users to claim back their money.
     * @param _offerId the Id of the offer.
     */
    function cancelOffer(uint256 _offerId) external isOfferOwner(_offerId) {
        _Offer memory _offer = offers[_offerId]; // in memory copy needed so that it is possible to delete the struct inside the storage offers mapping, while keeping check effects interact pattern intact

        delete offers[_offerId]; // mark offer as cancelled forever, updating offer price before external call, Checks Effects Interactions pattern
        (bool success, ) = payable(_offer.from).call{value: _offer.price}(""); // transfer the offer amount back to bidder
        require(success);

        emit OfferCancelled(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.amount
        );
    }

    function changeOrderPrice(uint256 _orderId, uint256 _newPrice)
        external
        isOrderOwner(_orderId)
    {
        require(_newPrice > 0); // protecting the user from mistakenly submitting an order for free. We could also require that it is not the same as the previous price, but it is  probably spending gas for nothing as the chance is very low and doesn't res

        _Order storage _order = orders[_orderId];

        _order.price = _newPrice;

        emit Order(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.price,
            _order.amount
        );
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `increaseOffer()` and `decreaseOffer()`, because they expect different parameters depending on whether the offer is being increased or decreased.
     *      A `msg.value` is required, this function will add the amount sent to the old offer amount. The frontend needs to calculate the difference between the old and new offer.
     *      E.g. A buyer calls submitOffer() and pays 0.1 ETH. The same buyer later wants to increase the offer to 0.3 ETH, therefore they now need to send 0.2 ETH, because 0.1 was was sent before.
     * @param _offerId the id of the offer
     */
    function increaseOffer(uint256 _offerId)
        external
        payable
        isOfferOwner(_offerId)
    {
        require(msg.value > 0);

        _Offer storage _offer = offers[_offerId];

        _offer.price += msg.value; // transfer extra amount needed on top of older offer

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            0
        );
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `increaseOffer()` and `decreaseOffer()`, because they expect different parameters depending on whether the offer is being increased or decreased.
     *      In contrast with `increaseOffer()`, instead of `msg.value` this function expects a uint parameter representing the new (lower) offer; the buyer will get refunded the difference.
     *      E.g. A buyer calls submitOffer() and pays 0.3 ETH. The same buyer later wants to decrease the offer to 0.1 ETH, therefore they will get refunded 0.2 ETH. I.e. The amount expected by the `_newAmount` paramer is 0.1 ETH (1^17).
     * @param _offerId the id of the offer
     * @param _newPrice the new offer amount in Ether, NOT the difference with the previous offer, just the new (lower) offer amount. E.g. 1 ETH = 1^18.
     */
    function decreaseOffer(uint256 _offerId, uint256 _newPrice)
        external
        isOfferOwner(_offerId)
    {
        _Offer storage _offer = offers[_offerId];
        require(_newPrice > 0 && _newPrice < _offer.price);

        uint256 _refund = _offer.price - _newPrice; // needed to store result before offer price is updated
        _offer.price = _newPrice; // updating offer price before external call, Checks Effects Interactions pattern

        (bool success, ) = payable(msg.sender).call{value: _refund}(""); // transfer the difference between old and new lower offer to the user
        require(success);

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            0
        );
    }

    function changeOrderAmount(uint256 _orderId, uint256 _newAmount)
        external
        payable
        isOrderOwner(_orderId)
    {
        require(_newAmount > 0);

        _Order storage _order = orders[_orderId];

        _order.amount = _newAmount;

        emit Order(
            _order.collection,
            _order.tokenId,
            msg.sender,
            _orderId,
            _order.price,
            _newAmount
        );
    }

    /**
     * @dev to be called only for ERC1155 tokens, having a separate function costs less gas than having a generic function for both ERCs in this case
     * @param _newAmount can be any uint except for 0 or the same amount as the previous offer; since the amount is unchanged it will not require any extra logic, therefore `increaseOffer()` must be called for erc1155 instead
     *  it is not enforced that _newAmount == _offer.amount because it isn't a security issue, however the frontend should disallow this in order to avoid wasting eth
     */
    function changeOfferAmount(uint256 _offerId, uint256 _newAmount)
        external
        payable
        isOfferOwner(_offerId)
    {
        require(_newAmount > 0);

        _Offer storage _offer = offers[_offerId];

        _offer.amount = _newAmount;

        emit Offer(
            _offer.collection,
            _offer.tokenId,
            msg.sender,
            _offerId,
            _offer.price,
            _newAmount
        );
    }

    /**
     * @notice the collector calls this function to buy an NFT at the ask price, only if an order exists
     * @notice if someone has an open offer but calls fillOrder, the offer will remain open, meaning they will need to call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in order to pay for part of the order.
     * @param _orderId avoids having to store a mapping to order id like the deprecated `mapping(address => mapping(uint256 => uint256)) private _tokenToOrderId` which would have not worked for erc1155 as each token has a supply.
     * _orderId does not constitute a vulnerability as it is user provided, since A) a regular user will go through the frontend which gets orderId from events
     */
    function fillOrder(uint256 _orderId) external payable {
        _Order memory _order = orders[_orderId];
        // checking that the order wasn't deleted or filled and that the order exists
        // In the EVM, there is an opcode for < and one for >, but not for <= or >=.
        // That is why `msg.value == orders[_orderId].price` is better than `msg.value >= orders[_orderId].price`.
        require(_order.price > 0 && msg.value == _order.price);

        _trade(
            _orderId,
            msg.sender,
            _order.from,
            _order.price,
            _order.tokenId,
            _order.collection,
            _order.amount,
            _order.commissionReceiver,
            _order.commissionShares
        );
    }

    /**
     * @dev this function can only be called by the owner of the NFT for sale, i.e. the address that created the order.
     * Eg. the order creator may be happy with an offer amount, so they call acceptOffer() passing in the offer Id as the only parameter;
     * the internal _trade() function will get called, where this smart contract will send the offer amount to the seller (minus fees) and send the NFT to the buyer.
     * @param _orderId If there is no order, the Id will be set to 0, else the order will be marked as filled by the _trade() function, orderFilled[_orderId] = true;
     * this is needed to delete the order from storage when calling _trade() if there is any, and to check that msg.sender is the owner of the nft
     *
     * Required:
     *
     * - caller must be token owner, or else transferFrom will revert, this also means that _offerId must exist or else it will revert.
     *   the _seller paramteter passed to trade() will be msg.sender, the marketplace will therefore try to transfer the tokenId (amount) to the offer maker/buyer on behalf of msg.sender.
     *   i.e. although the transferFrom checks `require(_isApprovedOrOwner(_msgSender(), tokenId))` and the marketplace is indeed approved, it can only transfer on behalf of msg.sender.
     *   Note Consider what would happen if the erc implementation does not revert upon failed transfers though! given that Ninfa has no control over all of the accepted collections' implementations, there is no guarantee that the collection will follow the standard.
     *
     */
    function acceptOffer(uint256 _offerId, uint256 _orderId) external {
        _Offer memory _offer = offers[_offerId]; // creating an additional variable in this particular case is cheaper than calling `offers[_offerId].something` each time. See https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/#avoid-additional-variables

        delete offers[_offerId]; // mark offer as cancelled forever, so that user's can't claim a refund after their offer gets accepted

        _trade(
            _orderId,
            _offer.from,
            msg.sender,
            _offer.price,
            _offer.tokenId,
            _offer.collection,
            _offer.amount,
            address(0),
            0
        ); // we are passing offer amount instead of order price as function parameter
    }

    function _transferNFT(
        address _collection,
        address _seller,
        address _buyer,
        uint256 _tokenId,
        uint256 _amount
    ) private {
        if (_amount == 0)
            IERC721Ninfa(_collection).transferFrom(_seller, _buyer, _tokenId);
        else
            IERC1155(_collection).safeTransferFrom(
                _seller,
                _buyer,
                _tokenId,
                _amount,
                ""
            );
    }

    /**
     * @param _orderId order Id
     * @param _buyer order or offer creator, depending on who `msg.sender` is
     * @param _price NFT's price
     * @param _tokenId NFT's Id
     */
    function _trade(
        uint256 _orderId,
        address _buyer,
        address _seller,
        uint256 _price,
        uint256 _tokenId,
        address _collection,
        uint256 _amount,
        address _commissionReceiver,
        uint256 _commissionShares
    ) private {
        /*******************
         * Local Variables *
         ******************/
        bool success;

        _Trade memory trade = _Trade(
            _price,
            0,
            0,
            (_price * _commissionShares) / 10000, // calculating commission amount from shares (basis points), (_price * bps) / 10000
            ZERO_ADDRESS,
            _commissionReceiver
        ); // TODO test what costs less gas; using a struct for local variables or for function parameters? Include `bool success` in struct?
        // TODO would "block scoping" work instead? e.g. uniswap V2 https://github.com/Uniswap/v2-periphery/blob/69617118cda519dab608898d62aaa79877a61004/contracts/UniswapV2Router02.sol#L327-L333

        /*************************
         * Transfer NFT to buyer *
         ************************/

        if (_orderId != 0) {
            // since there is an order, the marketplace is the owner of the nft, then it will transfer the nft to the buyer without complaining.
            // therefore the msg.sender must be equal to the order creator in order to prove they are the legitimate owner.
            require(msg.sender == orders[_orderId].from);
            // if _orderId is different from 0, then automatically the order exists because otherwise the mapping would be deleted, i.e. no need to check the order is valid
            // Orders may exist simultaneously as offers, therefore if the `delete` directive was placed only inside the `fillOrder()`, the order would not be deleted when fulfilling an order via `acceptOffer()`.
            delete orders[_orderId];

            // if `_orderId` is different from 0, there is an order, i.e. the marketplace is the owner of the NFT, therefore the `from` parameter must be the marketplace's address
            // if `_orderId` is 0, there is no order, i.e. the marketplace is NOT the owner of the nft, therefore the `from` parameter must be the seller's address, i.e. whoever called acceptOffer()
            // `_orderId` will be 0 when `_trade()` is called by `acceptOffer()` AND no order exists corresponding to the token for which the offer was made
            _transferNFT(_collection, address(this), _buyer, _tokenId, _amount);
        } else {
            _transferNFT(_collection, _seller, _buyer, _tokenId, _amount);
        }

        // 1155 cannot be a primary sale becaause it is impossible to track each fungible tokenId supply
        // todo consider if we need to trade the erc721 v1 of the contract's address. It can't be whitelised so it might need a new variable to store its address, or to add a nested mapping in secondarySale containging collection => tokenId
        // however then how would I know if the tokenId for erc721 v1 is a primary sale or not. I should upgrade v1 to make secondarySale public (right now is private). This could be a good solution going forward, for when there will be a v3.
        if (_collection == address(NinfaERC721) && !secondarySale[_tokenId]) {
            /****************************************************
             * If Primary Sale ( i.e. a Ninfa ERC721 Contract ) *
             ***************************************************/

            // primary sales exist only for Ninfa Collection
            // overrides the `marketplaceAmount` that is by default calculated using NINFA_SECONDARY_FEE. There is a separate if case should fees be set to 0, in order to avoid dividing 0 by 10000 which would revert the transaction.
            // if the primary fee is 0, it won't revert, but rather the final result will be 0. Since fees are 0% unly until 2023, an if statement might save a little gas now but waste it after primary fees are set.
            trade.marketplaceAmount = (_price * ninfaPrimaryFee) / 10000;

            secondarySale[_tokenId] = true; // Set secondarySale bool to true after first sale on NinfaMarketplace.
        } else {
            /***************************************************
             * If Secondary Sale ( includes erc1155 contracts ) *
             ***************************************************/

            /*******************
             * Get Royalty Info *
             *******************/

            if (_collection.supportsERC165Interface(INTERFACE_ID_ERC2981)) {
                (trade.royaltyReceiver, trade.royaltyAmount) = IERC2981(
                    _collection
                ).royaltyInfo(_tokenId, _price); // If the collection supports the ERC-2981 royalties interface, store the receiver address and amount in memory.
            }

            trade.sellerAmount -= trade.royaltyAmount; // Only subtract `royaltyAmount` if secondary sale. This assignment indirectly checks that: `royaltyAmount < (_price - marketplaceAmount)`, otherwise it would revert. This guarantees that external NFTs' royalties do not overflow!

            trade.marketplaceAmount = (_price * NINFA_SECONDARY_FEE) / 10000;

            /*****************
             * Pay Royalties *
             ****************/

            // if `royaltyAmount == (_price - marketplaceAmount)` then `sellerAmount == 0` which is default. This means that 0 value payments may happen, which is ok. That is why we aren't requiring that `royaltyAmount > 0` either.
            // Neither it is required that `royaltyReceiver != ZERO_ADDRESS`, this would be an error on the part of whoever programmed the NFT, but it doesn't represent any security issues for the Marketplace.
            // For NinfaERC721 all  tokens will have a receiver and fixed 10% royalties. I.e. if the token exists, its royalties also exist.
            (success, ) = trade.royaltyReceiver.call{
                value: trade.royaltyAmount
            }("");
            require(success);

            emit RoyaltyPayment(
                _collection,
                _tokenId,
                trade.royaltyReceiver,
                trade.royaltyAmount
            );
        }

        trade.sellerAmount -= trade.marketplaceAmount; // subtracting primary or secondary fee amount (may be 0 for primaries).

        /***************************
         * Pay gallery commissions *
         **************************/

        if (trade.commissionAmount > 0) {
            if (_seller == trade.commissionReceiver) {
                // this condition MUST only be triggered if the trade is a primary sale, i.e. it is a Ninfa NFT, i.e. there will always be a `royaltyReceiver` for every artist so that they can get paid.
                // there seller MAY also be the commissionReceiver during a secondary sale, e.g. a gallery selling an external collection for the first time on ninfa.
                // trade.commissionReceiver = _seller;
                _seller = trade.royaltyReceiver;
                // delete _saleCommissions[_collection][_tokenId];
            }

            trade.sellerAmount -= trade.commissionAmount;

            (success, ) = trade.commissionReceiver.call{
                value: trade.commissionAmount
            }("");
            require(success);

            emit RoyaltyPayment(
                _collection,
                _tokenId,
                trade.commissionReceiver,
                trade.commissionAmount
            ); // reusing the same event definition for both artist and gallery royalties, one may just filter events by address to find out which is which
        }

        /**********************************************
         * Pay marketplace fee (primary or secondary) *
         *********************************************/

        (success, ) = feeAccount.call{value: trade.marketplaceAmount}("");
        require(success);

        /**************
         * Pay seller *
         *************/
        (success, ) = payable(_seller).call{value: trade.sellerAmount}(""); /*(_price - marketplaceAmount - royaltyAmount)*/
        require(success);

        emit Trade(_collection, _tokenId, _seller, _price, _buyer, _amount);
    }

    /********************
     * SALE COMMISSIONS *
     *******************/

    /*******************
     * ADMIN FUNCTIONS *
     ******************/

    /**
     * @notice setter function only callable by contract admin used to change any or all addresses used by the Marketplace,
     * @dev if only one address needs to be set, make sure you are passing all other past addresses as parameters
     * @dev the reason there is only one setter function rather many is to save bytecode, because the Marketplace is very close to contract size limit
     * @param _feeAccount is the address owned by NINFA that will collect sales fees
     */
    function initAddresses(
        address _ninfaErc721,
        address _feeAccount,
        address _ninfaErc1155Factory,
        address _paymentSplitterFactory
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        feeAccount = payable(_feeAccount);
        NinfaERC1155Factory = INinfaERC1155Factory(_ninfaErc1155Factory);
        PaymentSplitterFactory = IPaymentSplitterFactory(
            _paymentSplitterFactory
        );
        NinfaERC721 = IERC721Ninfa(_ninfaErc721);
    }

    /**
     * @notice whitelist collection to be traded on marketplace
     * @param _collection address of collection ERC721 or ERC1155
     */
    function whitelistNFT(address _collection)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        NFTWhitelist[_collection] = true;
    }

    function setPrimaryFee(uint24 _feeBps)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        ninfaPrimaryFee = _feeBps;
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, to the deployer and grants CURATOR_ROLE admin role of ARTIST_ROLE
     * @dev after deployment need to manually call setErc1155Factory and setPaymentSplitterFactory.
     */
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ARTIST_ROLE, CURATOR_ROLE);
    }

    /***************************
     * EXTERNAL VIEW FUNCTIONS *
     **************************/

    // /**
    //  * @notice Calculate sale commission info for a token id from the Ninfa collection
    //  * @param _collection collection address
    //  * @param _tokenId the token id
    //  * @param _amount amount received by artist from primary sale
    //  * @return receiver address and amount to be paid for primary sale commission to gallery
    //  */
    // function getSaleCommission(
    //     address _collection,
    //     uint256 _tokenId,
    //     uint256 _amount
    // ) public view returns (address receiver, uint256 commissionAmount) {
    //     receiver = _saleCommissions[_collection][_tokenId].receiver;
    //     commissionAmount =
    //         (_amount * _saleCommissions[_collection][_tokenId].feeBps) /
    //         10000;
    // }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)

pragma solidity 0.8.15;

import "./IERC165.sol";

/**
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165Checker {
    /**
     * @notice Query if a contract implements an interface, does not check ERC165 support
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return true if the contract at account indicates support of the interface with
     * identifier interfaceId, false otherwise
     * @dev Assumes that account contains a contract that supports ERC165, otherwise
     * the behavior of this method is undefined. This precondition can be checked
     * with {supportsERC165}.
     * Interface identification is specified in ERC-165.
     */
    function supportsERC165Interface(address account, bytes4 interfaceId)
        internal
        view
        returns (bool)
    {
        bytes memory encodedParams = abi.encodeWithSelector(
            IERC165.supportsInterface.selector,
            interfaceId
        );
        (bool success, bytes memory result) = account.staticcall{gas: 30000}(
            encodedParams
        );
        if (result.length < 32) return false;
        return success && abi.decode(result, (bool));
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)

pragma solidity 0.8.15;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length)
        internal
        pure
        returns (string memory)
    {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

/**
 * @title Counters
 * @dev Stripped down version of OpenZeppelin Contracts v4.4.1 (utils/Counters.sol), identical to CountersUpgradeable.sol being a library. Provides counters that can only be incremented. Used to track the total supply of ERC721 ids.
 * @dev Include with `using Counters for Counters.Counter;`
 */
library Counters {
    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    /// @dev if implementing ERC721A there could be an overflow risk by removing overflow protection with `unchecked`, unless we limit the amount of tokens that can be minted, or require that totalsupply be less than 2^256 - 1
    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

/// @dev Interface for the NFT Royalty Standard
interface IERC2981 {
    /// @notice Called with the sale price to determine how much royalty
    //          is owed and to whom.
    /// @param _tokenId - the NFT asset queried for royalty information
    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId
    /// @return receiver - address of who should be sent the royalty payment
    /// @return royaltyAmount - the royalty payment amount for _salePrice
    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
        external
        view
        returns (address receiver, uint256 royaltyAmount);

    function setRoyaltyReceiver(address _royaltyReceiver) external;
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

/**
 * @dev Implementation of the {IERC721Receiver} interface.
 *
 * Accepts all token transfers.
 * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
 */
contract ERC721Holder {
    /**
     *
     * @dev See {IERC721Receiver-onERC721Received}.
     *
     * Always returns `IERC721Receiver.onERC721Received.selector`.
     *
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(
        address, /* operator*/
        address, /* from*/
        uint256, /* tokenId*/
        bytes calldata /* data*/ // TODO Why isn't `calldata` implemented in OZ's ERC721Holder, but `memory` is used instead? The npm_modules uses `memory` yet the docs don't show it in the interface https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-
    ) external pure returns (bytes4) {
        return 0xbc197c81; // this.onERC721Received.selector, i.e. bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

interface IERC721Ninfa {
    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev {ERC721Ninfa-mint}
     */
    function mint(bytes32 _tokenURI, address _msgSender) external;

    function mintAndSetRoyaltyReceiver(
        bytes32 _tokenURI,
        address _msgSender,
        address _royaltyReceiver
    ) external;

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    function exists(uint256 _id) external view returns (bool);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

/**
 * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens, but the onERC1155BatchReceived was removed.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 *
 */
contract ERC1155Holder {
    /**
     *
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * param operator The address which initiated the transfer (i.e. msg.sender)
     * param from The address which previously owned the token
     * param id The ID of the token being transferred
     * param value The amount of tokens being transferred
     * param data Additional data with no specified format
     * return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return 0xf23a6e61; // this.onERC1155Received.selector
    }

    /**
     * @dev supportsInterface is only needed to signal support for onERC1155Received, not onERC721Received. The interface is probably needed because a contract may implement onERC1155Received, onERC1155BatchReceived, or both. See https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828
     */
    function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return
            interfaceId == 0x01ffc9a7 || // Interface ID for IERC165
            interfaceId == 0xf23a6e61; // NOTE bytes4 for `this.onERC1155Received.selector`, normally it would be `type(IERC1155Receiver).interfaceId` which includes the selector for `onERC1155BatchReceived`, but the marketplace doesn't support that function (yet?)
    }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(
        address indexed account,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        external
        view
        returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;

    function totalSupply() external view returns (uint256);

    function mint(
        address _to,
        bytes32 _tokenURI,
        uint256 _amount,
        bytes memory _data
    ) external;
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

interface IPaymentSplitter {
    function totalShares() external view returns (uint256);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

interface IPaymentSplitterFactory {
    function deployClone(address[] calldata payees, uint256[] calldata shares)
        external
        returns (address clone);
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

interface INinfaERC1155Factory {
    function exists(address _instance) external view returns (bool);

    function deployClone(
        string calldata _name,
        string calldata _symbol,
        address _msgSender,
        uint256 _salt
    ) external returns (address clone);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity 0.8.15;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)

pragma solidity 0.8.15;

import "./IAccessControl.sol";
import "../utils/Strings.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is IAccessControl {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, msg.sender);
        _;
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account)
        public
        view
        override
        returns (bool)
    {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(uint160(account), 20),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account)
        public
        override
        onlyRole(getRoleAdmin(role))
    {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account)
        public
        override
        onlyRole(getRoleAdmin(role))
    {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public override {
        require(
            account == msg.sender,
            "AccessControl: can only renounce roles for self"
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     */
    function _grantRole(bytes32 role, address account) internal {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     */
    function _revokeRole(bytes32 role, address account) internal {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}