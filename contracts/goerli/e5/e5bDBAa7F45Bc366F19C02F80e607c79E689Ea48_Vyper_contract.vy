# @version ^0.3.0


##########
# README #
##########

# # VeriHash's UnPool MEV Sharing Contract
# https://verihash.io/
# https://unpool.fi/
#
# Welcome to the MEV sharing contract! Validators on UnPool collect their portion of MEV from this
# contract by withdrawing their balance generated by being awesome validators.
#
# When a validator signs up with UnPool, they add their validator public key and a beneficiary
# wallet to the contract. The beneficiary wallet is the wallet who can collect the balance. A
# validator's balance is calculated by the total MEV collected divided among the total users of the
# pool, weighted by their own uptime. The more uptime you have, the higher your reward will be.
#
#
# ## How To Sign Up
#
# In order to add your validator to the MEV sharing pool, you need to prove you hold the validator
# private key and thus own the validator. We never want to know, see, or hold your private keys. We
# mean it when we say, "your keys, your crypto, your rewards".
# 
#
# In order to prove ownership, we have you sign an EIP-191 message using the private keys of the
# validator you are adding. We store each message's signature in order to stop replay attacks. Each
# signature can only be used once in the life of the contract. A Python example of signing a message
# is at the bottom of this README.
# Reference: https://eips.ethereum.org/EIPS/eip-191.
#
# Call the function `add_validator` with the following information:
# 1. The public key of the validator. It must match the private key used to generate the signature
#    of the message.
# 2. The hash of the message.
# 3. The signature of the signed message.
# 4. Acknowledgement that you are not affiliated with any address on the OFAC's SDN list. We do not
#    do business with, and actively block, any address on the SDN list in order to stay compliant
#    with the US Government sanctions and regulations in regards to contributing, servicing, or 
#    benefiting with or from sanctioned entities.
#
# Once your validator is added, use the UnPool portal to get a personal link to the execution layer
# client's endpoint of the UnPool validator network and start getting a share of the MEV generated
# by the pool!
#
#
# ## How To Remove Yourself
#
# If you think this whole setup sucks and you want out, feel free to remove your validator at any
# time. Call the `remove_validator` function with the public key of the validator as the argument
# using the original beneficiary wallet address.
#
# We highly recommend you widthdraw any earned rewards before calling this function. Otherwise, you
# will have to re-add the validator, withdraw rewards, and remove the validator; all of which cost
# gas.
#
# You will not lose any balance in the contract but will be unable to withdraw unless you re-add
# the validator again using a new signature. You can re-add the validator using the same beneficiary
# wallet or a different one. You will need to use a new signature when doing so.
#
#
# ## How To Get Rewards
#
# You can check your current balance in the contract by checking the map `validatorBalances` with
# a validator public key as the hashmap's key. The balance available will be in Gwei.
#
# If you have a balance in the contract, call the `withdraw` function using the benefiary wallet set
# during the initial `add_opeartor` step. The balance will be transferred to the wallet and zero'd
# out in the contract.
#
#
# ## Python example of creating an EIP-191 signature
# ```python
# import uuid
#
# from eth_account.messages import encode_defunct
# from getpass import getpass
# from web3.auto import w3
#
#
# def sign(privateKey, salt=None):
#
#     # Create an account object from the private key
#     account = w3.eth.account.from_key(privateKey)
#
#     # Create a message object which can be signed.
#     # Use the standard uuid library to generate random text.
#     # We store all of the hashed messages in the contract and they can only be used once.
#     # Reference: https://eth-account.readthedocs.io/en/stable/eth_account.html#eth_account.messages.encode_defunct
#     message = encode_defunct(text=uuid.uuid4().hex)
#
#     # Sign the message with the validator's key
#     return account.sign_message(message)
#
#
# if __name__ == '__main__':
#
#     # Get the private key of the validator
#     privateKey = getpass("Enter the validator's private key in order to sign the message: ")
#
#     # Let's sign the message
#     signedMessage = sign(privateKey)
#
#     # Input this stuff into the contract.
#     print()
#     print('Input the following values into https://www.verihash.io/hydra/register.html')
#     print('Validator public key:', w3.eth.account.from_key(privateKey).address)
#     print('Message hash:', signedMessage.messageHash.hex())
#     print('Signature:', signedMessage.signature.hex())
# ```


#############
# Constants #
#############

SIGNATURE_LENGTH: constant(uint256) = 65


###################
# State Variables #
###################

# The wallet who can update the `feeCollector` and `balanceUpdater` addresses
# It can also update the `feePercent`
admin: public(address)

# The wallet who can collect the fees from clients for using the service
feeCollector: public(address)

# The wallet who can update the `rewardBalance` for each `beneficiaryWallet`
balanceUpdater: public(address)

# The percent of the rewards which goes to the owner
feePercent: public(uint256)

# A map of {validatorsublicKey:beneficiaryWallet}
validators: public(HashMap[address, address])

# The current number of active validators
numValidators: public(uint256)

# A map of {beneficiaryWallet:rewardBalance}
validatorBalances: public(HashMap[address, uint256])

# The total balance of all validator. We store this particular value to make the fee collection
# math simple, due to rounding errors. The total amount of fees we can collect is simply
# `self.balance - totalValidatorBalance`. We take a fee out whenever we call `add_balance`.
totalValidatorBalance: public(uint256)

# The wallet who can add and remove banned addresses
sdnUpdater: public(address)

# We don't allow beneficiary wallets on the Office of Foreign Asset Control (OFAC) list of
# Specially Designated Nationals and Blocked Persons ("SDN List"):
# https://www.treasury.gov/ofac/downloads/sdnlist.txt
# https://home.treasury.gov/policy-issues/office-of-foreign-assets-control-sanctions-programs-and-information
# `True` if banned, `False` (default) if allowed.
isAddressBanned: public(HashMap[address, bool])

# The current number of banned addresses
numBannedAddresses: public(uint256)

# Use a map to ensure signed messages can't be used twice
signatures: HashMap[Bytes[SIGNATURE_LENGTH], bool]


##########
# Events #
##########

# Fire whenever a validator is added
event ValidatorAdded:
    beneficiaryWallet: indexed(address)
    validatorPublicKey: indexed(address)
    validatorSignature: Bytes[SIGNATURE_LENGTH]

# Fire whenever a validator is removed
event ValidatorRemoved:
    beneficiaryWallet: indexed(address)
    validatorPublicKey: indexed(address)

# Fire whenever the contract receives funds
event RewardAdded:
    depositingWallet: indexed(address)
    value: uint256

# Fire whenever a balance is added
event BalanceAdded:
    depositingWallet: indexed(address)
    addedValue: uint256
    fees: uint256

# Fire whenever a `beneficiaryWallet`'s balance is withdrawn
event BalanceWithdrawn:
    beneficiaryWallet: indexed(address)
    previousBalance: uint256

# Fire whenever the fees are collected by the `feeCollector` wallet
event FeesWithdrawn:
    feeCollector: indexed(address)
    previousBalance: uint256

# Fire whenver an address is banned
event AddressBanned:
    bannedAddress: indexed(address)

# Fire whenver an address is unbanned
event AddressUnbanned:
    unbannedAddress: indexed(address)


################################################
# Contract Initialization and Default Function #
################################################

@external
@nonpayable
def __init__(feePercent: uint256,
             feeCollector: address,
             balanceUpdater: address,
             sdnUpdater: address):
    self.admin = msg.sender
    self.feePercent = feePercent
    self.feeCollector = feeCollector
    self.balanceUpdater = balanceUpdater
    self.sdnUpdater = sdnUpdater


@external
@payable
def __default__():

    # Ensure the calling address is not banned
    assert self.isAddressBanned[msg.sender] == False, \
    "You are on the US Treasury's SDN list. We cannot do business with you."

    # Send an event to any listeners when rewards are added
    log RewardAdded(msg.sender, msg.value)


######################
# Internal Functions #
######################

@internal
@view
def _verify_validator(publicKey: address,
                      prefixedHashedMessage: bytes32,
                      signature: Bytes[SIGNATURE_LENGTH]) -> bool:

    # Arguments:
    # publicKey: The public key of the signer of the message
    # prefixedHashedMessage: The hashed message signed by the user, which includes the prefix
    # signature: The hashed message signed with the user's wallet. 65 = 32 + 32 + 1

    # Split the signature into the r, s, and v components
    r: uint256 = convert(slice(signature, 0, 32), uint256)
    s: uint256 = convert(slice(signature, 32, 32), uint256)
    v: uint256 = convert(slice(signature, 64, 1), uint256)

    # Return if the signature's public key matches the input public key
    # https://vyper.readthedocs.io/en/stable/built-in-functions.html#ecrecover
    return ecrecover(prefixedHashedMessage, v, r, s) == publicKey


############################
# Administrative Functions #
############################

@external
@nonpayable
def set_admin(admin: address) -> address:

    # Only allow the `admin` to call this function
    assert self.admin == msg.sender, \
    "You cannot update the admin address."

    # Set a new admin address
    self.admin = admin

    # Return the new admin address
    return self.admin


@external
@nonpayable
def set_fee_collector(feeCollector: address) -> address:

    # Only allow the `admin` to call this function
    assert self.admin == msg.sender, \
    "You cannot update the fee collector address."

    # Set a new fee collector address
    self.feeCollector = feeCollector

    # Return the new fee collector address
    return self.feeCollector


@external
@nonpayable
def set_balance_updater(balanceUpdater: address) -> address:

    # Only allow the `admin` to call this function
    assert self.admin == msg.sender, \
    "You cannot update the balance updater address."

    # Set a new balance updater address
    self.balanceUpdater = balanceUpdater

    # Return the new balance updater address
    return self.balanceUpdater


@external
@nonpayable
def set_sdn_updater(sdnUpdater: address) -> address:

    # Only allow the `admin` to call this function
    assert self.admin == msg.sender, \
    "You cannot update the SDN updater address."

    # Set a new SDN updater address
    self.sdnUpdater = sdnUpdater

    # Return the new SDN updater address
    return self.sdnUpdater


@external
@nonpayable
def set_fee_percent(feePercent: uint256) -> uint256:

    # Only allow the `admin` to call this function
    assert self.admin == msg.sender, \
    "You cannot update the fee percent."

    # Ensure the range is good. It cannot be <0 due to the `feePercent` type itself being uint256.
    assert feePercent <= 100, "The fee percent must be <= 100."

    # Set a new fee percent
    self.feePercent = feePercent

    # Return the new fee percent
    return self.feePercent


######################
# SDN List Functions #
######################

@external
@nonpayable
def ban_address(addressToBan: address):

    # Only allow the `sdnUpdater` to call this function
    assert self.sdnUpdater == msg.sender, \
    "You cannot ban an address."

    # You can't ban an already banned address
    assert self.isAddressBanned[addressToBan] == False, \
    "The address is already banned."

    # Add the address to the banned address list
    self.isAddressBanned[addressToBan] = True

    # Increment the banned address counter
    self.numBannedAddresses += 1

    # Send an event to any listeners
    log AddressBanned(addressToBan)


@external
@nonpayable
def unban_address(addressToBan: address):

    # Only allow the `sdnUpdater` to call this function
    assert self.sdnUpdater == msg.sender, \
    "You cannot unban an address."

    # You can't unban an address that isn't already banned
    assert self.isAddressBanned[addressToBan] == True, \
    "The address is not banned."

    # Remove the address from the banned address list
    self.isAddressBanned[addressToBan] = False

    # Decrement the banned address counter
    self.numBannedAddresses -= 1

    # Send an event to any listeners
    log AddressUnbanned(addressToBan)


#############################
# Balance Updater Functions #
#############################

@external
@nonpayable
def add_balance(beneficiaryWallet: address,
                addedBalance: uint256) -> uint256:

    # Only allow the `balanceUpdater` to call this function
    assert self.balanceUpdater == msg.sender, \
    "You cannot update a balance."

    # Ensure the address is not banned
    assert self.isAddressBanned[beneficiaryWallet] == False, \
    "We can't interact with addresses on the SDN list."

    # Ensure there is enough of a balance in the contract for these funds
    assert self.balance >= self.totalValidatorBalance + addedBalance, \
    "We do not have enough funds in the contract to update this balance. Add more!"

    # The portion of fees. We round down the fees because we love you.
    decimalFeePercent: decimal = convert(self.feePercent, decimal)
    decimalAddedBalance: decimal = convert(addedBalance, decimal)
    decimalFees: decimal = decimalAddedBalance * (decimalFeePercent / 100.0)
    fees: uint256 = convert(decimalFees, uint256)

    # Remove the fees from the `addedBalance`
    normalizedBalance: uint256 = addedBalance - fees

    # Add the `normalizedBalance` to the `totalValidatorBalance`
    self.totalValidatorBalance += normalizedBalance

    # Add more to the balance. We cannot remove balance.
    self.validatorBalances[beneficiaryWallet] += normalizedBalance

    # Send an event to any listeners
    log BalanceAdded(msg.sender, normalizedBalance, fees)

    # Return the new balance
    return self.validatorBalances[beneficiaryWallet]


###########################
# Fee Collector Functions #
###########################

@external
@nonpayable
def collect_fees() -> uint256:

    # Ensure the calling address is not banned
    assert self.isAddressBanned[msg.sender] == False, \
    "You are on the US Treasury's SDN list. We cannot do business with you."

    # Only allow the `feeCollector` to call this function
    assert msg.sender == self.feeCollector, \
    "You must be the fee collector to collect the fees."

    # Store the fee balance, which is the total contract balance - `totalValidatorBalance`
    fees: uint256 = self.balance - self.totalValidatorBalance

    # There should actually be something to withdraw
    assert fees > 0, "There are no fees to withdraw."

    # Send the balance to the `feeCollector` owner
    send(msg.sender, fees)

    # Send an event to any listeners
    log FeesWithdrawn(msg.sender, fees)

    # Return the previous balance
    return fees


##################
# User Functions #
##################

@external
@nonpayable
def add_validator(validatorPublicKey: address,
                  validatorSignedMessage: bytes32,
                  validatorSignature: Bytes[SIGNATURE_LENGTH],
                  iAmNotAffiliatedWithAnySdnAddress: bool) -> address:

    """ Arguments:
    validatorPublicKey: The public key of the validator used to sign the message.
    validatorSignedMessage: The messaged signed with the validator private key.
    validatorSignature: The signature of the signed message. Cannot be used more than once.
    iAmNotAffiliatedWithAnySdnAddress: In order to do business with VeriHash Inc., A user must
        specify they are not affiliated with any wallet address on the Office of Foreign Asset
        Control (OFAC) list of Specially Designated Nationals and Blocked Persons ("SDN List"):
        https://www.treasury.gov/ofac/downloads/sdnlist.txt
        https://home.treasury.gov/policy-issues/financial-sanctions/specially-designated-nationals-and-blocked-persons-list-sdn-human-readable-lists
    """

    # Ensure the calling address is not banned
    assert self.isAddressBanned[msg.sender] == False, \
    "You are on the US Treasury's SDN list. We cannot do business with you."

    # Ensure the validator public key is not banned
    assert self.isAddressBanned[validatorPublicKey] == False, \
    "Your validator public key is on the US Treasury's SDN list. We cannot do business with you."

    # Ensure the caller has specified they are not affiliated with any address on the SDN list
    assert iAmNotAffiliatedWithAnySdnAddress == True, \
    "You must acknowledge you are not affiliated with any wallet on the OFAC's SDN list."

    # Size sanity check
    assert len(validatorSignature) == SIGNATURE_LENGTH, \
    "The signature length is not correct. Please retry with a new signature."

    # Check for valid validator ownership
    result: bool = self._verify_validator(validatorPublicKey,
                                         validatorSignedMessage,
                                         validatorSignature)

    # Ensure the validator's signature was valid
    assert result == True, "Cannot validate the validator signed message."

    # Revert the transaction if someone has already added the validator.
    # It should be the zero address, which is the default address.
    assert self.validators[validatorPublicKey] == empty(address), \
    "Validator exists. Please remove using the original beneficiary's wallet."

    # Ensure someone has not already used the `validatorSignature`
    assert self.signatures[validatorSignature] == False, \
    "Signature already used to previously add a validator. Please re-sign a new message."

    # Add the `validatorSignature` to a hashmap in order to stop replay attacks
    self.signatures[validatorSignature] = True

    # If we haven't failed, add the calling wallet at the validator key owner
    self.validators[validatorPublicKey] = msg.sender

    # Increment the number of validators counter
    self.numValidators += 1

    # Send an event to any listeners
    log ValidatorAdded(msg.sender, validatorPublicKey, validatorSignature)

    # Return the wallet associated with the `validatorPublicKey` 
    return self.validators[validatorPublicKey]


@external
@nonpayable
def remove_validator(validatorPublicKey: address) -> address:

    # Ensure the calling address is not banned
    assert self.isAddressBanned[msg.sender] == False, \
    "You are on the US Treasury's SDN list. We cannot do business with you."

    # Ensure the validator public key is not banned
    assert self.isAddressBanned[validatorPublicKey] == False, \
    "Your validator public key is on the US Treasury's SDN list. We cannot do business with you."

    # Only allow removal of existing validators
    assert self.validators[validatorPublicKey] != empty(address), "Validator does not exist."

    # Only allow the original wallet to remove a validator
    assert self.validators[validatorPublicKey] == msg.sender, \
    "Only the original beneficiary can remove a validator."

    # Remove the validator
    self.validators[validatorPublicKey] = empty(address)

    # Decrement the number of validators counter
    self.numValidators -= 1

    # Send an event to any listeners
    log ValidatorRemoved(msg.sender, validatorPublicKey)

    # Return the wallet associated with the `validatorPublicKey` 
    # It should be `empty(address)`
    return self.validators[validatorPublicKey]


@external
@nonpayable
def withdraw() -> uint256:

    # Ensure the calling address is not banned
    assert self.isAddressBanned[msg.sender] == False, \
    "You are on the US Treasury's SDN list. We cannot do business with you."

    # Ensure the caller has a balance
    assert self.validatorBalances[msg.sender] > 0, "You do not have any funds to withdraw."

    # Store the previous balance
    previousBalance: uint256 = self.validatorBalances[msg.sender]

    # Reset the balance to zero
    self.validatorBalances[msg.sender] = 0

    # Send any balance to the caller
    send(msg.sender, previousBalance)

    # Remove the previous balance from the `totalValidatorBalance`
    self.totalValidatorBalance -= previousBalance

    # Send an event to any listeners
    log BalanceWithdrawn(msg.sender, previousBalance)

    # Return the previous balance
    return previousBalance