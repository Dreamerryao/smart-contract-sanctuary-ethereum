pragma solidity ^0.8.0;
/// @title Jaypigs
/// @author Youssefea - [emailÂ protected]
/// @notice You can use this contract for only the most basic simulation
/// @dev All function calls are currently implemented without side effects
/// @custom:experimental This is an experimental contract.

import "./jaypigsTools.sol";

contract jaypigsStorage is Ownable{

    struct Offer{
        uint bid;
        address bidder;
        uint bidStamp;
        uint bidTime;
    }
    
     //fee percentage that the contract takes and gives to previous depositors
     uint private fee;
     //total volume that has gone through the smart contract for ever
     uint256 private total_volume;
     //total balance of the smart contract hitorically. This is related to the total volume but not always
     uint256 private total_balance;
     //mapping the depositor address to the asset (nftAddress) and the to the tokenID
     mapping(uint => mapping(address => address)) private depositors;
     //mapping the price determined by the dpeositor to the asset (nftAdress & tokenID)
     mapping(address => mapping(uint => uint)) private nftPrice;
     //mapping of offers made by bidders to the asset
     mapping(address => mapping(uint => Offer[])) private nftOffers;
     //mapping the volumes generated by each depositor to their address
     mapping (address => uint[]) private volumes;
     //an array of all the sales volumes that were registered
     uint[] public vol_sales;
     //an array of comulative sales volumes that were registered
     uint[] public vol_sales_total;
     // total of historical claims of depositor
     mapping (address=>uint) private claims;
     //mapping indexes
     mapping (address => uint[]) private indexes;
     //index for concatenation
     uint private index;
     //marketAddress
     address marketAddress;
     //rewards contract address
     address rewardsAddress;
     //token used for offers, usually it's the wrapped token address
     address tokenForOffer;


    
    constructor() {

        //initializing token for offers address
        tokenForOffer=address(0);

        fee=10;

        //Initial volume to 0
        total_volume=0;

        //Initial index
        index=0;

        //initialize marketAddress
        marketAddress=address(0);

        rewardsAddress=address(0);


    }

    /**
     * @notice modifiers to restrict access to the market address or rewards contract address only
     */

    modifier onlyMarket(){
        require(msg.sender==marketAddress,"You can only access this function from the market contract");
        _;
    }

    modifier onlyRewards(){
        require(msg.sender==rewardsAddress, "You can only access this function from the rewards contract");
    _;
    }
    

    //setters

    /**
     * @notice set the rewards contract address
     */
    function setRewards(address _rewardsAddress) external onlyOwner{
        rewardsAddress=_rewardsAddress;
    }    

    /**
     * @notice set the market address
     */
    function setMarket(address _marketAddress) external onlyOwner{
        marketAddress=_marketAddress;
    }

    /**
     * @notice set the despositor for a specific NFT
     */
    function setDepositor(address nftAddress, uint tokenID, address depositor) external onlyMarket{
        depositors[tokenID][nftAddress]=depositor;
    }

    /**
     * @notice set claims to a certain 
     */
    function setClaims(address depositor, uint amount ) external onlyRewards{

        claims[depositor]=amount;
    }

    function setPrice(address nftAddress, uint tokenID, uint price) external onlyMarket{

        nftPrice[nftAddress][tokenID]=price;
    }

    function pushOffer(address nftAddress, uint tokenID, uint offerPrice, address offerMaker, uint offerBlock,uint offerTime ) external onlyMarket returns (uint) {

        nftOffers[nftAddress][tokenID].push(Offer(offerPrice,offerMaker,offerBlock, offerTime));

        return (nftOffers[nftAddress][tokenID].length - 1);
    }

    function setOfferBid(address nftAddress, uint tokenID, uint offerIndex, uint offer) external onlyMarket returns (uint){
        nftOffers[nftAddress][tokenID][offerIndex].bid=offer;
    }


    function pushIndex(address depositor, uint number) external onlyMarket{

        indexes[depositor].push(number);
    }

    function pushVolumeSales(uint amount) external onlyMarket{

        vol_sales.push(amount);
    }

    function pushVolumes(address depositor, uint amount) external onlyMarket{

        volumes[depositor].push(amount);
    }
    

    function pushTotalVolume() external onlyMarket{

        vol_sales_total.push(total_volume);
    }

    function updateTotalVolume(uint amount) external onlyMarket{

        total_volume=total_volume+amount;
    }

    function updateTotalBalance( uint amount) external onlyMarket{

        total_balance+=amount;
    }

    //balance

    function _balance(address  depositor) internal view returns (uint){

        uint formula;
        uint i;
        uint k;
        uint v;


        if (volumes[depositor][0]>0 && vol_sales.length>1)
        {
            //This formula is detailed in the whitepaper

            v=SafeMath.getSum(volumes[depositor],0,volumes[depositor].length);

            for (k=indexes[depositor][indexes[depositor].length-1]+1; k<vol_sales.length;k++){

                formula+=fee*vol_sales[k]*v/vol_sales_total[k-1]/100;
            }

            for (i=0; i<indexes[depositor].length-1; i++){

                v=SafeMath.getSum(volumes[depositor],0,i+1);

                for (k=indexes[depositor][i]+1; k<=indexes[depositor][i+1]; k++){

                        formula+=fee*vol_sales[k]*v/vol_sales_total[k-1]/100;

                }
            }

            return (formula-claims[depositor]);

        }
        else
        {
            //returns 0 if the address never sold any asset through the smart contract
            return (0);
        }

    }

    //getters

    function getDepositor(address nftAddress, uint tokenID) external view returns (address){
        return depositors[tokenID][nftAddress];
    }

    function getBalance(address depositor) external view returns (uint){

        return _balance(depositor);
    }

    function getClaims(address depositor) external view returns (uint){

        return claims[depositor];
    }

    function getPrice(address nftAddress, uint tokenID) external view returns (uint){

        return nftPrice[nftAddress][tokenID];
    }

    function getOfferBid(address nftAddress, uint tokenID, uint offerIndex) external view returns (uint) {

        return nftOffers[nftAddress][tokenID][offerIndex].bid;
    }

    function getLastOfferBid(address nftAddress, uint tokenID) external view returns (uint){

        uint lastIndex=nftOffers[nftAddress][tokenID].length-1;
        return nftOffers[nftAddress][tokenID][lastIndex].bid;
    }

    function getOfferBidder(address nftAddress, uint tokenID, uint offerIndex) external view returns (address){

        return nftOffers[nftAddress][tokenID][offerIndex].bidder;
    }

    function getOfferStamp(address nftAddress, uint tokenID, uint offerIndex) external view returns (uint){

        return nftOffers[nftAddress][tokenID][offerIndex].bidStamp;
    }

    function getOfferTime(address nftAddress, uint tokenID, uint offerIndex) external view returns (uint){

        return nftOffers[nftAddress][tokenID][offerIndex].bidTime;
    }

    function getOffersLength(address nftAddress, uint tokenID) external view returns(uint){

        return nftOffers[nftAddress][tokenID].length;
    }

    function getVolumes(address depositor) external view returns (uint[] memory){

        return volumes[depositor];
    }

    function getIndexes(address depositor) external view returns (uint[] memory){

        return indexes[depositor];
    }

    function getTokenForOffer() external view returns (address){

        return tokenForOffer;
    }

    



}