/*
MIT License

Copyright (c) 2021 Joshua IvÃ¡n Mendieta Zurita

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// SPDX-License-Identifier: MIT License
pragma solidity ^0.8.9;

// Importing the contracts Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole
import "./Ownable.sol";
import "./Farmer Role.sol";
import "./Distributor Role.sol";
import "./Retailer Role.sol";
import "./Consumer Role.sol";

// Define a contract 'Supplychain'
contract SupplyChain is Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole {
      // Define a variable called 'upc' for Universal Product Code (UPC)
      uint256 private upc;

      // Define a variable called 'sku' for Stock Keeping Unit (SKU)
      uint256 private sku;

      // Define a public mapping 'items' that maps the UPC to an Item.
      mapping (uint256 => Item) private items;
  
      // Define enum 'State' with the following values:
      // Harvested : 0
      // Processed : 1
      // Packed : 2
      // ForSale : 3
      // Sold : 4
      // Shipped : 5
      // Received : 6
      // Purchased : 7
      enum State { 
            Harvested,  
            Processed,  
            Packed,     
            ForSale,    
            Sold,       
            Shipped,    
            Received,   
            Purchased   
      }

      State constant defaultState = State.Harvested;

      // Define a struct 'Item' with the following fields:
      struct Item {
            uint256 sku;  // Stock Keeping Unit (SKU)
            uint256 upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
            address ownerID;  // Metamask-Ethereum address of the current origOwner as the product moves through 8 stages
            address originFarmerID; // Metamask-Ethereum address of the Farmer
            string originFarmName; // Farmer Name
            string originFarmInformation;  // Farmer Information
            string originFarmLatitude; // Farm Latitude
            string originFarmLongitude;  // Farm Longitude
            string originCropURL; // URL of the Crops (it can be a photo url or a live stream video url)
            uint256 productID;  // Product ID potentially a combination of upc + sku
            string productNotes; // Product Notes
            uint256 productPrice; // Product Price
            State itemState;  // Product State as represented in the enum above
            address distributorID;  // Metamask-Ethereum address of the Distributor
            address retailerID; // Metamask-Ethereum address of the Retailer
            address consumerID; // Metamask-Ethereum address of the Consumer
      }

      // Define 8 events with the same 8 state values and accept 'upc' as input argument
      event Harvested(uint256 upc);
      event Processed(uint256 upc);
      event Packed(uint256 upc);
      event ForSale(uint256 upc);
      event Sold(uint256 upc);
      event Shipped(uint256 upc);
      event Received(uint256 upc);
      event Purchased(uint256 upc);

      // Define a modifer that verifies the Caller
      modifier verifyCaller (address _address) {
            require(msg.sender == _address); 
            _;
      }

      // Define a modifier that checks if the paid amount is sufficient to cover the price
      modifier paidEnough(uint256 _price) { 
            require(msg.value >= _price); 
            _;
      }
  
      // Define a modifier that checks the price and refunds the remaining balance
      modifier checkValue(uint256 _upc , address _address) {
            _;
            uint256 _price = items[_upc].productPrice;
            uint256 amountToReturn = msg.value - _price;
            payable(_address).transfer(amountToReturn);
      }

      // Define a modifier that checks if an item.state of a upc is Harvested
      modifier harvested(uint256 _upc) {
            require(items[_upc].itemState == State.Harvested);
            _;
      }

      // Define a modifier that checks if an item.state of a upc is Processed
      modifier processed(uint256 _upc) {
            require(items[_upc].itemState == State.Processed);
            _;
      }
  
      // Define a modifier that checks if an item.state of a upc is Packed
      modifier packed(uint256 _upc) {
            require(items[_upc].itemState == State.Packed);
            _;
      }

      // Define a modifier that checks if an item.state of a upc is ForSale
      modifier forSale(uint256 _upc) {
            require(items[_upc].itemState == State.ForSale);
            _;
      }

      // Define a modifier that checks if an item.state of a upc is Sold
      modifier sold(uint256 _upc) {
            require(items[_upc].itemState == State.Sold);
            _;
      }
  
      // Define a modifier that checks if an item.state of a upc is Shipped
      modifier shipped(uint256 _upc) {
            require(items[_upc].itemState == State.Shipped);
            _;
      }

      // Define a modifier that checks if an item.state of a upc is Received
      modifier received(uint256 _upc) {
            require(items[_upc].itemState == State.Received);
            _;
      }

      // Define a modifier that checks if an item.state of a upc is Purchased
      modifier purchased(uint256 _upc) {
            require(items[_upc].itemState == State.Purchased);
            _;
      }

      // In the constructor set 'origOwner' to the address that instantiated the contract
      // and set 'sku' to 1
      // and set 'upc' to 1
      constructor() {
            origOwner = msg.sender;
            sku = 1;
            upc = 1;
      }

      // Define a function 'kill' if required
      function kill() external onlyOwner {
            if (msg.sender == origOwner) {
                  selfdestruct(payable(origOwner));
            }
      }

      // Define a function 'harvestItem' that allows a farmer to mark an item 'Harvested'
      // Access Control List enforced by calling Smart Contract / DApp
      function harvestItem(
            uint256 _upc, 
            string memory _originFarmName, 
            string memory _originFarmInformation, 
            string memory _originFarmLatitude, 
            string memory _originFarmLongitude,
            string memory _originCropURL
      ) external onlyFarmer {
            // Add the new item as part of Harvest
            uint256 productID = _upc + sku;
            items[_upc].sku = sku;
            items[_upc].upc = _upc;
            items[_upc].ownerID = msg.sender;
            items[_upc].originFarmerID = msg.sender;
            items[_upc].originFarmName = _originFarmName;
            items[_upc].originFarmInformation = _originFarmInformation;
            items[_upc].originFarmLatitude = _originFarmLatitude;
            items[_upc].originFarmLongitude = _originFarmLongitude;
            items[_upc].originCropURL = _originCropURL;
            items[_upc].productID = productID;
            items[_upc].itemState = State.Harvested;
            // Increment sku
            sku = sku + 1;
            // Emit the appropriate event
            emit Harvested(_upc);
      }

      // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
      // Call modifier to check if upc has passed previous supply chain stage
      // Call modifier to verify caller of this function
      // Access Control List enforced by calling Smart Contract / DApp
      function processItem(uint256 _upc) external onlyFarmer harvested(_upc) {
            // Update the appropriate fields
            items[_upc].itemState = State.Processed;
            // Emit the appropriate event
            emit Processed(_upc);
      }

      // Define a function 'packItem' that allows a farmer to mark an item 'Packed'
      // Call modifier to check if upc has passed previous supply chain stage
      // Call modifier to verify caller of this function
      // Access Control List enforced by calling Smart Contract / DApp
      function packItem(uint256 _upc, string memory _productNotes) external onlyFarmer processed(_upc) {
            // Update the appropriate fields
            items[_upc].itemState = State.Packed;
            items[_upc].productNotes = _productNotes;
            // Emit the appropriate event
            emit Packed(_upc);
      }

      // Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'
      // Call modifier to check if upc has passed previous supply chain stage
      // Call modifier to verify caller of this function
      // Access Control List enforced by calling Smart Contract / DApp
      function sellItem(uint256 _upc, uint256 _price) external onlyFarmer packed(_upc) {
            // Update the appropriate fields
            items[_upc].itemState = State.ForSale;
            items[_upc].productPrice = _price;
            // Emit the appropriate event
            emit ForSale(_upc);
      }

      // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
      // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
      // and any excess ether sent is refunded back to the buyer

      // Call modifier to check if upc has passed previous supply chain stage
      // Call modifer to check if buyer has paid enough
      // Call modifer to send any excess ether back to buyer
      // Access Control List enforced by calling Smart Contract / DApp
      function buyItem(uint256 _upc) external payable onlyDistributor forSale(_upc) paidEnough(_upc) checkValue(_upc , msg.sender) {  
            // Update the appropriate fields - ownerID, distributorID, itemState
            items[_upc].ownerID = msg.sender;
            items[_upc].distributorID = msg.sender;
            items[_upc].itemState = State.Sold;
            // Transfer money to farmer
            uint productPrice = items[_upc].productPrice;
            payable(items[_upc].originFarmerID).transfer(productPrice);
            // Emit the appropriate event
            emit Sold(_upc);
      }

      // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
      // Use the above modifers to check if the item is sold

      // Call modifier to check if upc has passed previous supply chain stage
      // Call modifier to verify caller of this function
      // Access Control List enforced by calling Smart Contract / DApp
      function shipItem(uint256 _upc) external onlyDistributor sold(_upc) {
            // Update the appropriate fields
            items[_upc].itemState = State.Shipped;
            // Emit the appropriate event
            emit Shipped(_upc);
      }

      // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
      // Use the above modifiers to check if the item is shipped

      // Call modifier to check if upc has passed previous supply chain stage
      // Access Control List enforced by calling Smart Contract / DApp
      function receiveItem(uint256 _upc) external onlyRetailer shipped(_upc) {
            // Update the appropriate fields - ownerID, retailerID, itemState
            items[_upc].ownerID = msg.sender;
            items[_upc].retailerID = msg.sender;
            items[_upc].itemState = State.Received;
            // Emit the appropriate event
            emit Received(_upc);
      }

      // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
      // Use the above modifiers to check if the item is received

      // Call modifier to check if upc has passed previous supply chain stage
      // Access Control List enforced by calling Smart Contract / DApp
      function purchaseItem(uint256 _upc) external payable onlyConsumer received(_upc) paidEnough(_upc) checkValue(_upc, msg.sender) {
            // Update the appropriate fields - ownerID, consumerID, itemState
            items[_upc].ownerID = msg.sender;
            items[_upc].consumerID = msg.sender;
            items[_upc].itemState = State.Purchased;
            // Transfer money to farmer
            uint productPrice = items[_upc].productPrice;
            payable(items[_upc].retailerID).transfer(productPrice);
            // Emit the appropriate event
            emit Purchased(_upc);
      }

      // Define a function 'fetchItemBufferOne' that fetches the data
      function fetchItemBufferOne(uint256 _upc) external view returns (
            uint256 itemSKU,
            uint256 itemUPC,
            address ownerID,
            address originFarmerID,
            string memory originFarmName,
            string memory originFarmInformation,
            string memory originFarmLatitude,
            string memory originFarmLongitude,
            string memory originCropURL
      ) {
            // Assign values to the 8 parameters
            Item memory item = items[_upc];
            return (
                  item.sku,
                  item.upc,
                  item.ownerID,
                  item.originFarmerID,
                  item.originFarmName,
                  item.originFarmInformation,
                  item.originFarmLatitude,
                  item.originFarmLongitude,
                  item.originCropURL
            );
      }

      // Define a function 'fetchItemBufferTwo' that fetches the data
      function fetchItemBufferTwo(uint256 _upc) external view returns (
            uint256 itemSKU,
            uint256 itemUPC,
            uint256 productID,
            string memory productNotes,
            uint256 productPrice,
            State itemState,
            address distributorID,
            address retailerID,
            address consumerID
      ) {
            Item memory item = items[_upc];
            // Assign values to the 9 parameters
            return (
                  item.sku,
                  item.upc,
                  item.productID,
                  item.productNotes,
                  item.productPrice,
                  item.itemState,
                  item.distributorID,
                  item.retailerID,
                  item.consumerID
            );
      }
}