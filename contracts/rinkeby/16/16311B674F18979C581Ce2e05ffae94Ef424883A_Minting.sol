/**
 *Submitted for verification at Etherscan.io on 2021-05-26
*/

pragma solidity 0.8.3;
abstract contract ERC20 {
    function totalSupply() external virtual view returns (uint256);
    function balanceOf(address account) external virtual view returns (uint256);
    function transfer(address recipient, uint256 amount) external virtual returns (bool);
    function allowance(address owner, address spender) external virtual view returns (uint256);
    function approve(address spender, uint256 amount) external virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// ADD THIS LOGIC TO THE RELAYER CONTRACT!
abstract contract DigifoxRelayer {
    // A POINTS & FEES VAR SHOULD BE UPDATED WHENEVER DEPOSITS/SWAPS OCCUR BASED ON STAKING PERIOD 
    // TODO: IMPORTANT!! STOP ACCUMULATING REWARDS ONCE THE MINTING PERIOD HAS ENDED!!!!!!
    // TODO: MAKE POINT PRECISION TO BE 10^18
    struct RelayerAddresses { 
       mapping(uint256 => uint256) feesGeneratedPerPeriod;   // ie: Period 1 == 3020, Period 2 == 5020...
       mapping(uint256 => uint256) pointsGeneratedPerPeriod; // ie: Period 1 == 3220, Period 2 == 5720... MAKE POINT PRECISION TO BE 10^18
       uint256 stakingOrigin; // ie, started staking on block 19203...
       uint256 claimedRewards; // How much HAVE been claimed
       uint256 lastBlockRedeemed; // The last block that a redeem action occured (for staking)
       uint256 lastPeriodRedeemed; // The last period withdrawn from (for minting redeem logic)
       
       address owningAddress; // for convenience 
       
    }
    
    mapping(address => RelayerAddresses) relayerAddresses;
    mapping(uint256 => uint256) public periodsAndFees; // ie: Period 1 == $50,000, Period 2 == $75,000
    mapping(uint256 => uint256) periodsAndPoints; // ie: Period 1 == 54000 POINTS, Period 2 == 79000 POINTS
    mapping(uint256 => uint256) periodsAndBlocks; // ie: Period 1 == Block 234213, Period 2 == Block 253422
    mapping(uint256 => uint256) periodsAndActualMinted; // ie: Period 1 == 80,000 DGF, Period 2 == 52,352 DGF
    // address[] public eligableAddresses; // any address that is eligable to receive a reward
    mapping(address => bool) addressIsEligable;
    uint256 public currentPeriod;
    
    // General Upkeep Functions
    function setCurrentPeriod(uint256 _period) external virtual;
    function getTotalFeesOfPeriod(uint256 _period) external virtual view returns (uint256 totalReward);
    function getPointsOfPeriod(uint256 _period) external virtual view returns (uint256 totalPoints);
    function checkAccumulatedRewards(address _check) external virtual view returns (uint256 accumulatedRewards);
    function setPeriodMintedTokens(uint256 _period, uint256 _minted) external virtual;
    
    // RelayerAddresses Functions
    function addToClaimedRewards(address _redeemer, uint256 _minted) external virtual;
    function getPointsOfUserByPeriod(address _redeemer, uint256 _period) external virtual view returns (uint256 points);
    function checkLastPeriodRedeemed(address _check) external virtual view returns (uint256 lastPeriod);
    function updateLastTimeRedeemed(address _redeemer, uint256 _period) external virtual; // update lastPeriodRedeemed & lastBlockRedeemed (block.number)
    
    
    /*  RELAYER WILL NEED TO HAVE A MODIFIED VERSION OF THIS LOGIC!!!
    /*  THIS WILL NEED TO BE CALLED WHENEVER A FEE-GENERATING ACTION TAKES
    /*  PLACE AND UPDATE THE pointsGeneratedPerPeriod VARIABLE IN relayerAddresses.
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       address _check the address to check the staking reward
                        multiplier of.
        Returns:    uint256 stakingMultiplier, the current yield from staking.
        Notes:      Used to determine extra rewards for users who are staking.
    **********************************************************************
    
    function determineCurrentStakingMultiplier(address _check) public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = block.number.sub(stakingPeriod[_check]);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x AFTER 2 YEARS (1.5x after 1 year, s-curve, modify logic to fit this)
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    */
}

// CONTRACT FOR MINTING NEW DGF TOKENS
// Accept (as input) the % of fees generated by different users...
// TODO: Make this rely on the relayer contracts for fees generated
// TODO: Make this contract polymorphic to support the different minting programs
// TODO: Make decimal precision WAY higher (think in terms of millions of users)

contract Minting {
    
    address private constant dgfAddress = address(0x0);
    address private constant relayerAddress = address(0x0); // Maybe make this an array for multiple relayers.
    
    DigifoxRelayer public relayer       = DigifoxRelayer(relayerAddress);
    ERC20   public token                = ERC20(dgfAddress); // Digifox Token
    
    address public owner;
    uint256 public totalActualMinted;
    uint256 public totalExtraTokens;
    uint256 private periodsElapsed;
    uint256 private lastBlockMinted;
    
    uint256 private constant blocksInAMonth     = 195810; // 195810 blocks every 30 days
    uint256 private constant decayMinuend       = 104000000000000000000000;
    uint256 private constant decaySubtrahend    = 2122000000000000000000;
    uint256 private constant decimals           = 18; 
    uint256 private constant maxPeriods         = 49;
    
    mapping(uint256 => uint256) public actualMintedAmount;
    mapping(address => bool) public mintingAdmins;
    
    
    /***********************  MODIFIERS AND CONSTRUCTOR  ***********************/ 
    
    modifier monthPassedAndMintingActive() {
        // The last block minted must have been a month ago.
        require(block.number >= (lastBlockMinted + blocksInAMonth) && periodsElapsed <= maxPeriods);
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner may use this function.");
        _;
    }
    
    modifier onlyOwnerOrAdmin() {
        require(msg.sender == owner || mintingAdmins[msg.sender], "Only the owner or admins may use this function.");
        _;
    }
    
    constructor() {
        periodsElapsed = 1;
        lastBlockMinted = 0;
        owner = msg.sender;
    }
    
    /**************************  USER FUNCTIONS  **************************/ 
    /***********************************************************************
        Function:   redeemAirdrop()
        Args:       None
        Returns:    None
        Notes:      Used to redeem your airdop.
    ***********************************************************************/
    
    function redeemAirdrop() public {
        uint256 accumulatedRewards = relayer.checkAccumulatedRewards(msg.sender);
        require(accumulatedRewards > 0, "There are no tokens left to redeem.");
        
        uint256 _reward = checkReward();
        
        relayer.addToClaimedRewards(msg.sender, _reward);
        token.transfer(msg.sender, _reward);
        relayer.updateLastTimeRedeemed(msg.sender, periodsElapsed);
    }
    
    /**************************  ADMIN FUNCTIONS  **************************/ 
    // Don't forget to add recovery functions for extra tokens //

    /***********************************************************************
        Function:   mint()
        Args:       uint256 dollar_value the current price DGF is valued at 
                        in THOUSANDS (1001 = $1.001).
        Returns:    None
        Notes:      Used to mint tokens for early adopters.
    ***********************************************************************/
    
    function mint(uint256 dollar_value) public onlyOwnerOrAdmin monthPassedAndMintingActive returns (uint256 mintedDuringThisPeriod) {
        
        uint256 rewardMultiplier = determineCurrentRewardMultiplier(dollar_value, relayer.getTotalFeesOfPeriod(periodsElapsed));
        
        lastBlockMinted = block.number;
        mintedDuringThisPeriod = (currentUpperBound() * rewardMultiplier) / (100000);
        
        relayer.setPeriodMintedTokens(periodsElapsed, mintedDuringThisPeriod);
        
        // Variables to maintain minting functionality within this contract
        totalActualMinted = totalActualMinted + mintedDuringThisPeriod;
        actualMintedAmount[periodsElapsed] = mintedDuringThisPeriod;
        periodsElapsed = periodsElapsed + 1;
        totalExtraTokens = totalExtraTokens + (currentUpperBound() - totalActualMinted);
        
        relayer.setCurrentPeriod(periodsElapsed);
        return mintedDuringThisPeriod;
    }
    /***********************************************************************
        Function:   addAdmin()
        Args:       address _admin a new admin.
        Returns:    None
        Notes:      Used by the owner to add an admin for easy minting 
                        functionality maintenance.
    ***********************************************************************/
    
    function addAdmin(address _admin) public onlyOwner {
        mintingAdmins[_admin] = true;
    }
    
    /***********************************************************************
        Function:   revokeAdmin()
        Args:       address _admin of a previous admin.
        Returns:    None
        Notes:      Used by the owner to remove an admin for easy minting 
                        functionality maintenance.
    ***********************************************************************/
    
    function revokeAdmin(address _admin) public onlyOwner {
        mintingAdmins[_admin] = false;
    }
    
    /***********************************************************************
        Function:   redeemAirdropForAnother()
        Args:       address _other, the user you are redeeming for.
        Returns:    None
        Notes:      Used to redeem the airdrop for another user. Only admins
                        or the owner may use this function.
    ***********************************************************************/
    
    function redeemAirdropForAnother(address _other) public onlyOwnerOrAdmin {
        uint256 accumulatedRewards = relayer.checkAccumulatedRewards(_other);
        require(accumulatedRewards > 0, "There are no tokens left to redeem.");
        
        uint256 _reward = checkReward();
        
        relayer.addToClaimedRewards(_other, _reward);
        token.transfer(_other, _reward);
        relayer.updateLastTimeRedeemed(_other, periodsElapsed);
    }
    
    /******************************   VIEWS   ******************************/ 
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       uint256 dollar_value the current price DGF is valued at 
                        in THOUSANDS (1001 = $1.001).
                    uint256 totalFeesGenerated the current dollar value in 
                        fees generated since the last minting (no decimal).
        Returns:    uint256 currMultiplier, the current percent to mint.
        Notes:      Used to get the percent of the upper bound to mint. 
                        Percent that is generated is in the HUNDRED THOUSANDS
                        for precision purposes (ie: 24556 = 24.556%).
    ***********************************************************************/
    
    // TODO: Change staking logic to be an S curve where 50% bonus (1500) after 1 year, 100% bonus after year 2 (2000)
    // TODO: Move staking to its own smart contract?
    
    
    function determineCurrentRewardMultiplier(uint256 dollar_value, uint256 totalFeesGenerated) public view returns (uint256 currMultiplier) {
        currMultiplier = (totalFeesGenerated * (100000)) / (dollar_value * (currentUpperBound() / (10 ** decimals)) / (1000));
        
        if (currMultiplier >= 100000) return 100000;
        return currMultiplier;
    }
    
    /***********************************************************************
        Function:   checkReward()
        Args:       None
        Returns:    None
        Notes:      Used to determine if the calling address has a reward.
    ***********************************************************************/
    
    function checkReward() public view returns (uint256 _reward) {
        if(relayer.checkLastPeriodRedeemed(msg.sender) == 0) { // First time redeeming
            for(uint256 i = 1; i <= periodsElapsed; i++) {
                // Figure out how much of the reward one should get
                _reward = _reward + (((relayer.getPointsOfUserByPeriod(msg.sender, i)) * (10**decimals)) / (relayer.getPointsOfPeriod(i)));
            }
        }
        else { // Has redeemed before
            for(uint256 i = relayer.checkLastPeriodRedeemed(msg.sender); i <= periodsElapsed; i++) {
                // Figure out how much of the reward one should get
                _reward = _reward + (((relayer.getPointsOfUserByPeriod(msg.sender, i)) * (10**decimals)) / (relayer.getPointsOfPeriod(i)));
            }
        }
        
        return _reward;
    }
    
    /***********************************************************************
        Function:   checkRewardOfAddress()
        Args:       address _check the user you are checking for
        Returns:    None
        Notes:      Used to determine if the calling address has a reward. 
                        Only admins or the owner may use this function.
    ***********************************************************************/
    
    function checkRewardOfAddress(address _check) public view onlyOwnerOrAdmin returns (uint256 _reward) {
        if(relayer.checkLastPeriodRedeemed(_check) == 0) { // First time redeeming
            for(uint256 i = 1; i <= periodsElapsed; i++) {
                // Figure out how much of the reward one should get
                _reward = _reward + (((relayer.getPointsOfUserByPeriod(_check, i)) * (10**decimals)) / (relayer.getPointsOfPeriod(i)));
            }
        }
        else { // Has redeemed before
            for(uint256 i = relayer.checkLastPeriodRedeemed(_check); i <= periodsElapsed; i++) {
                // Figure out how much of the reward one should get
                _reward = _reward + (((relayer.getPointsOfUserByPeriod(_check, i)) * (10**decimals)) / (relayer.getPointsOfPeriod(i)));
            }
        }
        return _reward;
    }
    
    /***********************************************************************
        Function:   currentUpperBound()
        Args:       None
        Returns:    uint256 currBound, the current upper bound.
        Notes:      Used to calculate the current upper bound reward.
    ***********************************************************************/
    
    function currentUpperBound() public view returns (uint256 currBound) {
        return decayMinuend - (decaySubtrahend * periodsElapsed);
    }
    
    /***********************************************************************
        Function:   upperBoundOfPeriod()
        Args:       uint256 _period the period to get the upper bound for.
        Returns:    uint256 currBound, the current upper bound.
        Notes:      Used to calculate the current upper bound reward.
    ***********************************************************************/
    
    function upperBoundOfPeriod(uint256 _period) public pure returns (uint256 currBound) {
        return decayMinuend - (decaySubtrahend * _period);
    }
    
    
    // TEST FUNCTIONS REMOVE BEFORE DEPLOYING
    
    
    function TEST_determineCurrentStakingMultiplier(uint256 curr_block, uint256 block_staked) public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = curr_block - block_staked;
        uint256 blocksInAYear = blocksInAMonth * 12;
        
        stakingMultiplier = ((blocksStaked * 1000) / (blocksInAYear)) + (1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    
    // LEGACY UNUSED FUNCTIONS!
    
    
    /***********************************************************************
        Function:   removeStaker()
        Args:       None
        Returns:    None
        Notes:      
    ***********************************************************************
    
    function removeStaker(address _other) public onlyOwnerOrAdmin {
        //TODO: do this function
    }
    
    
    /***********************************************************************
        Function:   beginStakingForAnother()
        Args:       address _participant a participant to add.
        Returns:    None
        Notes:      Used by the owner to add a participant for easy minting 
                        functionality maintenance.
    ***********************************************************************
    
    function beginStakingForAnother(address _address) public onlyOwnerOrAdmin {
        require(!isStaking[_address], "This user is already staking.");
        stakingAddresses.push(_address);
        isStaking[_address] = true;
        if (stakingPeriod[_address] == 0) stakingPeriod[_address] = block.number;
    }
    
    
    /***********************************************************************
        Function:   beginStaking()
        Args:       None
        Returns:    None
        Notes:      Used by a user to take place in the early adopters 
                        program.
    ***********************************************************************
    
    function beginStaking() public {
        require(!isStaking[msg.sender], "This user is already staking.");
        require(relayer.addressIsEligable[msg.sender], "This user is not using an elgiable Digifox wallet.");
        //TODO: MAKE SURE THE CALLING ADDRESS IS WHITELISTED AS A DIGIFOX USER!!!
        // Work with the Celsius team to do this?
        // stakingAddresses.push(msg.sender); HAVE TO USE A MAP
        
        
        isStaking[msg.sender] = true;
        if (stakingPeriod[msg.sender] == 0) stakingPeriod[msg.sender] = block.number;
    }
    
    /***********************************************************************
        Function:   getStakingOriginBlock()
        Args:       address _check the address to check the staking origin of.
        Returns:    uint256 startingBlock, the block staking was started.
        Notes:      Used to determine when staking began.
    ***********************************************************************
    
    function getStakingOriginBlock(address _check) public view returns (uint256 startingBlock) {
        return stakingPeriod[_check];
    }
    
    /***********************************************************************
        Function:   getStakingOriginBlock()
        Args:       None
        Returns:    uint256 startingBlock, the block staking was started.
        Notes:      Used to determine when staking began for the calling user.
    ***********************************************************************
    
    function getStakingOriginBlock() public view returns (uint256 startingBlock) {
        return stakingPeriod[msg.sender];
    }
    
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       address _check the address to check the staking reward
                        multiplier of.
        Returns:    uint256 stakingMultiplier, the current yield from staking.
        Notes:      Used to determine extra rewards for users who are staking.
    ***********************************************************************
    
    function determineCurrentStakingMultiplier(address _check) public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = block.number.sub(stakingPeriod[_check]);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       None.
        Returns:    uint256 stakingMultiplier, the current yield from staking.
        Notes:      Used to determine extra rewards for the calling user.
    ***********************************************************************
    
    function determineCurrentRewardMultplier() public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = block.number.sub(stakingPeriod[msg.sender]);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    */
}