/**
 *Submitted for verification at Etherscan.io on 2021-04-11
*/

pragma solidity ^0.5.16;

/**
  * @title
  *
  * @notice  NFT Factory: ERC-721 NFT token generated by user selfly  
  * 
  */
  
/***
* 
* MIT License
* ===========
* 
*  Copyright (c) 2020 
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
contract IERC721Receiver {
    /**
     * @notice Handle the receipt of an NFT
     * @dev The ERC721 smart contract calls this function on the recipient
     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,
     * otherwise the caller will revert the transaction. The selector to be
     * returned can be obtained as `this.onERC721Received.selector`. This
     * function MAY throw to revert and reject the transfer.
     * Note: the ERC721 contract address is always the message sender.
     * @param operator The address which called `safeTransferFrom` function
     * @param from The address which previously owned the token
     * @param tokenId The NFT identifier which is being transferred
     * @param data Additional data with no specified format
     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
     */
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)
    public returns (bytes4);
}

interface AnftToken {
  function mint(address account, uint256 tokenId) external returns (bool);
  function safeMint(address to, uint256 tokenId, bytes calldata _data) external returns (bool);
  function ownerOf(uint256 tokenId) external returns (address owner);
  function totalSupply() external view returns (uint256);
  function safeTransferFrom(address from, address to, uint256 tokenId) external;
  function existData(uint256 _data) external view returns (bool);
}

interface ERC20Token {
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) ;    
  function transfer(address dst, uint rawAmount) external returns (bool);
  function balanceOf(address account) external view returns (uint);
} 

/*
interface ApwrToken {
  function mint(address account, uint256 amount) external;
  function totalSupply() external returns (uint256);
  function burnFrom(address account, uint256 _value) external;
} 

interface ArtdToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function mint(address account, uint256 amount) external;
}
*/
/*
interface NFTFactory{
    function getMeta( uint256 resId ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, address);
    function getMeta2( uint256 nftId ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256);
    function getFactory( uint256 nftId ) external view returns (address);
    function renewPromote( uint256 nftId, uint256 value ) external;
    function renewAmount( uint256 nftId, uint256 value ) external;
    function renewAPWR( uint256 nftId, uint256 value ) external;
    function renewSKILL( uint256 nftId, uint256 value ) external;
    function renewERA( uint256 nftId, uint256 value ) external;
    function renewLocktime( uint256 nftId, uint256 value ) external;
    function getAuthor( uint256 nftId ) external view returns (address);
    function getcreatedTime( uint256 nftId ) external view returns (uint256);
    function getLock( uint256 nftId ) external view returns (uint256);
}
*/
interface validfactory {
  function isValidfactory( address _factory ) external view returns (bool);
} 
/*
interface ArttToken {
  function transferFrom(address src, address dst, uint rawAmount) external returns (bool);
} 
*/

/*
interface RandomSeed {
  function random_getSeed( address sender, uint256 num ) external view returns (uint256);
  function random_get9999( address sender, uint256 random ) external view returns (uint);
  function random_get9999x( address sender, uint256 num ) external returns (uint);
} 
*/

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


/**
 * @title SafeMath
 * @dev Math operations with safety checks that revert on error
 */
library SafeMath {
    int256 constant private INT256_MIN = -2**255;

    /**
    * @dev Multiplies two unsigned integers, reverts on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Multiplies two signed integers, reverts on overflow.
    */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below

        int256 c = a * b;
        require(c / a == b);

        return c;
    }

    /**
    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.
    */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0); // Solidity only automatically asserts when dividing by 0
        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow

        int256 c = a / b;

        return c;
    }

    /**
    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    /**
    * @dev Subtracts two signed integers, reverts on overflow.
    */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a));

        return c;
    }

    /**
    * @dev Adds two unsigned integers, reverts on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    /**
    * @dev Adds two signed integers, reverts on overflow.
    */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a));

        return c;
    }

    /**
    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
    * reverts when dividing by zero.
    */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}


/**
 * Utility library of inline functions on addresses
 */
library Address {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solium-disable-next-line security/no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract nftMeta {

     mapping(uint256 => uint256) internal _era;
     mapping(uint256 => uint256) internal _grade;
     mapping(uint256 => uint256) internal _promote;
     mapping(uint256 => uint256) internal _artdamount;
     mapping(uint256 => uint256) internal _apwramount;
     mapping(uint256 => uint256) internal _skill;
     mapping(uint256 => address) internal _factory;
     
     mapping(uint256 => address) internal _author;
     mapping(uint256 => uint256) internal _createdTime;
     mapping(uint256 => uint256) internal _lock;
}    


contract RandomSeed is  Ownable {
    using SafeMath for uint256;
    using Address for address;
    constructor() public { }

    bool v6_switch = true;
    bool v5_switch = true;
    bool v4_switch = true;
    bool v3_switch = true;
    
    uint limit_v6_s = 9995;
    uint limit_v6_e = 9999;

    uint limit_v5_s = 9965;
    uint limit_v5_e = 9994;

    uint limit_v4_s = 9800;
    uint limit_v4_e = 9964;

    uint limit_v3_s = 9500;
    uint limit_v3_e = 9799;    

    //  Test area
    /*
    uint limit_v6_s = 8000;
    uint limit_v6_e = 9999;

    uint limit_v5_s = 6000;
    uint limit_v5_e = 7999;

    uint limit_v4_s = 4000;
    uint limit_v4_e = 5999;

    uint limit_v3_s = 2000;
    uint limit_v3_e = 3999;    
    */

    function _random_256( address senderx, uint256 num ) public view returns (uint256)
    {
       uint n = (block.timestamp+block.number) % 100;    
       uint256 seed = uint256(keccak256(abi.encodePacked(
            num + block.timestamp + block.difficulty +
            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now+n)) +
            block.gaslimit + 
            ((uint256(keccak256(abi.encodePacked(senderx)))) / (now-n)) +
            block.number
        )));
        return seed; 
    }
    /*
    function random_get9999( address sender, uint256 num ) public view returns (uint) {
        
        uint256 n = uint256((block.timestamp+block.number) % 100); 
        uint256 nump =  uint256(_random1( sender, num + n ) % 10000);
        uint256 v = uint256(keccak256(abi.encodePacked(n + nump + block.timestamp + block.difficulty )));
        v = v % 100;
        uint num_x = _random1( sender, n+v ) % 10000;
        uint num_xx = num_x % 1000;
        
        if( v6_switch == false && num_x >= limit_v6_s && num_x <= limit_v6_e )
        {
            num_x = 2000 + num_xx;
        }
        else if( v5_switch == false && num_x >= limit_v5_s && num_x <= limit_v5_e )
        {
            num_x = 2000 + num_xx;
        }
        else if( v4_switch == false && num_x >= limit_v4_s && num_x <= limit_v4_e )
        {
            num_x = 1000 + num_xx;
        }
        else if( v3_switch == false && num_x >= limit_v3_s && num_x <= limit_v3_e )
        {
            num_x = 1000 + num_xx;
        }

        return  num_x;
    }
    
    
    function swGrade( uint num, uint onoff ) external onlyOwner
    {
        bool sw = false;
        if( onoff > 0 )
           sw = true;
           
        if( num >= limit_v6_s && num <= limit_v6_e)
        {
            v6_switch = sw;
        }
        else if( num >= limit_v5_s && num <= limit_v5_e)
        {
            v5_switch = sw;
        }
        else if( num >= limit_v4_s && num <= limit_v4_e)
        {
            v4_switch = sw;
        }
        else if( num >= limit_v3_s && num <= limit_v3_e)
        {
            v3_switch = sw;
        }
                
    }
    
    function g6_switch() public view returns (bool) { return v6_switch; }
    function g5_switch() public view returns (bool) { return v5_switch; }
    function g4_switch() public view returns (bool) { return v4_switch; }
    function g3_switch() public view returns (bool) { return v3_switch; }
    */
}


 

contract NftRegister is  RandomSeed, nftMeta {
    using SafeMath for uint256;
    using Address for address;
    
    uint256 private releaseDate;
    
   // address public _artd =  address(0xA23F8462d90dbc60a06B9226206bFACdEAD2A26F);

    address public _anft =  address(0x3366BEdeFD41180E4e499d3BD4C717Da5b3C9A4e);
    
    //address public _apwr = address(0xb60F072494c7f1b5a8ba46bc735C71A83D940D1A);
    //address public _artt = address(0x77dF79539083DCd4a8898dbA296d899aFef20067);
    //address public _fundpool = address(0x37C8fC383e037f92f501E5884B8B5E37e3f5170E);
    
    address public _validchecker = address(0x5FD6eB55D12E759a21C09eF703fe0CBa1DC9d88D);
    
    //address private _randseed = address(0x75A7c0f3c7E59D0Aa323cc8832EaF2729Fe2127C);
    //address private _randseed = address(0x96cB202A24925d8A52b726Bc691E09cbD05618fa);
 
    //address public _relay = address(0xe9089848C9873B6cCcF72D23446EaA2851f77E61);
    address payable _teamWallet = address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);    
    address private _burnPool = 0x6666666666666666666666666666666666666666;
    address private init_address = address(0x3244C695758e077422DDB30Ec229595A6A92DC04);
    address private white_address = address(0x0000000000000000000000000000000000000000);
    
    //uint256 public _eraNFT = 2;   //  NEW Generration 
    //uint256 private pwrdist = 0.002 * 1e18;  // claim APWR amount 
    //uint256 private pwrupg  = 0.005 * 1e18;  // upgrade APWR amount
    //uint256 private pwrrelay  = 0.004 * 1e18;  // relay APWR amount
     
    address[] public _allfactorylist;
    uint256 public _storestartTime =  now + 365 days;
    uint256 private nonce = 0;
   // uint256 private max_promote = 9999;
//    uint256 public constant _rateBase = 10000; 
  //  uint256 public _burnRate = 250;       
    //uint256 public _rewardRate = 250;
    uint256 public _claimdays = 60 days;
    
    uint256[] private _allNft;
    uint256[] private _allReg;
    uint256[] private _stageReg;
    
    // Mapping from NFT-id to position in the allNft array
    mapping(uint256 => uint256) private _allNftIndex;
    
    uint256 public _factorycount = 0;
    uint256 public _factorylimit = 1000;
    
    uint public constant MaxRegister = 10000;
    
    bool public isRegister = false;
    bool public isPickup = false;
    // uint[] stagelimit = [ 4000, 3000, 2000, 1000, 0 ] ;
    uint[] public stagelimit = [ 12, 4, 3, 2, 0] ;
    uint[] public stageminted = [ 0, 0, 0, 0, 0 ] ;
    uint public current_stage = 0;
    
    uint16[] s0_objA = [ 64675,63700,61750,59150,55900,48750,39000,26000,13000,0 ];
    uint16[] s1_objA= [ 64350,63050,60667,56333,49833,42250,33583,23833,11917,0 ];
    uint16[] s2_objA = [ 63050,59800,53300,46800,39000,31200,23400,15600,7800,0 ];
    uint16[] s3_objA= [ 61100,56550,51350,45500,37700,28600,21450,14300,7150,0 ];

    uint16[] public round ;
    uint16[] public round_len ;
    uint16[] public shift ;
    
    //uint16[] public round = [ 0, 4, 8, 12 ];
    //uint16[] public round_len = [ 4, 4, 4, 3 ];
    //uint16[] public shift = [ 3, 2, 1, 1 ];
    
    uint256 Stage_p1 = 100000000000000000; // 0.1 ETH 
    uint256 Stage_p2 = 300000000000000000; // 0.3 ETH
    uint256 Stage_p3 = 500000000000000000; // 0.5 ETH
    uint256 Stage_p4 = 900000000000000000; // 0.9 ETH
    uint256[] stagePrice = [ Stage_p1, Stage_p2, Stage_p3, Stage_p4, 0 ] ;
    
            
    uint random_value = 778899;


    event NFTReceived(address operator, address from, uint256 tokenId, bytes data);
    event EncodeProperties(uint16 a, uint16 b,uint16 c, uint16 d);
    event CreatedProperties(uint256 pro);
    event RegisteredNFT(uint256 id, address wallet);


    mapping(uint256 => uint256) public _lastStoreTime;
    mapping(uint256 => uint) private _allowchallenge;
    mapping (address => bool) public hasClaimed;
    mapping (uint256 => address) public registeredAddress;
    mapping (uint256 => uint256) public registerPool;
    
    
    struct RegData {
        bool picked;
        uint num;
        address account;
    }
    struct StoreNft {
        uint256 tokenid;
    }
    mapping (uint256 => RegData[] ) public regdat;
    mapping (uint256 => StoreNft[] ) public tmpnft;
    
    /*
    mapping (uint256 => uint256) public registerpool0;
    mapping (uint256 => uint256) public registerpool1;
    mapping (uint256 => uint256) public registerpool2;
    mapping (uint256 => uint256) public registerpool3;
    */
   // Throws when msg.sender has already claimed the airdrop 
    modifier hasNotClaimed() {
        require(hasClaimed[msg.sender] == false);
        _;
    }
    
    // Throws when the 30 day airdrop period has passed 
    modifier canClaim() {
        require(releaseDate + _claimdays >= now);
        _;
    }

    modifier checkstoreStart() {
        require(block.timestamp > _storestartTime, "store not start");
        _;
    }

    constructor() public {
        
        releaseDate = now;
        _allfactorylist.push( address(this) );
        isRegister = true;
        isPickup = true;
    }

    function setAnft( address anft ) external onlyOwner {
        _anft = anft;
    }
    

    function getfactoryCount() public view returns( uint256 ) {
       return _factorycount;
    }
    
    function setlinkFactory( address[] calldata _factorylist ) external onlyOwner {
        _allfactorylist = _factorylist;
    }
 
    function setwhiteaddr( address _white ) external onlyOwner {
        white_address = _white;
    }
    
    function stageAdjust( uint nextstage ) external onlyOwner {
        if( nextstage >= 4 )
          isRegister = false;
        else
          isRegister = true; 
        current_stage = nextstage;
    }
    
    function priceResponse( uint stage, uint256 price ) external onlyOwner {
        stagePrice[stage] = price;
    }
    
        /**
     * @dev Gets the owner of the NFT ID
     * @param nftId uint256 ID of the token to query the owner of
     * @return owner address currently marked as the owner of the given NFT ID
     */
    function NFTownerOf(uint256 nftId) private returns (address) {
        AnftToken _anftx =  AnftToken(_anft);
        address owner = _anftx.ownerOf(nftId);
        require(owner != address(0));
        return owner;
    }

    function toBytes(uint256 x) pure internal returns (bytes memory b) {
         b = new bytes(32);
         assembly { mstore(add(b, 32), x) }
    }

    function claim_process( uint256 properties ) internal returns (uint256) {
 
        nonce = nonce + 1;
        uint256 id = 0; 

        bytes memory _xdata = toBytes(properties);

        AnftToken _anftx =  AnftToken(_anft);
        id = _anftx.totalSupply();
        uint pool_index = totalNFTs();
        
        _anftx.safeMint(address(this), id, _xdata );

        registerPool[pool_index] = id;
 
        return id;
    }

    function isContract(address _addr) internal view returns (bool)
    {
        uint32 size;
          assembly {
            size := extcodesize(_addr)
          }
          return (size > 0);
    }
    
    function convert_uint16 (uint256 _a) pure internal returns (uint16) 
    {
        return uint16(_a);
    }

    function encode_properties(uint16 a, uint16 b, uint16 c, uint16 d)  public pure returns (uint256) {
        uint16 [] memory dat = new uint16[] (4);
        dat[0] = a;
        dat[1] = b;
        dat[2] = c;
        dat[3] = d;
        uint i;
        uint256 result=0;
        for(i=0; i<4; i++) {
            result <<= 16;
            result |= dat[i];
        }
        return result;
    }
    
    function addRecord(uint number, address wallet) internal {
        RegData memory newd;
        newd.picked = false;
        newd.num = number;
        newd.account = wallet;
        regdat[current_stage].push(newd);
    }
    
    //function genRandom(uint randomx) public view returns (uint16,uint16,uint16,uint16)
    function genRandom() internal view returns (uint16,uint16,uint16,uint16)
    {

        uint randomx  = _random_256(msg.sender, nonce);
        uint16 random = convert_uint16(randomx % 65536);
        uint16 p0 = 0;
        uint16 p1 = 0;
        uint16 p2 = 0;
        uint16 p3 = 0;

        uint i=0;
        bool[4] memory flagx = [true,true,true,true];
        if( current_stage == 0)
        {
            for(i=0;i<10;i++)
            {
                if( flagx[0] && random >= s0_objA[i] )
                {   
                    p0 = 9-convert_uint16(i);
                    flagx[0] = false;
                }
            }
        }
        else if( current_stage == 1)
        {
            for(i=0;i<10;i++)
            {
                if( flagx[0] && random >= s1_objA[i] )
                {   
                    p0 = 9-convert_uint16(i);
                    flagx[0] = false;
                }
            }
        }
        else if( current_stage == 2)
        {
            for(i=0;i<10;i++)
            {
                if( flagx[0] && random >= s2_objA[i] )
                {   
                    p0 = 9-convert_uint16(i);
                    flagx[0] = false;
                }
            }
        }
        else if( current_stage == 3)
        {
            for(i=0;i<10;i++)
            {
                if( flagx[0] && random >= s3_objA[i] )
                {   
                    p0 = 9-convert_uint16(i);
                    flagx[0] = false;
                }
            }
        }        
        
        p1 = convert_uint16((randomx % 10000) / 100);
        p2 = convert_uint16((randomx % 100)/10);
        p3 = convert_uint16(randomx % 10);

        return (p0,p1,p2,p3);
    }
    
    function _claim_one( address reg_addr ) internal returns (uint16) {
        
          uint16 p1=0;
          uint16 p2=0;
          uint16 p3=0;
          uint16 p4=0;
          
          AnftToken _anftx =  AnftToken(_anft);
          uint256 en_data = 0;
          bool isexist = true;
          while( isexist ){
              nonce = nonce + 1;
              (p1,p2,p3,p4) = genRandom();
                
               emit EncodeProperties( p1,p2,p3,p4 );
               en_data = encode_properties( p1,p2,p3,p4 );
               
               isexist = _anftx.existData(en_data);
          }
          emit CreatedProperties( en_data );
    
          uint256 serial_id = claim_process( en_data );
          emit RegisteredNFT(serial_id, reg_addr);
          registeredAddress[serial_id] = reg_addr;
          addRecord( serial_id,  reg_addr );
          stageminted[current_stage] = stageminted[current_stage] + 1;
          
        return p1; 
    }
    
    function claim( uint amount, uint avl) internal canClaim {
        uint i=0;
        uint mintamount = amount;
        //address reg_addr = msg.sender;
        for(i=0;i< mintamount;i++)
        {
            /*
              uint16 p1=0;
              uint16 p2=0;
              uint16 p3=0;
              uint16 p4=0;
              
              AnftToken _anftx =  AnftToken(_anft);
              uint256 en_data = 0;
              bool isexist = true;
              while( isexist ){
                  nonce = nonce + 1;
                  (p1,p2,p3,p4) = genRandom();
                    
                   emit EncodeProperties( p1,p2,p3,p4 );
                   en_data = encode_properties( p1,p2,p3,p4 );
                   
                   isexist = _anftx.existData(en_data);
              }
              emit CreatedProperties( en_data );
    
              uint256 serial_id = claim_process( en_data );
              emit RegisteredNFT(serial_id, reg_addr);
              registeredAddress[serial_id] = reg_addr;
              addRecord( serial_id,  reg_addr );
              
              stageminted[current_stage] = stageminted[current_stage] + 1;
              */
              uint16 p1 = _claim_one( msg.sender );
              
              if( p1>=6 && avl>0 && i==(amount-1) ){
                  mintamount = mintamount + 1;
                 // reg_addr = init_address;
                  _claim_one( init_address );
              }
        }
    } 

    
        
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4) 
    {
        _addNft( tokenId );
        _addReg( tokenId );
        _addReg_stage( tokenId );
        emit NFTReceived(operator, from, tokenId, data);
        return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
    }

    /**
     * @dev Private function to remove a token from this extension's token tracking data structures.
     * This has O(1) time complexity, but alters the order of the _allTokens array.
     * @param nftId uint256 ID of the token to be removed from the tokens list
     */
     
    function _removeNft(uint256 nftId) private {

        uint256 lastNftIndex = _allNft.length.sub(1);
        uint256 NftIndex = _allNftIndex[nftId];

        uint256 lastNftId = _allNft[lastNftIndex];

        _allNft[NftIndex] = lastNftId; 
        _allNftIndex[lastNftId] = NftIndex; 

        _allNft.length--;
        _allNftIndex[nftId] = 0;
    }
    
    /**
     * @dev Private function to add a token to this extension's token tracking data structures.
     * @param tokenId uint256 ID of the token to be added to the tokens list
     */
    function _addNft(uint256 tokenId) private {
        _allNftIndex[tokenId] = _allNft.length;
        _allNft.push(tokenId);
    }
    
    /**
     * @dev Gets the total amount of NFT stored by the contract.
     * @return uint256 representing the total amount of NFT
     */
    function totalNFTs() public view returns (uint256) {
        return _allNft.length;
    }

    /**
     * @dev Gets the token ID at a given index of all the tokens in this contract
     * Reverts if the index is greater or equal to the total number of tokens.
     * @param index uint256 representing the index to be accessed of the tokens list
     * @return uint256 token ID at the given index of the tokens list
     */
    /*
    function registeredByIndex(uint256 index) public view returns (address) {
       // require(index < totalNFTs(), "RegisterAddress: global index out of bounds");
        return registeredAddress[index];
    }
    */
    
    function registeredNum(uint256 stage, uint256 index) public view returns (address) {
       // require(index < totalNFTs(), "RegisterAddress: global index out of bounds");
        return regdat[stage][index].account;
    }
    
    
    function getPriceMin() public view returns (uint256) {
       // require(block.timestamp >= SALE_START_TIMESTAMP, "Sale has not started");
       // require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");
          return stagePrice[current_stage];
    }
    
    function _addReg(uint256 tokenId) private {
        _allReg.push(tokenId);
    }
    
    function totalReg() public view returns (uint256) {
        return _allReg.length;
    }

    function _addReg_stage(uint256 tokenId) private {
        StoreNft memory snft;
        snft.tokenid = tokenId;
        tmpnft[current_stage].push(snft);
    }
    
    function totalstoreNft(uint256 stage) public view returns (uint256) {
        return tmpnft[stage].length;
    }    

    
    function registerNFT( uint256 amount ) public payable {
        require( isContract(msg.sender) == false, "Not allow contract to call");
        AnftToken _anftx =  AnftToken(_anft);
        uint totalminted = _anftx.totalSupply();
        
        require(isRegister, "isRegister: Register not enable");
        require(MaxRegister > totalminted, "MaxRegister: Not available");
        require(stageminted[current_stage]+amount <= stagelimit[current_stage], "stagelimit: Not available");
        uint avl = stagelimit[current_stage] - (stageminted[current_stage]+amount);
        require(totalminted.add(amount) <= MaxRegister, "Exceed max Register amount");
     //   require(stagePrice[current_stage].mul(amount) <= msg.value, "Ether too small");
        
        claim( amount, avl);
        
        if( stageminted[current_stage] >= stagelimit[current_stage]){
            current_stage = current_stage + 1;
        }
    }
    
    function Registered() public view returns (uint256) {
       // require(block.timestamp >= SALE_START_TIMESTAMP, "Sale has not started");
       // require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");
          return stagePrice[current_stage];
    }    

    function finializeErc20( address _token ) external onlyOwner {
        ERC20Token _tokenx =  ERC20Token(_token);
        uint _currentBalance =  _tokenx.balanceOf(address(this));
        _tokenx.transfer(_teamWallet, _currentBalance );
    }
    
    function finializeEth() external onlyOwner {
        uint256 _currentBalance =  address(this).balance;
        _teamWallet.transfer(_currentBalance);
    }
    /*
    function render() external {
        
        require( msg.sender == white_address, "Invalid white address");
        AnftToken _anftx =  AnftToken(_anft);
        uint op_stage;
        for(op_stage=0; op_stage<4; op_stage++) 
        {
            uint length = totalstoreNft(op_stage);
            if( length > 0 )
            {
                uint256  randomshift = random_value%length;
                uint i;
                for(i=0; i<length; i++) 
                {  
                   uint new_idx = i-randomshift;
                   if(i < randomshift){
                      new_idx = i+length-randomshift;
                   }
                   uint xid = regdat[op_stage][new_idx].num;
                   address register = regdat[op_stage][i].account;
                   if( register == init_address && address(this)==_anftx.ownerOf(xid))
                   {
                      _anftx.safeTransferFrom( address(this), msg.sender,xid );
                      _removeNft(0);
                      break;
                   }
                }
            }
        }
    }
    */
   function setRoundforPickup() external onlyOwner{ 
       
       uint rlen = round.length;
       if( rlen ==0 ){
            round.push(0);
       }
       else{
           uint16 x = round[rlen-1];
           uint16 y = round_len[rlen-1];
           round.push(x+y);
       }
       
       uint16 newlen = uint16(totalReg() - round[rlen]);
       round_len.push( newlen );
         
       uint16 randomshift = uint16(random_value%newlen);
       shift.push( randomshift );
       
   }
   
   function  pickindex (uint idx) public view returns (uint){
            uint r;
            uint my_round = 0;
            for(r=0; r<round.length; r++) 
            {
               if( idx >= round[r] )
                   my_round = r;
            }
            uint thesshift = shift[my_round];
            uint start = thesshift + round[my_round];
            uint len = round_len[my_round];
            uint new_idx = idx-start + round[my_round];
            if(idx < start){
                      new_idx = idx + len -start + round[my_round];
            }   
            return new_idx;
   }
    
    function pickupNFT() external { 
        require( isPickup, "isPickup: Pickup not enable");
        
        uint total=0;
        AnftToken _anftx =  AnftToken(_anft);
        uint op_stage;
        for(op_stage=0; op_stage<4; op_stage++) 
        {
            uint length = totalstoreNft(op_stage);
            total = total + length;
            uint rlen = round.length;
            if( length > 0 && rlen > 0)
            {
               // uint256  randomshift = random_value%length;
                uint allow = round[rlen-1]+round_len[rlen-1];
                if( total > allow ){ 
                    length = length - (total-allow);
                }
                
                uint i;
                for(i=0; i<length; i++) 
                {  
                   // uint new_idx = i-randomshift;
                   // if(i < randomshift){
                  // new_idx = i+length-randomshift;
                  // }
                  
                   
                   //uint xid = regdat[op_stage][new_idx].num;
                   bool status = regdat[op_stage][i].picked;
                   address register = regdat[op_stage][i].account;
                   if( register == msg.sender && status==false)
                   {
                      uint xid = pickindex(regdat[op_stage][i].num); 
                      _anftx.safeTransferFrom( address(this), register,xid );
                      regdat[op_stage][i].picked = true;
                      _removeNft(0);
                   }
                }
            }
        }

    } 

    function getPickupdNumber( address buyer ) public view returns (uint[] memory,uint[] memory,uint[] memory,uint[] memory) 
    {  

        uint[] memory tickets_stg0;
        uint[] memory tickets_stg1;
        uint[] memory tickets_stg2;
        uint[] memory tickets_stg3;

        uint op_stage;
        for(op_stage=0; op_stage<4; op_stage++) 
        {
            uint length = totalstoreNft(op_stage);
            uint i;
            uint count = 0;
            for(i=0; i<length; i++) 
            {   
                address register = regdat[op_stage][i].account;
                if( register == buyer)
                {
                    count = count + 1;
                }
            }
            if(op_stage==0)
                tickets_stg0 = new uint[](count);
            else if(op_stage==1)
                tickets_stg1 = new uint[](count); 
            else if(op_stage==2)
                 tickets_stg2 = new uint[](count);                    
            else if(op_stage==3)
                 tickets_stg3 = new uint[](count);  

            uint cnt=0;
            for(i=0; i<length; i++) 
            {  
                bool status = regdat[op_stage][i].picked;
                //uint xid = regdat[op_stage][i].num;
                address register = regdat[op_stage][i].account;
                if( register == buyer && status==true)
                {
                    uint xid = pickindex(regdat[op_stage][i].num);
                    if(op_stage==0)
                       tickets_stg0[cnt++] = xid;
                    else if(op_stage==1)
                       tickets_stg1[cnt++] = xid; 
                    else if(op_stage==2)
                       tickets_stg2[cnt++] = xid;                    
                    else if(op_stage==3)
                       tickets_stg3[cnt++] = xid;
                }
            }
        }
        return(tickets_stg0,tickets_stg1,tickets_stg2,tickets_stg3);
    }
    
    function getRegisteredNumber( address buyer ) public view returns (uint,uint,uint,uint) 
    {  

        uint  tickets_stg0 = 0;
        uint  tickets_stg1 = 0;
        uint  tickets_stg2 = 0;
        uint  tickets_stg3 = 0;

        uint op_stage;
        for(op_stage=0; op_stage<4; op_stage++) 
        {
            uint length = totalstoreNft(op_stage);
            uint i;
            /*
            uint count = 0;
            for(i=0; i<length; i++) 
            {   
                address register = regdat[op_stage][i].account;
                if( register == buyer)
                {
                    count = count + 1;
                }
            }
            
            if(op_stage==0)
                tickets_stg0 = new uint[](count);
            else if(op_stage==1)
                tickets_stg1 = new uint[](count); 
            else if(op_stage==2)
                 tickets_stg2 = new uint[](count);                    
            else if(op_stage==3)
                 tickets_stg3 = new uint[](count);  
            
            uint cnt=0;
            */
            for(i=0; i<length; i++) 
            {  
                //uint xid = regdat[op_stage][i].num;
                bool status = regdat[op_stage][i].picked;
                address register = regdat[op_stage][i].account;
                if( register == buyer && status==false)
                {
                    if(op_stage==0)
                       //tickets_stg0[cnt++] = xid;
                       tickets_stg0 = tickets_stg0 + 1;
                    else if(op_stage==1)
                       //tickets_stg1[cnt++] = xid; 
                        tickets_stg1 = tickets_stg1 + 1;
                    else if(op_stage==2)
                       //tickets_stg2[cnt++] = xid; 
                       tickets_stg2 = tickets_stg2 + 1;
                    else if(op_stage==3)
                       //tickets_stg3[cnt++] = xid;
                       tickets_stg3 = tickets_stg3 + 1;
                }
            }
        }
        return(tickets_stg0,tickets_stg1,tickets_stg2,tickets_stg3);
    }
}