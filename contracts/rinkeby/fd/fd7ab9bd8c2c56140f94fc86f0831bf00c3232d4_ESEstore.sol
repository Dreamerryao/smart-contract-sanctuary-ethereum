// SPDX-License-Identifier: MIT
pragma solidity >=0.8.7 <0.9.0;
import "./data.sol";
contract ESEstore is ERC721 ,  Ownable , ReentrancyGuard{ using Counters for Counters.Counter; using SafeMath for uint256; using Address for address; using Strings for uint256; mapping (uint256 => string) private _tokenURIs; string private _baseURIextended; uint256 public MaxSupply = 5555; uint256 private  _mintCost; event PriceChanged(uint256 New_mintCost); event SetESEstore(address eseStore); uint256 public totalSupply; address public eseStore; address private _proxyRegistryAddress; bool private _isPublicMintEnabled;
constructor(string memory name, string memory symbol, string memory baseURI, uint256  Cost, uint256  total) ERC721(name, symbol) {  _mintCost= Cost;_baseURIextended = baseURI; totalSupply = total -1; _isPublicMintEnabled = true;  for(uint256 i; i<total; i++){_mint(msg.sender,i);}}
function SetEseStore(address _eseStore) external onlyOwner { eseStore = _eseStore; emit SetESEstore(_eseStore); }function Allow_Mint() public onlyOwner{ _isPublicMintEnabled = true; }function Deny_Mint() public onlyOwner{ _isPublicMintEnabled = false; }
function ResetMaxSupply(uint256 max) public onlyOwner{MaxSupply = max;}event Set_ProxyRegistry(address proxy); modifier onlyOwnerOrStoryes() { require( eseStore == msg.sender || owner() == msg.sender, "caller is neither eseStore nor owner" ); _; }
function Set_proxyRegistry(address _proxy) external onlyOwner{_proxyRegistryAddress = _proxy; emit Set_ProxyRegistry(_proxy); }
function Store_Gift(address to) public  nonReentrant { require(_isPublicMintEnabled, "Mint disabled"); require(totalSupply < MaxSupply, "Exceeds max supply"); require( eseStore == msg.sender || owner() == msg.sender, "caller is neither eseStore nor owner" ); { totalSupply += 1; _safeMint(to, totalSupply);} }
function Iztegli() public onlyOwner { uint256 balance = address(this).balance; payable(msg.sender).transfer(balance); }
function Obnovi_BaseURI(string memory baseURI_) external onlyOwner() {  _baseURIextended = baseURI_; }
function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual { require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token"); _tokenURIs[tokenId] = _tokenURI; }
function _baseURI() internal view virtual override returns (string memory) { return _baseURIextended; }
function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), "Query for nonexistent token"); require(_isApprovedOrOwner(_msgSender(), tokenId) || owner() == msg.sender, "NTF: caller is not owner nor approved"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = _baseURI(); if (bytes(_tokenURI).length == 0) { return string(abi.encodePacked(base, tokenId.toString(), ".json")); } if (bytes(_tokenURI).length > 0) { return _tokenURI; } return string(abi.encodePacked(base, tokenId.toString())); }
function Suzdai_Nft( address _to, uint256 _tokenId, string memory tokenURI_ ) external onlyOwner() { require(_isPublicMintEnabled, "Mint disabled"); _mint(_to, _tokenId); _setTokenURI(_tokenId, tokenURI_); totalSupply += 1; }
function New_Nft_Url( uint256 _tokenId, string memory tokenURI_ ) external { require(_exists(_tokenId), "Operation query for nonexistent token"); require(_isApprovedOrOwner(_msgSender(), _tokenId) || owner() == msg.sender, "NTF: caller is not owner nor approved"); _setTokenURI(_tokenId, tokenURI_);}
function getCost() public view returns (uint256){return _mintCost;}function getMintStatus() public view returns (bool) {return _isPublicMintEnabled;} function setTokenPrice(uint _ether) external onlyOwner {emit PriceChanged(_ether);  _mintCost = _ether; }
function Bay_Nfts (address na, uint256 brojki) public payable nonReentrant{ require(_isPublicMintEnabled, "Mint disabled"); require(brojki > 0, "You can drop minimum 1 NFTs"); require(owner() == msg.sender || msg.value >= _mintCost * brojki, "ETH sent is not correct"); require(totalSupply < MaxSupply, "Exceeds max supply"); for(uint256 i; i<brojki; i++){ totalSupply += 1; _safeMint(na, totalSupply); } } }