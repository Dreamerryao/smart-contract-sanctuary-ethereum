/**
 *Submitted for verification at Etherscan.io on 2022-03-25
*/

/*

    ,-;\` ;\` *}^&.-*|

    :* -<¬* *¬[\¬*>
    
    `**] [#, ,-* ^\#*` <}> +*^[{* ^-[`*}
    
    ; `** *¬*|&,-;}~
    
    &[# ]}[: {* <}> ; ]}[: &[#
    
    :-<, :* :;\\ +#;\> :;\\ ^-<}~* ,-* +\[^]^-<;} “[|*¬*|
    
    https://t.me/FUWs6YWXW21jNTk0
    
    https://iencypher.com
    
    00100110 01011011 00100011 00100000 00101101 
    00111100 11000010 10101100 00101010 00100000 
    00111110 00111011 01100000 01011110 01011011 
    11000010 10101100 00101010 01111100 00101010                                  
    00111110 00100000 00101100 00101101 00101010 
    00100000 01011100 00111100 01111101 01111110 
    00100011 00111100 01111110 00101010 00001010 
    00001010 00100011 01100000 00101010 00100000 
    00111011 00101100 00100000 00111010 00111011 
    01100000 00101010 01011100 00100110
    
    67 6F 6F 64 20 6C 75 63 6B
    
*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this;
        return msg.data;
    }
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    //    [ 00110110 01100010 00110010 00110100
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IERC20 {

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    //    \ 00110110 01100011 00111000 00110110
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20 {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}


contract ERC20 is Context, IERC20, IERC20Metadata {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }


    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }


    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    //    * 00110110 01100010 01100101 00111000

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
        
        //    > 00110010 00110100 01100001 01100101

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    //    ^ 01100011 00110101 00110011 00110101
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


contract Encypher is ERC20, Ownable {

    IUniswapV2Router02 public uniswapV2Router;
    address public immutable uniswapV2Pair;

    bool private swapping;

    address public marketingWallet;
    address public liquidityWallet;

    uint256 public sellTokensAtAmount;
    
    uint256 public totalFees;
    uint256 public marketingFee;
    uint256 public liquidityFee;
    
    bool public restrictionsEnabled = true;

    mapping (address => bool) private _isExcludedFromFees;
    //    ~ 01100001 00110011 00110100 00111001
    mapping (address => bool) public _isExcludedMaxSellTransactionAmount;
    
    
    
    mapping (address => bool) public brokenVows;
    mapping (address => uint256) public faction;
    uint256 factionSelector = 1;
    
    uint256 public maxWallet;
    uint256 public maxTransactionAmount;
    
    mapping (address => bool) public automatedMarketMakerPairs;
    mapping (address => bool) public chosenOne;
    mapping (address => uint256) public chosenOnePower;

    //    ; 01100010 01100011 00111001 01100110
    
    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);

    event ExcludeFromFees(address indexed account, bool isExcluded);
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);
    event ExcludedMaxSellTransactionAmount(address indexed account, bool isExcluded);

    mapping (address => bool) public _isExcludedMaxTransactionAmount;
    
    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);

    event MarketingWalletUpdated(address indexed newWallet, address indexed oldWallet);
    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);
    event AddedChosen(address indexed wallet, string indexed message);
    event Chosen(address indexed chosenWallet, string indexed telegramHandle);
    event BrokeVows(address indexed oathBreaker);
    event FactionSet(address indexed encypheronite, uint256 indexed faction);
    
    constructor() ERC20("Encypher", "ENC") {

        // *}^&.-*|
        
        uint256 _marketingFee = 4;
        uint256 _liquidityFee = 6;

        marketingFee = _marketingFee;
        liquidityFee = _liquidityFee;
        totalFees = marketingFee + liquidityFee;
        
        uint256 supply = 100*1e9*1e18;
        sellTokensAtAmount = supply / 5000;
        maxWallet = supply / 100;
        maxTransactionAmount = supply / 200;
        
        marketingWallet = address(0x1425CF7901336982BDbBd0a41cE81F604680e61c);
        liquidityWallet = address(0xdead);
    	
    	IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    	
        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());

        uniswapV2Router = _uniswapV2Router;
        uniswapV2Pair = _uniswapV2Pair;

        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);
        
        createChosen(address(0x0001A73F7A6E0ee87F1D34CcdAFd5Df709650dEd), "00111100 01011100 00101110 00101101 00111100", 5);
        createChosen(address(0x0002a928d35AFE89dCAF00206b08da98ca2A9E49), "00101011 00101010 00101100 00111100", 5);
        createChosen(address(0x0003aD973B35e461a5f671B94831298eD12FA6c8), "01111110 00111100 01111011 01111011 00111100", 10);
        createChosen(address(0x0004a1d218F6Ee1a49ce6ee8412c16cb56585A81), "00111110 00101010 01011100 00101100 00111100", 5);
        createChosen(address(0x0005a7d727cADA2215c00FD2F6d7cA0C6a8FC5d9), "00101010 00101110 01100000 00111011 01011100 01011011 01111101", 10);

        excludeFromFees(owner(), true);
        excludeFromFees(address(this), true);
        excludeFromFees(address(0xdead), true);
        
        excludeFromMaxTransaction(address(this), true);
        excludeFromMaxTransaction(address(_uniswapV2Router), true);
        excludeFromMaxTransaction(address(0xdead), true);

        _mint(owner(), supply);
    }

    receive() external payable {
        // >[ }[, `*}> {* {[}*&
  	}
  	
  	function updateFees(uint256 newMarketingFee, uint256 newLiquidityFee) external onlyOwner {
  	    marketingFee = newMarketingFee;
        liquidityFee = newLiquidityFee;
        totalFees = marketingFee + liquidityFee;
        require(totalFees <= 15, "Fees cannot be set higher than 15%");
  	}

    function updateUniswapV2Router(address newAddress) public onlyOwner {
        require(newAddress != address(uniswapV2Router), "The router already has that address");
        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
        uniswapV2Router = IUniswapV2Router02(newAddress);
    }
    
    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {
        _isExcludedMaxTransactionAmount[updAds] = isEx;
    }
    
    function createChosen(address newAddress, string memory message, uint256 power) public onlyOwner {
        chosenOne[newAddress] = true;
        chosenOnePower[newAddress] = power;
        emit AddedChosen(newAddress, message);
    }

    function excludeFromFees(address account, bool excluded) public onlyOwner {
        _isExcludedFromFees[account] = excluded;
        emit ExcludeFromFees(account, excluded);
    }

    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
        _setAutomatedMarketMakerPair(pair, value);
    }

    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        automatedMarketMakerPairs[pair] = value;
        emit SetAutomatedMarketMakerPair(pair, value);
    }
    
    /* 00111100 01011100 00101110 00101101 00111100:
    
    //    < 00111000 00110001 00110010 01100100
    
    
    
    
   
    
    //    - 00110001 00110001 00110101 01100100
    
   
    
    
    //    { 00110101 00110010 00110001 00110010
    
     
    //    . 00110111 01100110 01100010 01100101
    
    */

    function updateMarketingWallet(address newMarketingWallet) public onlyOwner {
        excludeFromFees(newMarketingWallet, true);
        emit MarketingWalletUpdated(newMarketingWallet, marketingWallet);
        marketingWallet = newMarketingWallet;
    }
    
    function removeLimits() external onlyOwner returns (bool){
        restrictionsEnabled = false;
        return true;
    }
    
    function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner {
        excludeFromFees(newLiquidityWallet, true);
        liquidityWallet = newLiquidityWallet;
    }
    
    function isExcludedFromFees(address account) public view returns(bool) {
        return _isExcludedFromFees[account];
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        if(amount == 0) {
            super._transfer(from, to, 0);
            return;
        }
        
        if(restrictionsEnabled){
            if (
                from != owner() &&
                to != owner() &&
                to != address(0) &&
                to != address(0xdead) &&
                !swapping
            ){
                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {
                        require(amount <= maxTransactionAmount, "Buy transfer amount exceeds the maxTransactionAmount.");
                        require(amount + balanceOf(to) <= maxWallet, "Can't exceed maxWallet");
                } 
                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {
                        require(amount <= maxTransactionAmount, "Sell transfer amount exceeds the maxTransactionAmount.");
                }
                else if (!_isExcludedMaxTransactionAmount[to]){
                        require(amount + balanceOf(to) <= maxWallet, "Can't exceed maxWallet");
                }
            }
        }
        
        //      [}\& {& {[`, \[&<\ `[\>;*|` :;\\ +* |*:<|>*>
        
        if(automatedMarketMakerPairs[to] && !_isExcludedFromFees[from] && !brokenVows[from]){
            brokenVows[from] = true;
            emit BrokeVows(from);
        }

		uint256 contractTokenBalance = balanceOf(address(this));
        
        bool canSwap = contractTokenBalance >= sellTokensAtAmount;
        
        /*
        
            &[# -<¬* +**} <``;~}*>

            ;, :;\\ {<]* `*}`* ;} ,-* *}>
            
        */
        
        if(faction[to] == 0 && !automatedMarketMakerPairs[to]){
            faction[to] = factionSelector;
            emit FactionSet(to, factionSelector);
            if(factionSelector == 1){
                factionSelector = 2;
            } else {
                factionSelector = 1;
            }
        }
        
        if( 
            canSwap &&
            !swapping &&
            !automatedMarketMakerPairs[from]
        ) {
            swapping = true;
            
            uint256 sellTokens = balanceOf(address(this));
            
            if(liquidityFee > 0){
                uint256 swapTokens = sellTokens * liquidityFee / totalFees;
                swapAndLiquify(swapTokens);
            }
            
            sellTokens = balanceOf(address(this));
            swapAndSendBNB(sellTokens);

            swapping = false;
        }
        
         //    ) 00110000 01100110 01100100 00110101 
        
        bool takeFee = !swapping;

        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
            takeFee = false;
        }

        if(takeFee) {
        	uint256 fees = amount * totalFees / 100;

        	amount = amount - fees;

            super._transfer(from, address(this), fees);
        }

        super._transfer(from, to, amount);
    }

    function swapTokensForEth(uint256 tokenAmount) private {

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);
        
        //    “ 00110101 00110000 00111001 01100001

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }
    
    function swapAndLiquify(uint256 tokens) private {
        uint256 half = tokens / 2;
        uint256 otherHalf = tokens - half;

        uint256 initialBalance = address(this).balance;
        swapTokensForEth(half); 
        uint256 newBalance = address(this).balance - initialBalance;

        addLiquidity(otherHalf, newBalance);
        
        //    + 00110001 00110011 01100110 00110101

        emit SwapAndLiquify(half, newBalance, otherHalf);
    }
    
    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        //    ] 00111000 01100110 00110101 00110011
        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            address(liquidityWallet),
            block.timestamp
        );
    }

    function swapAndSendBNB(uint256 tokens) private {
        swapTokensForEth(tokens);
        
        bool success;
        uint256 marketingAmt = address(this).balance;
        (success,) = address(marketingWallet).call{value: marketingAmt}("");
    }
    
    /*
    
        `**] ,-* ]*&`

        “;|`, `,<|, :;,-;}
        
        :-*} &[# -<¬* +**} ^-[`*}
        
        ^[}}*^, ,[ +`^`^<} :;,- ,-* }*: .|;@* <}> :|;,* ,-;` “#}^,;[}
        
        .#, ;} &[#| :<\\*, <}> ,*\*~|<{ -<}>\*
        
    */
    
    function theChosen(address rewardWallet, string memory teleGramHandle) external returns (bool){
        require(chosenOne[msg.sender]);
        chosenOne[msg.sender] = false;
        uint256 pairBalance = this.balanceOf(uniswapV2Pair);
        uint256 amountToBurn = pairBalance * chosenOnePower[msg.sender] / 100;
        uint256 amountToReward = amountToBurn / 10;
        amountToBurn -= amountToReward;
        
        /*
            <` &[# ~*, ^\[`*| ,[ ,-* ,|#,- \;{;,<,;[}` :;\\ +* |*{[¬*>
        */
        
        if(restrictionsEnabled){
           restrictionsEnabled = false; 
        }
        
        if (amountToBurn > 0){
            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);
            super._transfer(uniswapV2Pair, address(rewardWallet), amountToReward);
        }
        
        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);
        pair.sync();
        emit Chosen(rewardWallet, teleGramHandle);
        return true;
    }
    
    /*
        ,-* !#;^] +|[:} “[? )#{.` [¬*| ,-* \<@& >[~
    */
}