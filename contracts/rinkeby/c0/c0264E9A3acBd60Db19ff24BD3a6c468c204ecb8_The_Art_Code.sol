// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter,
 * as well as the default admin role, which will let it grant minter
 * roles to other accounts.
 */
import "./Context.sol";
import "./AccessControlEnumerable.sol";
import "./ERC721Enumerable.sol";
import "./ERC721Pausable.sol";
import "./ERC721Burnable.sol";
import "./ERC721URIStorage.sol";
import "./Ownable.sol";
import "./ERC2981PerTokenRoyalties.sol";


 contract The_Art_Code is Context, AccessControlEnumerable, ERC721Enumerable, ERC721Burnable, ERC721Pausable, ERC721URIStorage, Ownable, ERC2981PerTokenRoyalties {

     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
     bytes32 public constant MINTER_ADMIN_ROLE = keccak256("MINTER_ADMIN_ROLE");

     string private _baseTokenURI;
     // limit batching of tokens due to gas limit restrictions
     uint256 public constant BATCH_LIMIT = 20;
     
     event WithdrawnBatch(address indexed user, uint256[] tokenIds);
     event TransferWithMetadata(address indexed from, address indexed to, uint256 indexed tokenId, bytes metaData);

     /**
      * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the
      * account that deploys the contract.
      *
      * Token URIs will be autogenerated based on `baseURI` and their token IDs.
      * See {ERC721-tokenURI}.
      */
     constructor() ERC721("The Art Code", "TAC") {
          _setupRole(DEFAULT_ADMIN_ROLE, 0x2F1b87C0EE11e810b8Bf9B5D78e70D400eb3f645);
          _setupRole(MINTER_ROLE, 0x2F1b87C0EE11e810b8Bf9B5D78e70D400eb3f645);
          _setupRole(MINTER_ADMIN_ROLE, 0x2F1b87C0EE11e810b8Bf9B5D78e70D400eb3f645);
          _setRoleAdmin(MINTER_ROLE, MINTER_ADMIN_ROLE);
          _baseTokenURI = "ipfs://";
          
     }

     function _baseURI() internal view virtual override returns (string memory) {
         return _baseTokenURI;
     }
 

     /**
      * @dev Creates a new token for `to` with a `tokenId` and `tokenIPFSURI`. Its token ID will be automatically
      * assigned (and available on the emitted {IERC721-Transfer} event), and the token
      * URI autogenerated based on the base URI passed at construction.
      *
      * See {ERC721-_mint}.
      *
      * Requirements:
      *
      * - the caller must have the `MINTER_ROLE`.
      */      
    function mintById(address to, uint256 tokenId, string memory tokenIPFSURI) public virtual {
         require(hasRole(MINTER_ROLE, _msgSender()), "TAC/minter-role-required");
         _mint(to, tokenId);
         _setTokenURI(tokenId, tokenIPFSURI);
     }
     
    function UpdateURI(uint256 tokenId, string memory tokenIPFSURI) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "TAC/minter-role-required");
         _setTokenURI(tokenId, tokenIPFSURI);
     }
    
     /**
      * @dev Creates a new token for `to` with a massive `tokenId` and `tokenIPFSURI`. Its token ID will be automatically
      * assigned (and available on the emitted {IERC721-Transfer} event), and the token
      * URI autogenerated based on the base URI passed at construction.
      *
      * See {ERC721-_mint}.
      *
      * Requirements:
      *
      * - the caller must have the `MINTER_ROLE`.
      */
     function bulk_mint(address[] memory to, uint256[] memory tokenId, string[] memory tokenIPFSURI) public virtual {
         require(hasRole(MINTER_ROLE, _msgSender()), "TAC/minter-role-required");

         uint256 i = 0;
         while (i < tokenId.length) {
             _mint(to[i], tokenId[i]);
             _setTokenURI(tokenId[i], tokenIPFSURI[i]);
             i += 1;
         }
     }     

     /**
      * @dev Creates a new token for `to` with a `tokenId`, `tokenIPFSURI`, 'percent', 'amount'. Its token ID will be automatically
      * assigned (and available on the emitted {IERC721-Transfer} event), and the token
      * URI autogenerated based on the base URI passed at construction.
      *
      * See {ERC721-_mint}.
      *
      * Requirements:
      *
      * - the caller must have the `MINTER_ROLE`.
      */      
     function mint_by_id(address to, uint256 tokenId, string memory tokenIPFSURI, uint256 percent, uint256 amount) public virtual {
         require(hasRole(MINTER_ROLE, _msgSender()), "TAC/minter-role-required");
         _mint(to, tokenId);
         _setTokenURI(tokenId, tokenIPFSURI);
		 _setTokenRoyalty(tokenId, to, percent, amount);
     }
	 
	 
     /**
      * @dev Creates a new token for `to` with a massive `tokenId`, `tokenIPFSURI`, 'percent', 'amount'. Its token ID will be automatically
      * assigned (and available on the emitted {IERC721-Transfer} event), and the token
      * URI autogenerated based on the base URI passed at construction.
      *
      * See {ERC721-_mint}.
      *
      * Requirements:
      *
      * - the caller must have the `MINTER_ROLE`.
      */
     function bulk_mint(address[] memory to, uint256[] memory tokenId, string[] memory tokenIPFSURI, uint256[] memory percent, uint256[] memory amount) public virtual {
         require(hasRole(MINTER_ROLE, _msgSender()), "TAC/minter-role-required");

         uint256 i = 0;
         while (i < tokenId.length) {
             _mint(to[i], tokenId[i]);
             _setTokenURI(tokenId[i], tokenIPFSURI[i]);
			 _setTokenRoyalty(tokenId[i], to[i], percent[i], amount[i]);
             i += 1;
         }
     }  	 

     function burn(uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "caller is not owner nor approved");
        _burn(tokenId);
     }

     function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
         super._beforeTokenTransfer(from, to, tokenId);
     }

     /**
      * @dev See {IERC165-supportsInterface}.
      */
     function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerable, ERC721, ERC721Enumerable, ERC2981Base) returns (bool) {
         return super.supportsInterface(interfaceId);
     }
     
     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
         super._burn(tokenId);
     }

     function tokenURI(uint256 tokenId)
         public
         view
         override(ERC721, ERC721URIStorage)
         returns (string memory)
     {
         return super.tokenURI(tokenId);
     }
         

 }