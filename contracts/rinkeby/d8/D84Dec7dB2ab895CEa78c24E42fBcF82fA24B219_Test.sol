/**
 *Submitted for verification at Etherscan.io on 2022-01-07
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library MathLib {

    // Table index into the trigonometric table
    uint constant INDEX_WIDTH = 4;
    // Interpolation between successive entries in the tables
    uint constant INTERP_WIDTH = 8;
    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;
    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
    uint16 constant ANGLES_IN_CYCLE = 16384;
    uint16 constant QUADRANT_HIGH_MASK = 8192;
    uint16 constant QUADRANT_LOW_MASK = 4096;
    uint constant SINE_TABLE_SIZE = 16;
    uint8 constant RATIO_MIN_VALUE = 2;

    // constant sine lookup table generated by gen_tables.py
    // We have no other choice but this since constant arrays don't yet exist
    uint8 constant entry_bytes = 2;
    bytes constant sin_table = "\x00\x00\x0c\x8c\x18\xf9\x25\x28\x30\xfb\x3c\x56\x47\x1c\x51\x33\x5a\x82\x62\xf1\x6a\x6d\x70\xe2\x76\x41\x7a\x7c\x7d\x89\x7f\x61\x7f\xff";

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @param _width The width of the bits (in bits) we want to extract
     * @param _offset The offset of the bits (in bits) we want to extract
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function bits(uint _value, uint _width, uint _offset) internal pure returns (uint) {
        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);
    }

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function log_2(uint256 _value) internal pure returns (uint8) {
        uint8 log2_res = 0;
        if (_value < 256) {
            while (_value > 1) {
                _value >>= 1;
                log2_res += 1;
            }
        } else {
            for (uint8 s = 128; s > 0; s >>= 1) {
                if (_value >= (1 << s)) {
                    _value >>= s;
                    log2_res |= s;
                }
            }
        }

        return log2_res;
    }

    function sin_table_lookup(uint index) internal pure returns (uint16) {
        bytes memory table = sin_table;
        uint offset = (index + 1) * entry_bytes;
        uint16 trigint_value;
        assembly {
            trigint_value := mload(add(table, offset))
        }

        return trigint_value;
    }

    function sqrt(uint256 y) internal pure returns (uint256) {
      uint256 result;
      if (y > 3) {
          result = y;
          uint256 x = y / 2 + 1;
          while (x < result) {
              result = x;
              x = (y / x + x) / 2;
          }
      } else if (y != 0) {
          result = 1;
      }

      return result;
    }

    function abs(int256 x) internal pure returns (int256) {
        return x < 0 ? x*(-1) : x;
    }

    /**
     * Return the sine of an integer approximated angle as a signed 16-bit
     * integer.
     *
     * @param param A 14-bit angle. This divides the circle into 16384
     *               angle units, instead of the standard 360 degrees.
     * @return The sine result as a number in the range -32767 to 32767.
     */
    function sin(uint param) internal pure returns (int) {
        uint _angle = param % 16384;
        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);
        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);

        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;
        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

        if (!is_odd_quadrant) {
            index = SINE_TABLE_SIZE - 1 - index;
        }

        uint x1 = sin_table_lookup(index);
        uint x2 = sin_table_lookup(index + 1);
        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);

        int sine;
        if (is_odd_quadrant) {
            sine = int(x1) + int(approximation);
        } else {
            sine = int(x2) - int(approximation);
        }

        if (is_negative_quadrant) {
            sine *= -1;
        }

        return sine;
    }

    /**
     * Return the cos of an integer approximated angle.
     * It functions just like the sin() method but uses the trigonometric
     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
     */
    function cos(uint param) internal pure returns (int) {
        uint _angle = param % 16384;
        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {
            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;
        } else {
            _angle += QUADRANT_LOW_MASK;
        }
        return sin(_angle);
    }

    /**
     * Return the angle of an integer approximated ratio as a signed 256-bit
     * integer.
     *
     * @param _ratio A 256-bit(unit 1) ratio as a number in the range 0 to infinite.
     * @return The arctan result is A 256-bit angle. This divides the circle into 4 * 340282366920938463463374607431768211455 (2^256)
     *               angle units, instead of the standard 360 degrees.                785118600829010179644344535919513282844767027200
     */
    function arctan(uint256 _ratio) internal pure returns (uint256) {
        uint128[256] memory arctan_table = [
            0x1,
            0x2,
            0x5,
            0xa,
            0x14,
            0x28,
            0x51,
            0xa2,
            0x145,
            0x28b,
            0x517,
            0xa2f,
            0x145f,
            0x28be,
            0x517c,
            0xa2f9,
            0x145f3,
            0x28be6,
            0x517cc,
            0xa2f98,
            0x145f30,
            0x28be60,
            0x517cc1,
            0xa2f983,
            0x145f306,
            0x28be60d,
            0x517cc1b,
            0xa2f9836,
            0x145f306d,
            0x28be60db,
            0x517cc1b7,
            0xa2f9836e,
            0x145f306dc,
            0x28be60db9,
            0x517cc1b72,
            0xa2f9836e4,
            0x145f306dc9,
            0x28be60db93,
            0x517cc1b727,
            0xa2f9836e4e,
            0x145f306dc9c,
            0x28be60db939,
            0x517cc1b7272,
            0xa2f9836e4e4,
            0x145f306dc9c8,
            0x28be60db9391,
            0x517cc1b72722,
            0xa2f9836e4e44,
            0x145f306dc9c88,
            0x28be60db93910,
            0x517cc1b727220,
            0xa2f9836e4e441,
            0x145f306dc9c882,
            0x28be60db939105,
            0x517cc1b727220a,
            0xa2f9836e4e4415,
            0x145f306dc9c882a,
            0x28be60db9391054,
            0x517cc1b727220a9,
            0xa2f9836e4e44152,
            0x145f306dc9c882a5,
            0x28be60db9391054a,
            0x517cc1b727220a94,
            0xa2f9836e4e441529,
            0x145f306dc9c882a53,
            0x28be60db9391054a7,
            0x517cc1b727220a94f,
            0xa2f9836e4e441529f,
            0x145f306dc9c882a53f,
            0x28be60db9391054a7f,
            0x517cc1b727220a94fe,
            0xa2f9836e4e441529fc,
            0x145f306dc9c882a53f8,
            0x28be60db9391054a7f0,
            0x517cc1b727220a94fe1,
            0xa2f9836e4e441529fc2,
            0x145f306dc9c882a53f84,
            0x28be60db9391054a7f09,
            0x517cc1b727220a94fe13,
            0xa2f9836e4e441529fc27,
            0x145f306dc9c882a53f84e,
            0x28be60db9391054a7f09d,
            0x517cc1b727220a94fe13a,
            0xa2f9836e4e441529fc275,
            0x145f306dc9c882a53f84ea,
            0x28be60db9391054a7f09d5,
            0x517cc1b727220a94fe13a5,
            0xa2f9836e4e441529fc2721,
            0x145f306dc9c882a53f84cfd,
            0x28be60db9391054a7f08fca,
            0x517cc1b727220a94fe0ce18,
            0xa2f9836e4e441529fbf104a,
            0x145f306dc9c882a53f69c164,
            0x28be60db9391054a7e308945,
            0x517cc1b727220a94f749466f,
            0xa2f9836e4e441529c5d42c02,
            0x145f306dc9c882a5245b55128,
            0x28be60db93910549a5bd26b6b,
            0x517cc1b727220a8e33ae31fb0,
            0xa2f9836e4e4414f3a8fb88628,
            0x145f306dc9c8828a15ef034288,
            0x28be60db93910471325a9836cd,
            0x517cc1b7272203ca9899bdfb7a,
            0xa2f9836e4e43ded6d057e8660e,
            0x145f306dc9c8677ba99d33447c5,
            0x28be60db93902bfdcfcc184c872,
            0x517cc1b7271b402f8425bf6cdb4,
            0xa2f9836e4e0dc1fe2cb80c6334b,
            0x145f306dc9ad590f57cd762752a0,
            0x28be60db92b7b89b41544beba46f,
            0x517cc1b72057a51b112aed731e45,
            0xa2f9836e17f0e95aad539e405542,
            0x145f306dae9eecbdc8ff826b71243,
            0x28be60daba445614e76d187ce4f82,
            0x517cc1b05cbc91abd2fe7f4921e75,
            0xa2f98337fb186652dd8577a994773,
            0x145f3052a032dc1e23c00e5d9aaf49,
            0x28be600246e9ed9fd0ea488467200a,
            0x517cbaecc2acdee4d07cb50e3ba109,
            0xa2f94d1b430cdbf245e9bac7b0f2ad,
            0x145f15447510aba8b0c1b2b7aaa6c7a,
            0x28bd87970a098a6135afd62d2d16923,
            0x5175f85641189e15a72537a0b6bdce8,
            0xa2c350c39626bb303300048a6da76f3,
            0x144447507776686dfe49572c7c78a5a9,
            0x27ece16d7b8e7a377d0fcf2824878347,
            0x4b90147677cc21995a23db6b8d4656bf,
            0x80000000000000000000000000000000,
            0xb46feb898833de66a5dc249472b9a940,
            0xd8131e92847185c882f030d7db787cb8,
            0xebbbb8af8889979201b6a8d383875a56,
            0xf5d3caf3c69d944cfccfffb75925890c,
            0xfae8a07a9bee761ea58dac85f4942317,
            0xfd7427868f5f6759eca5029d2d2e96dc,
            0xfeba0eabb8aef54574f3e4d485559385,
            0xff5d06b2e4bcf3240dba1645384f0d52,
            0xffae8345133d53211b2f834af1c45ef6,
            0xffd7419ffdb91612602f15b77b98dff5,
            0xffeba0cfad5fcd23e1dc3ff1a26550b6,
            0xfff5d067cc804e799ad227a88566b88c,
            0xfffae833e4fa3436e542d0180b6de18a,
            0xfffd7419f2545bba9eb1892e7831b07d,
            0xfffeba0cf925161134237007d948edbc,
            0xffff5d067c91e80f16a552ac61bfaabd,
            0xffffae833e48dfa85ae4eed5128ce1ba,
            0xffffd7419f246d484764beabb4145b90,
            0xffffeba0cf923652a6f0a83289d8ad5f,
            0xfffff5d067c91b1f23e01d347f39ccb4,
            0xfffffae833e48d8e4bfd07bda409324b,
            0xfffffd7419f246c6fd4023033e7b378d,
            0xfffffeba0cf92363798845662ccbb83a,
            0xffffff5d067c91b1bc21292fa81799f1,
            0xffffffae833e48d8ddfc356766420485,
            0xffffffd7419f246c6efb8ecda567c932,
            0xffffffeba0cf9236377d75ea10fcbd77,
            0xfffffff5d067c91b1bbeb0c5704779d7,
            0xfffffffae833e48d8ddf571cc51ce04f,
            0xfffffffd7419f246c6efab65a42d9494,
            0xfffffffeba0cf9236377d5adba4aaed7,
            0xffffffff5d067c91b1bbead63a2bd3fd,
            0xffffffffae833e48d8ddf56b08b6b990,
            0xffffffffd7419f246c6efab581cf76ba,
            0xffffffffeba0cf9236377d5ac0963e9b,
            0xfffffffff5d067c91b1bbead6040efb5,
            0xfffffffffae833e48d8ddf56b01f31e7,
            0xfffffffffd7419f246c6efab580f7035,
            0xfffffffffeba0cf9236377d5ac07b302,
            0xffffffffff5d067c91b1bbead603d8de,
            0xffffffffffae833e48d8ddf56b01ec5a,
            0xffffffffffd7419f246c6efab580f62a,
            0xffffffffffeba0cf9236377d5ac07b15,
            0xfffffffffff5d067c91b1bbead603d8a,
            0xfffffffffffae833e48d8ddf56b01ec5,
            0xfffffffffffd7419f246c6efab580f62,
            0xfffffffffffeba0cf9236377d5ac07b1,
            0xffffffffffff5d067c91b1bbead603d8,
            0xffffffffffffae833e48d8ddf56b01ec,
            0xffffffffffffd7419f246c6efab580f6,
            0xffffffffffffeba0cf9236377d5ac07b,
            0xfffffffffffff5d067c91b1bbead603d,
            0xfffffffffffffae833e48d8ddf56b01e,
            0xfffffffffffffd7419f246c6efab580f,
            0xfffffffffffffeba0cf9236377d5ac07,
            0xffffffffffffff5d067c91b1bbead603,
            0xffffffffffffffae833e48d8ddf56b01,
            0xffffffffffffffd7419f246c6efab580,
            0xffffffffffffffeba0cf9236377d5ac0,
            0xfffffffffffffff5d067c91b1bbead60,
            0xfffffffffffffffae833e48d8ddf56b0,
            0xfffffffffffffffd7419f246c6efab58,
            0xfffffffffffffffeba0cf9236377d5ac,
            0xffffffffffffffff5d067c91b1bbead6,
            0xffffffffffffffffae833e48d8ddf56b,
            0xffffffffffffffffd7419f246c6efab5,
            0xffffffffffffffffeba0cf9236377d5a,
            0xfffffffffffffffff5d067c91b1bbead,
            0xfffffffffffffffffae833e48d8ddf56,
            0xfffffffffffffffffd7419f246c6efab,
            0xfffffffffffffffffeba0cf9236377d5,
            0xffffffffffffffffff5d067c91b1bbea,
            0xffffffffffffffffffae833e48d8ddf5,
            0xffffffffffffffffffd7419f246c6efa,
            0xffffffffffffffffffeba0cf9236377d,
            0xfffffffffffffffffff5d067c91b1bbe,
            0xfffffffffffffffffffae833e48d8ddf,
            0xfffffffffffffffffffd7419f246c6ef,
            0xfffffffffffffffffffeba0cf9236377,
            0xffffffffffffffffffff5d067c91b1bb,
            0xffffffffffffffffffffae833e48d8dd,
            0xffffffffffffffffffffd7419f246c6e,
            0xffffffffffffffffffffeba0cf923637,
            0xfffffffffffffffffffff5d067c91b1b,
            0xfffffffffffffffffffffae833e48d8d,
            0xfffffffffffffffffffffd7419f246c6,
            0xfffffffffffffffffffffeba0cf92363,
            0xffffffffffffffffffffff5d067c91b1,
            0xffffffffffffffffffffffae833e48d8,
            0xffffffffffffffffffffffd7419f246c,
            0xffffffffffffffffffffffeba0cf9236,
            0xfffffffffffffffffffffff5d067c91b,
            0xfffffffffffffffffffffffae833e48d,
            0xfffffffffffffffffffffffd7419f246,
            0xfffffffffffffffffffffffeba0cf923,
            0xffffffffffffffffffffffff5d067c91,
            0xffffffffffffffffffffffffae833e48,
            0xffffffffffffffffffffffffd7419f24,
            0xffffffffffffffffffffffffeba0cf92,
            0xfffffffffffffffffffffffff5d067c9,
            0xfffffffffffffffffffffffffae833e4,
            0xfffffffffffffffffffffffffd7419f2,
            0xfffffffffffffffffffffffffeba0cf9,
            0xffffffffffffffffffffffffff5d067c,
            0xffffffffffffffffffffffffffae833e,
            0xffffffffffffffffffffffffffd7419f,
            0xffffffffffffffffffffffffffeba0cf,
            0xfffffffffffffffffffffffffff5d067,
            0xfffffffffffffffffffffffffffae833,
            0xfffffffffffffffffffffffffffd7419,
            0xfffffffffffffffffffffffffffeba0c,
            0xffffffffffffffffffffffffffff5d06,
            0xffffffffffffffffffffffffffffae83,
            0xffffffffffffffffffffffffffffd741,
            0xffffffffffffffffffffffffffffeba0,
            0xfffffffffffffffffffffffffffff5d0,
            0xfffffffffffffffffffffffffffffae8,
            0xfffffffffffffffffffffffffffffd74,
            0xfffffffffffffffffffffffffffffeba,
            0xffffffffffffffffffffffffffffff5d,
            0xffffffffffffffffffffffffffffffae,
            0xffffffffffffffffffffffffffffffd7,
            0xffffffffffffffffffffffffffffffeb,
            0xfffffffffffffffffffffffffffffff5,
            0xfffffffffffffffffffffffffffffffa,
            0xfffffffffffffffffffffffffffffffd,
            0xfffffffffffffffffffffffffffffffe,
            0xffffffffffffffffffffffffffffffff
        ];

        if (_ratio < RATIO_MIN_VALUE) 
            return 0;
        uint8 bit = log_2(_ratio);
        uint256 base = 1 << bit;
        uint256 x1 = arctan_table[bit];
        uint256 x2 = arctan_table[bit - 1];
        return ((x1 - x2) * (_ratio - base)) / base + x2;
    }

}

struct Orbit2D {
    int256 a;
    int256 e;
    int256 M;
    int256 T;
    int256 n;
}

struct Orbit3D {
    int256 a;
    int256 e;
    int256 M;
    int256 T;
    int256 Omega;
    int256 omega;
    int256 I;
    int256[3][3] Euler_angle_transformation_matrix;
    Orbit2D orbit2d;
}

pragma solidity ^0.8.0;

library Orbit2DFuns {
    uint8 constant Decimals = 8;
    int256 constant PI = 314159265;

    /**
     * Sets the mean angular velocity (n) for the class
     * Needs to be run every time the period (T) is set or updated
     */
    function _update_n( Orbit2D storage self ) internal {
        self.n = 2 * PI / self.T;
    }

    /**
     * To be used for changes in orbital parameters, e.g. perihelion shift
     */
    function update( Orbit2D storage self, string memory key, int256 value ) internal {
        if (keccak256(bytes(key)) == keccak256(bytes('a')))
            self.a = value;
        if (keccak256(bytes(key)) == keccak256(bytes('e')))
            self.e = value;
        if (keccak256(bytes(key)) == keccak256(bytes('M')))
            self.M = value;
        if (keccak256(bytes(key)) == keccak256(bytes('T'))) {
            self.T = value;
            self.n = 2 * PI / value;
        }
    }

    /**
     * Arguments: t [sec] - relative time from point zero (default J2000 epoch) 
     * Returns: radius [AU] and true anomaly [rad]
     */
    function get_rv( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {
        int256 M = t * 2 * 10**8 * PI / self.T  + self.M;  // actual mean anomaly
        int256 E;                         // actual eccentric anomaly
        int256 temp;                      // Temporary memory for deep computations

        // condition to check if fsolve is success.
        // fsolve_cond = (np.pi-2/E0) * (np.pi-2/E0) - 4*(np.pi*np.pi/4 - 2 - 2*M0/E0) : Python format
        int256 fsolve_cond = (PI- int(10**Decimals) * 2*int(10**Decimals)/self.e);
        fsolve_cond = fsolve_cond * fsolve_cond;
        temp = int(10**Decimals) * 2*int(10**Decimals)/self.e;
        temp = temp * M;
        temp = 4*(PI*PI/4 - int(10**Decimals) * 2*int(10**Decimals) - temp );
        fsolve_cond = fsolve_cond - temp;

        if(fsolve_cond > 0) {
            int256 E0 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/self.e) + int(MathLib.sqrt(uint(fsolve_cond))))/2;
            int256 E1 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/self.e) - int(MathLib.sqrt(uint(fsolve_cond))))/2;
            int256 E0_offset = E0-self.e*MathLib.sin(uint(8192*E0/PI))/32767;
            int256 E1_offset = E1-self.e*MathLib.sin(uint(8192*E1/PI))/32767;
            E = MathLib.abs(E0_offset) < MathLib.abs(E1_offset) ? E0:E1;
            
            // Radius (distance from baricenter) => r = self.a * ( 1.0 - self.e * np.cos( E ) ) : Python format
            int256 r = self.a * ( int(10**Decimals) - self.e * MathLib.cos(uint(8192*E/PI))/32767 ) / (int(10**Decimals));   
            // True anomaly => v = 2.0 * np.arctan( np.sqrt( ( 1.0 + self.e ) / ( 1.0 - self.e ) ) * np.tan( E / 2.0 ) ) : Python format                            // radius (distance from baricenter)
            temp = int(MathLib.sqrt(uint( int(10**Decimals) * int(10**Decimals) * (int(10**Decimals) + self.e )/( int(10**Decimals) - self.e ))));
            int256 ratio = temp * MathLib.sin(uint(4096*E/PI)) /  MathLib.cos(uint(4096*E/PI));
            ratio = ratio * int(2**128) /int(10**Decimals);
            temp = ratio < 0 ? int(MathLib.arctan(uint(ratio*(-1))))*(-1): int(MathLib.arctan(uint(ratio)));
            int256 v = (PI/2) * int(2*10**Decimals) * temp / int(2**128 * 10**Decimals );  // true anomaly
            return(r, v);
        } else {
          // fsolve is false.
          return(0, 0);
        }
    }


    /**
     * Same as get_rv() but returns the objects position in cartesian coordinates 
     * Returns: x, y [AU] - x-axis is in the direction of pericenter, y-axis is right-hand perpendicular
     */
    function get_xy( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {
        int256 r; 
        int256 v;
        (r, v) = get_rv(self, t);

        int256 x = r * MathLib.cos(uint(8192*v/PI))/32767;
        int256 y = r * MathLib.sin(uint(8192*v/PI))/32767;

        return(x, y);

    }

}

pragma solidity ^0.8.0;

library Orbit3DFuns {

    uint8 constant Decimals = 8;
    int256 constant PI = 314159265;

    function _update_Euler_angle_transformation_matrix( Orbit3D storage self) internal {
        int256 cosO = int(10**Decimals) * MathLib.cos(uint(8192*self.Omega/PI))/32767;
        int256 sinO = int(10**Decimals) * MathLib.sin(uint(8192*self.Omega/PI))/32767;

        int256 cosI = int(10**Decimals) * MathLib.cos(uint(8192*self.I/PI))/32767;
        int256 sinI = int(10**Decimals) * MathLib.sin(uint(8192*self.I/PI))/32767;

        int256 coso = int(10**Decimals) * MathLib.cos(uint(8192*self.omega/PI))/32767;
        int256 sino = int(10**Decimals) * MathLib.sin(uint(8192*self.omega/PI))/32767;

        self.Euler_angle_transformation_matrix[0][0] = (int(10**Decimals)*cosO*coso- sinO*sino*cosI)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[0][1] = (-int(10**Decimals)*cosO*sino- sinO*coso*cosI)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[0][2] = sinO*sinI/int(10**Decimals);
        self.Euler_angle_transformation_matrix[1][0] = (int(10**Decimals)*sinO*coso + cosO*cosI*sino)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[1][1] = (cosO*coso*cosI -int(10**Decimals)*sinO*sino)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[1][2] = -cosO*sinI/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][0] = sinI*sino/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][1] = sinI*coso/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][2] = cosI;
    }

    /**
     * Updates class parameters
     * To be used for changes in orbital parameters, e.g. perihelion shift
     */
    function update( Orbit3D storage self, string memory key, int256 value ) internal {
        if (keccak256(bytes(key)) == keccak256(bytes('a')))
            self.a = value;
        if (keccak256(bytes(key)) == keccak256(bytes('e')))
            self.e = value;
        if (keccak256(bytes(key)) == keccak256(bytes('M')))
            self.M = value;
        if (keccak256(bytes(key)) == keccak256(bytes('T'))) 
            self.T = value;
        if (keccak256(bytes(key)) == keccak256(bytes('Omega'))) {
            self.Omega = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        if (keccak256(bytes(key)) == keccak256(bytes('omega'))) {
            self.omega = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        if (keccak256(bytes(key)) == keccak256(bytes('I'))) {
            self.I = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        
        Orbit2DFuns.update(self.orbit2d, key, value);
    }

    /**
     * Argument: t [sec] - time since time zero [default to J2000 epoch]
     * Returns: objects possition x, y, z in [AU] - x is directed at vernal equinox; y,z are right-handed ortogonal
     */
    function get_xyz( Orbit3D storage self, int256 t) internal view returns (int256, int256, int256) {
        int256 p_2d_x;
        int256 p_2d_y;
        (p_2d_x, p_2d_y) = Orbit2DFuns.get_xy(self.orbit2d, t);

        int256 x = (self.Euler_angle_transformation_matrix[0][0] * p_2d_x + self.Euler_angle_transformation_matrix[0][1] * p_2d_y)/int(10**Decimals);
        int256 y = (self.Euler_angle_transformation_matrix[1][0] * p_2d_x + self.Euler_angle_transformation_matrix[1][1] * p_2d_y)/int(10**Decimals);
        int256 z = (self.Euler_angle_transformation_matrix[2][0] * p_2d_x + self.Euler_angle_transformation_matrix[2][1] * p_2d_y)/int(10**Decimals);

        return(x, y, z);

    }

}


pragma solidity ^0.8.0;

contract Test {

    using Orbit2DFuns for Orbit2D;
    using Orbit3DFuns for Orbit3D;
    int256[3][3] public matrix;
    

    Orbit2D orbit2d =  Orbit2D({a:38709893, e:20563069, M: 305073760, T:760065407544000, n:0});
    Orbit3D orbit3d =  Orbit3D({a:38709893, e:20563069, M: 305073760, T:760065407544000, I:12225804, Omega:84354677, omega:50832330, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
    
    function test_get_rv(int256 t) public view returns (int256, int256) {
        int256 res_r;
        int256 res_v;
        (res_r, res_v) = orbit2d.get_rv(t);
        return (res_r, res_v);
    }

    function test_get_xy(int256 t) public view returns (int256, int256) {
        int256 res_x;
        int256 res_y;
        (res_x, res_y) = orbit2d.get_xy(t);
        return (res_x, res_y);
    }

    function test_orbit_3d() public {
        orbit3d._update_Euler_angle_transformation_matrix();
    }

    function read_orbit3d_xyz(int256 t) public view returns (int256, int256, int256) {
        int256 res_x;
        int256 res_y;
        int256 res_z;
        (res_x, res_y, res_z) = orbit3d.get_xyz(t);
        return (res_x, res_y, res_z);
    }

    function read_orbit3d_matrix() public view returns (int256[3][3] memory) {
        return orbit3d.Euler_angle_transformation_matrix;
    }

}