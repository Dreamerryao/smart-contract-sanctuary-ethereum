/**
 *Submitted for verification at Etherscan.io on 2022-05-09
*/

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Written by 0xInuarashi.eth || 0xinuarashi.dev || 0xInuarashi#1234 || twitter.com/0xinuarashi

abstract contract Ownable {
    address public owner; 
    constructor() { owner = msg.sender; }
    modifier onlyOwner { require(owner == msg.sender, "Not Owner!"); _; }
    function transferOwnership(address new_) external onlyOwner { owner = new_; }
}

contract CommitBasedRaffle is Ownable {

    // For a commit-based raffle, we need to store somewhere the index of users as well
    // as user-data.

    // Then, we can pull a seed with provably-fair randomness and then use
    // that randomness as intertia for a compute-intensive on-chain result.

    // Gas cost is conscious in this contract.

    // First, we define an interia.
    bytes32 public raffleInertia;
    
    // We then have a intertia pull method.
    function pullRaffleIntertia() external onlyOwner {
        // Pulling is a 1-time function.
        require(raffleInertia == 0,
            "Intertia already set");
        
        // // A pseudo-random generated bytes32. For provably-fair, change this.
        // raffleInertia = keccak256(abi.encodePacked(
        //     block.timestamp, block.difficulty, blockhash(block.number - 
        //         uint256(keccak256(abi.encodePacked(
        //             block.timestamp, block.difficulty, blockhash(block.number) ))) 
        //          % 256 )
        // ));

        // A pseudo-random generated bytes32. For provably-fair, change this.
        raffleInertia = keccak256(abi.encodePacked(
            block.timestamp, block.difficulty, blockhash(block.number)));
    }

    // Now, we need to set some commit-based raffle logics.
    struct CommitData {
        address entrant; // 20 | 12
        uint64 entries; // 8 | 4
    }

    // 2 SSTORE are necessary to do this on-chain with flexibility.
    CommitData[] public commitData;
    function viewCommitData() external view returns (CommitData[] memory) {
        return commitData;
    }

    // Then, we set some raffle logics
    // uint256 public weiPerEntry = 1 ether;

    function raffleCommit(uint256 amount_) public {
        // We hardcode weiPerEntry for gas savings
        uint64 _entries = uint64(amount_ / 1 ether);

        commitData.push( 
            CommitData(
                msg.sender, 
                _entries
        ));
    }

    function test_raffleCommit(uint256 amount_, uint256 repeat_) external {
        for (uint256 i = 0; i < repeat_; i++) {
            raffleCommit(amount_);
        }
    }

    // Now, we need to create some pulling logic. Gas intensive view-function.
    function _getTotalEntries() public view returns (uint256) {
        // Find the total entries
        uint256 _totalEntries;
        for (uint256 i = 0; i < commitData.length; i++) {
            _totalEntries += commitData[i].entries;
        }
        return _totalEntries;
    }
    function _getIntertiaOfIndex(uint256 index_, uint256 modulo_) public 
    view returns (uint256) {
        require(raffleInertia != 0, 
            "raffleIntertia not set yet!");
        
        return uint256(keccak256(abi.encodePacked(
            raffleInertia, index_
        ))) % modulo_;
    }
    function _getRaffleWinner(uint256 index_, uint256 modulo_) public 
    view returns (address) {
        // Find the total entries
        uint256 _modulo = modulo_ == 0 ? (_getTotalEntries() + 1) : modulo_;

        // Now, pull an intertia with the amount of entries
        uint256 _winningEntry = _getIntertiaOfIndex(index_, _modulo); 

        // Now, we find the winner of the index.
        uint256 _currentEntry;
        address _winner;
        uint256 i;
        while (_winner == address(0)) {
            uint256 _previousEntries = _currentEntry;
            _currentEntry += commitData[i].entries;
            if (_previousEntries < _winningEntry 
                && _currentEntry >= _winningEntry) { 
                _winner = commitData[i].entrant;
            }
            i++;
        }
        return _winner;
    }

    // Pagination for Read Limit Safety







    function viewRaffleResults(uint256 amountOfWinners_) external 
    view returns (address[] memory) {
        uint256 _totalEntries = _getTotalEntries() + 1;
        address[] memory _winners = new address[](amountOfWinners_);
        for (uint256 i = 0; i < amountOfWinners_; i++) {
            _winners[i] = _getRaffleWinner(i, _totalEntries);
        }
        return _winners;
    }
    function viewIntertiaResults(uint256 amountOfWinners_) external 
    view returns (uint256[] memory) {
        uint256 _totalEntries = _getTotalEntries() + 1;
        uint256[] memory _winners = new uint256[](amountOfWinners_);
        for (uint256 i = 0; i < amountOfWinners_; i++) {
            _winners[i] = _getIntertiaOfIndex(i, _totalEntries);
        }
        return _winners;
    }
}